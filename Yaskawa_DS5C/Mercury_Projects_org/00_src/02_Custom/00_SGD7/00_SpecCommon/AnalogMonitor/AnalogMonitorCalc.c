/****************************************************************************************************/
/*																									*/
/*																									*/
/*		AnalogMonitorCalc.c : パラメータ計算処理定義	<S016>										*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : パラメータ計算処理																		*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/************** Copyright (C) Yaskawa Electric Corporation ******************************************/
/*																									*/
/*	Note	:	初版	2013.10.02	K.Sakamoto	For Mercury											*/
/*																									*/
/*	Log		:	Ver1.00																				*/
/*																									*/
/****************************************************************************************************/
#include "Basedef.h"
#include "MercuryGlobals.h"
#include "XlsAmonDef.h"
#include "AnalogMonitorCalc.h"
#include "DataTraceCalc.h"
#include "GainChange.h"				/* GAIN1			*/
#include "KnlApi.h"					/* KPI_SBCYCLEUS	*/
#include "Memory.h"					/* <S074> */

/****************************************************************************************************/
/*																									*/
/*			アナログモニタ変数取得関数																*/
/*																									*/
/*			数値データを返す																		*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		00 :モータ回転速度																			*/
/*--------------------------------------------------------------------------------------------------*/
LONG	GetVarData_AmonMotSpd( void *Axis )
{
	return (((AXIS_HANDLE*)Axis)->BaseControls->MotSts.MotSpd);/*<S0EC>*/
//	return (((AXIS_HANDLE*)Axis)->UnMonitor->AmonSpdRef);/*<S0CD>*/
}
/*--------------------------------------------------------------------------------------------------*/
/*		01 :速度指令																				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonSpdRef( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		02 :トルク指令																				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonTrqRef( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		03:位置偏差																					*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonPosErra( void *Axis )	データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		04:位置アンプ偏差																			*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonPosErrx( void *Axis )	データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		05:位置指令速度																				*/
/*--------------------------------------------------------------------------------------------------*/
LONG	GetVarData_AmondPosCmdSmp( void *Axis )
{
	//return (((AXIS_HANDLE*)Axis)->BaseControls->PosManager.var.dPcmda);
	return (((AXIS_HANDLE*)Axis)->BaseControls->AmondPosCmd);	/* <S1B6> */
}
/*--------------------------------------------------------------------------------------------------*/
/*		07:モータ負荷間位置偏差																		*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_sfperra_per32s( void *Axis )	データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		09:速度フィードフォワード																	*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_SpdFFCx( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		0A:トルクフィードフォワード																	*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_TrqFFCx( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		0B:有効ゲイン																				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonActGain( void *Axis )	データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		0D:外部エンコーダ速度　																		*/
/*--------------------------------------------------------------------------------------------------*/
LONG	GetVarData_AmonFencSpdsmp( void *Axis )
{
//	return (((AXIS_HANDLE*)Axis)->FencV->MotSpd);		/* <S04D>：モータ回転速度に処理を合わせる	*/
	return (((AXIS_HANDLE*)Axis)->BaseControls->MotSts.FencSpd);
}
/*--------------------------------------------------------------------------------------------------*/
/*		40:位置ループ前位置指令速度				データトレースで定義済み(共通)	<S187>				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_dPosRefi( void *Axis )
//{
//	/* FIXME:暫定対応 */
//	return (((AXIS_HANDLE*)Axis)->BaseControls->PosManager.var.dPcmda);
//}
/*--------------------------------------------------------------------------------------------------*/
/*		41:摩擦補償トルク																			*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_AmonDisTrq( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		42:制振モニタ																				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_MonResVib( void *Axis )		データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		43:フィルタ前トルク指令																		*/
/*--------------------------------------------------------------------------------------------------*/
LONG	GetVarData_TrqRefBeforeComp( void *Axis )
{
	/* FIXME:暫定対応	SGDV:BoutV.TrqRefBeforeComp */
	//return 0;															/* <S14B> */
	//return (((AXIS_HANDLE*)Axis)->BaseLoops->RippleCmp.AmonTrqComp1);	/* <S14B> */
	return (((AXIS_HANDLE*)Axis)->BaseLoops->RippleCmp.TrqRefBeforeComp);	/* <S14B> *//* <S1FD> */
}

/*--------------------------------------------------------------------------------------------------*/
/*		44:d軸電流指令																				*/
/*--------------------------------------------------------------------------------------------------*/
LONG	GetVarData_AmonIdRef( void *Axis )
{
	/* FIXME:暫定対応	SGDV:BoutV.AmonIdRef */
	return 0;
}
/*--------------------------------------------------------------------------------------------------*/
/*		****:ダミー変数																				*/
/*--------------------------------------------------------------------------------------------------*/
//LONG	GetVarData_Dummy( void *Axis )			データトレースで定義済み(共通)
//
/*--------------------------------------------------------------------------------------------------*/
/*		<S074> 0xF0:Output Parameter Specified RAM Address											*/
/*--------------------------------------------------------------------------------------------------*/
#define LPX_GETRAMADDR( ax, ch )		(((AXIS_HANDLE *)(ax))->AmonOut[(ch)].Vaddr)
#define	ANLG_MON_CH0_SEL	0x0001		/* アナログモニタ出力電圧試験モード : Ch0選択 */	/* <S0FD> */
#define	ANLG_MON_CH1_SEL	0x0002		/* アナログモニタ出力電圧試験モード : Ch1選択 */	/* <S0FD> */

LONG GetVarData_AmonAdrOutCH0H( void *Axis ) { return (*( (USHORT *)LPX_GETRAMADDR( Axis, 0 ))); }
LONG GetVarData_AmonAdrOutCH0W( void *Axis ) { return (*(  (ULONG *)LPX_GETRAMADDR( Axis, 0 ))); }
LONG GetVarData_AmonAdrOutCH1H( void *Axis ) { return (*( (USHORT *)LPX_GETRAMADDR( Axis, 1 ))); }
LONG GetVarData_AmonAdrOutCH1W( void *Axis ) { return (*(  (ULONG *)LPX_GETRAMADDR( Axis, 1 ))); }



/****************************************************************************************************/
/*																									*/
/*			アナログモニタビット変数取得関数														*/
/*																									*/
/*			指定する軸のビットデータを返す															*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		08:位置決め完了指令																			*/
/*--------------------------------------------------------------------------------------------------*/
//BOOL	GetBitData_Coin( void *Axis )			データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		0C:指令払い出し完了																			*/
/*--------------------------------------------------------------------------------------------------*/
//BOOL	GetBitData_Den( void *Axis )			データトレースで定義済み(共通)
/*--------------------------------------------------------------------------------------------------*/
/*		****:ダミー変数																				*/
/*--------------------------------------------------------------------------------------------------*/
//BOOL	GetBitData_Dummy( void *Axis )
//{
//	return FALSE;
//}

/****************************************************************************************************/
/*																									*/
/*			アナログモニタのゲイン計算関数															*/
/*																									*/
/****************************************************************************************************/

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : Dummy														*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalDummy( void *Axis )
{
		return( 0x00000000 );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : モータ速度,速度指令 (2^24/OvrSpd --> 1V/1000min-1)			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ回転速度、速度ＦＦ、制振モニタ等速度関係(min-1単位)の								*/
/*			アナログモニタ出力用ゲイン計算。														*/
/*																									*/
/*					   OvrSpd		 60		    1			  1			   1						*/
/*			Mgain = ------------ * ------- * -------- = -------------- * ------						*/
/*					 0x01000000     2*PAI	   1000		 Bprm.Knorspd	  1000						*/
/*																									*/
/*			OvrSpd   : 最大速度 [rad/s]																*/
/*			Knorspd	 : 正規化速度演算係数(r/min,mm/s --> NormalizedSpeed)							*/
/*			電圧換算 : 1V/1000rpm = 1/1000															*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalMotorSpeed( void *Axis )
{
	LONG	kx;		/* ゲイン	*/
	LONG	sx;		/* シフト数	*/

	kx = MlibScalKxgain( 1, 1, 1000, &sx, 0 );
	kx = MlibPcalKxkxks( kx, 1, ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->Knorspd, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : モータ回転速度 (dMotPos/ScanB --> 1V/1000min-1)				*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ回転速度(min-1単位)のアナログモニタ出力用ゲイン計算。								*/
/*																									*/
/*			MonSpd = Mgain * BinK.dMotPos		(BinK.dMotPos : pulse/ScanB)						*/
/*																									*/
/*					  Hprm.Kmotspd	    1000000		  1												*/
/*			Mgain  = -------------- * ----------- * ------											*/
/*					  Bprm.Knorspd	   SBCYCLEUS	 1000											*/
/*																									*/
/*			Kmotspd   : モータ速度演算ゲイン：[pulse/sec]  --> [2^24/OvrSpd]						*/
/*			Knorspd	  : 正規化速度演算係数  ：[r/min,mm/s] --> [NormalizedSpeed]					*/
/*			SBCYCLEUS : スキャンＢサイクルタイム [us]												*/
/*			電圧換算  : 1V/1000rpm = 1/1000															*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalMotPfbkSpd( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/
	LONG	plsno;	/* モータ速度演算ゲイン	*/
//	LONG	Egear_a;	/* 電子ギア分母			*/	/* <S1A7> *//* <S203> */
//	LONG	Egear_b;	/* 電子ギア分子			*/	/* <S1A7> *//* <S203> */

	/* FIXME:暫定対応 */
#if 0
	if( Kprm.f.FencUse )
	{
		plsno = Hprm.KmotspdFC;
	}
	else
	{
		plsno = Hprm.Kmotspd;
	}
#else
	plsno = ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->Kmotspd;
#endif

	kx = MlibScalKxgain( 1, 1000, KPI_SBCYCLEUS, &sx, 0 );
	kx = MlibPcalKxksks( kx, plsno, ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->Knorspd, &sx, -1 );

/* <S1A7> */
//	Egear_a = ((AXIS_HANDLE*)Axis)->BaseControls->PosManager.conf.Egear.a;/* <S203> */
//	Egear_b = ((AXIS_HANDLE*)Axis)->BaseControls->PosManager.conf.Egear.b;/* <S203> */
//	kx = MlibPcalKxgain( kx, Egear_b, Egear_a, &sx, -1 );/* <S203> */
/* <S1A7> */

	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : 位置指令速度 (dPosCmda/ScanB --> 1V/1000min-1)				*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 位置指令速度(min-1単位)のアナログモニタ出力用ゲイン計算。								*/
/*																									*/
/*			MonSpd = Mgain * dPosCmda			(dPosCmda : pulse/ScanB)							*/
/*																									*/
/*					  Iprm.Egear.b     Hprm.Kmotspd	    1000000	       1							*/
/*			Mgain  = -------------- * -------------- * ----------- * ------							*/
/*					  Iprm.Egear.a     Bprm.Knorspd	    SBCYCLEUS     1000							*/
/*																									*/
/*			Kmotspd   : モータ速度演算ゲイン：[pulse/sec]  --> [2^24/OvrSpd]						*/
/*			Knorspd	  : 正規化速度演算係数  ：[r/min,mm/s] --> [NormalizedSpeed]					*/
/*			SBCYCLEUS : スキャンＢサイクルタイム [us]												*/
/*			電圧換算  : 1V/1000rpm = 1/1000															*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalPosCmdaSpd( void *Axis )
{
	LONG	kx;			/* ゲイン				*/
	LONG	sx;			/* シフト数				*/
	LONG	plsno;		/* モータ速度演算ゲイン	*/
	LONG	Egear_a;	/* 電子ギア分母			*/
	LONG	Egear_b;	/* 電子ギア分子			*/

	/* FIXME:暫定対応 */
#if 0
	if( Kprm.f.FencUse )
	{
		plsno = Hprm.KmotspdFC;
	}
	else
	{
		plsno = Hprm.Kmotspd;
	}
#else
	plsno = ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->Kmotspd;
#endif

	kx = MlibScalKxgain( 1, 1000, KPI_SBCYCLEUS, &sx, 0 );
	kx = MlibPcalKxksks( kx, plsno, ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->Knorspd, &sx, 0 );

	/* FIXME:暫定対応 */
#if 0
#if( LESS_DEVIATION_CTRL != 0 )
	/* (偏差レス制御無効 && モデル追従制御無効) || PJOG有効 */
	if( (Kprm.f.NctErrLessUse == FALSE) && (Gprm.MFCModel == 0) || (BoutV.CtrlMode.us[0] == CTRLMODE_PJOG) )
	{	
		kx = MlibPcalKxgain( kx, Iprm.Egear.b, Iprm.Egear.a,  &sx, -1 );
	}
	else											/* 上記以外 */
	{
		kx = MlibPcalKxgain( kx, Iprm.NctEgear.b, Iprm.NctEgear.a,  &sx, -1 );
	}
#else
	kx = MlibPcalKxgain( kx, Iprm.Egear.b, Iprm.Egear.a,  &sx, -1 );
#endif
#else
	Egear_a = ((AXIS_HANDLE*)Axis)->BaseControls->PosManager.conf.Egear.a;
	Egear_b = ((AXIS_HANDLE*)Axis)->BaseControls->PosManager.conf.Egear.b;
	kx = MlibPcalKxgain( kx, Egear_b, Egear_a, &sx, -1 );
#endif

	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : トルク指令 (2^24/MaxTrq --> 1V/100%)							*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルクＦＦ、モデルトルク指令、外乱オブザーバ、推定外乱トルク等の						*/
/*			アナログモニタ出力用ゲイン計算。														*/
/*																									*/
/*					   MaxTrq		 1																*/
/*			Mgain = ------------ * -----															*/
/*					 0x01000000     100																*/
/*																									*/
/*			MaxTrq   : 最大トルク [%]																*/
/*			電圧換算 : 0.01V/% = 1/100																*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalTorqueRef( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->PerMaxTrq, 1, 100, &sx, 0 );
	kx = MlibPcalKxgain( kx, 1, 0x01000000, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : トルク指令 (15000/MaxTrq --> 1V/100%)						*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令（電流制限後最終ｑ軸電流指令）のアナログモニタ出力用ゲイン計算。				*/
/*																									*/
/*					   MaxTrq		 1																*/
/*			Mgain = ------------ * -----															*/
/*					   15000		100																*/
/*																									*/
/*			MaxTrq   : 最大トルク [%]																*/
/*			電圧換算 : 0.01V/% = 1/100																*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalTrqRef15K( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( ((AXIS_HANDLE*)Axis)->UniPrms->Bprm->PerMaxTrq, 1, (100 * 15000), &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : 位置偏差 (0.05V/1指令単位)									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 位置偏差のアナログモニタ出力用ゲイン計算。												*/
/*																									*/
/*					   1																			*/
/*			Mgain = ------																			*/
/*					  20																			*/
/*																									*/
/*			電圧換算 : 0.05V/1pulse = 1/20															*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalPulseError( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( 1, 1, 20, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : モータ負荷間位置偏差 (0.01V/1指令単位)						*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 位置偏差のアナログモニタ出力用ゲイン計算。												*/
/*																									*/
/*					  1																				*/
/*			Mgain = -----																			*/
/*					 100																			*/
/*																									*/
/*			電圧換算 : 0.01V/1pulse = 1/100															*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalPulseErr01( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( 1, 1, 100, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : ビット信号 (ON:5V, OFF:0V)									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ビット信号のアナログモニタ出力用ゲイン計算。											*/
/*					 																				*/
/*			Mgain = 5																				*/
/*																									*/
/*			電圧換算 : 5V/1 = 5																		*/
/*			入力信号 : ON = 1, OFF = 0																*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalBitSignal( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( 1, 5, 1, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : 有効ゲイン (第1:1V, 第2:2V, 第3:3V, 第4:4V)					*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 有効ゲインのアナログモニタ出力用ゲイン計算。自動ゲイン切替時定数に対応すること			*/
/*																									*/
/*						1																			*/
/*			Mgain = --------- 																		*/
/*					  GAIN1																			*/
/*																									*/
/*			電圧換算 : 1V/GAIN1																		*/
/*			入力信号 : 第1:GAIN1=2^22, 第2:GAIN2=2*(2^22), 第3:GAIN3=3*(2^22), 第4:GAIN4=4*(2^22)	*/
/*																									*/
/****************************************************************************************************/
KSGAIN	AmonGcalActGain( void *Axis )
{
	LONG	kx;		/* ゲイン				*/
	LONG	sx;		/* シフト数				*/

	kx = MlibScalKxgain( -1, 1, GAIN1, &sx, -1 );
	return( kx );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : アナログモニタ用のパラメータ(変数アドレス,データサイズ,出力ゲイン)計算を行う。			*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*	補足1 :	アナログモニタＨＷ仕様																	*/
/*--------------------------------------------------------------------------------------------------*/
/*			 1.000V : 3369.976																		*/
/*			10.000V : 33699.76																		*/
/*--------------------------------------------------------------------------------------------------*/
/*	補足2 :	アナログモニタ信号選択／オフセット電圧													*/
/*--------------------------------------------------------------------------------------------------*/
/*			  CH0	    CH1		  説明																*/
/*		   -----------------------------------------------------------------------------			*/
/*			Pn006.0 / Pn007.0 : アナログモニタ信号選択												*/
/*			Pn006.1 / Pn007.1 : アナログモニタ信号選択												*/
/*			Pn006.2 / Pn007.2 : 予備																*/
/*			Pn006.3 / Pn007.3 : 予備																*/
/*			Pn550   / Pn551   : オフセット電圧 (-1000.0〜+1000.0V)									*/
/*			Pn552   / Pn553   : 倍率																*/
/*--------------------------------------------------------------------------------------------------*/
/*	補足3 : アナログモニタ出力ゲイン＆シフト倍率													*/
/*--------------------------------------------------------------------------------------------------*/
/*			CH0 : PnE42= n.XAAA  X(左シフト数),AAA(ゲイン)											*/
/*			CH1 : PnE43= n.YBBB  Y(左シフト数),BBB(ゲイン)											*/
/*--------------------------------------------------------------------------------------------------*/
/*	補足4 : アナログモニタ出力ゼロ調＆ゲイン調														*/
/*--------------------------------------------------------------------------------------------------*/
/*			PnE58 : アナログモニタ出力ゼロ調(Lo:CH0,Hi:CH1)											*/
/*			PnE59 : アナログモニタ出力ゲイン調(Lo:CH0,Hi:CH1)										*/
/*																									*/
/*																									*/
/****************************************************************************************************/
#define AMON_OFFSET_P1V		337						/* Offset    [0.1V=337]							*/
#define	AMON_HWGAIN_1000V	3369976					/* H/W Gain  [1000V=3369976]					*/
/*--------------------------------------------------------------------------------------------------*/
void	PcalAnalogMonitorGain( AXIS_HANDLE *Axis, LONG chx )
{
	LONG	Index;
	LONG	Gsftx;
	LONG	Gadjx;
	LONG	Xgain;
	LONG	Mgain;
	LONG	AmonPrmx;
	AMONOUT	*AmonOutx;								/* アナログモニタデータへのポインタ			*/
	PRMDATA	*Prm;									/* パラメータ設定データへのポインタ			*/
	CMN_PRMDATA	*Cprm;								/* ユニット共通パラメータ設定データへのポインタ	*/

	/* 変数初期化	*/
	Prm = Axis->UniPrms->Prm;						/* パラメータ設定データ			*/
	Cprm = Axis->UniPrms->Cprm;						/* ユニット共通パラメータ設定データ	*/

/*--------------------------------------------------------------------------------------------------*/
/*		ＣＨ選択処理																				*/
/*--------------------------------------------------------------------------------------------------*/
	if( chx == 0 )									/* アナログモニタＣＨ０						*/
	{
//		AmonPrmx = Prm->b_prm6;						/* CH0 Parameter							*/
		AmonPrmx = Cprm->b_prm6;					/* CH0 Parameter							*//* 2軸目アナログモニタ対応<S103> */
//		Xgain = (LONG)((SHORT)Prm->mongain1);		/* CH0 Gain Parameter						*//* <S0DF> */
		Xgain = (LONG)((SHORT)Cprm->mongain1);		/* CH0 Gain Parameter						*//* <S0DF> */
		AmonOutx = (AMONOUT*)&(Axis->AmonOut[0]);	/* OutData Pointer							*/
		Gadjx = (CHAR)Cprm->mnag0_1.b.l;				/* Gain Adjust Data							*/
//		Gsftx = -((USHORT)Prm->mnrng0 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆	*//* <S0DF> */
		Gsftx = -((USHORT)Cprm->mnrng0 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆	*//* <S0DF> */
	}
	/*----------------------------------------------------------------------------------------------*/
	else											/* アナログモニタＣＨ１		*/
	{
//		AmonPrmx = Prm->b_prm7;						/* CH1 Parameter							*/
		AmonPrmx = Cprm->b_prm7;					/* CH1 Parameter							*//* 2軸目アナログモニタ対応<S103> */
//		Xgain = (LONG)((SHORT)Prm->mongain2);		/* CH1 Gain Parameter						*//* <S0DF> */
		Xgain = (LONG)((SHORT)Cprm->mongain2);		/* CH1 Gain Parameter						*//* <S0DF> */
		AmonOutx = (AMONOUT*)&(Axis->AmonOut[1]);	/* OutData Pointer							*/
		Gadjx = (CHAR)Cprm->mnag0_1.b.h;				/* Gain Adjust Data							*/
//		Gsftx = -((USHORT)Prm->mnrng1 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆	*//* <S0DF> */
		Gsftx = -((USHORT)Cprm->mnrng1 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆	*//* <S0DF> */
	}
/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタ出力ゲイン共通部の計算														*/
/*--------------------------------------------------------------------------------------------------*/
/*																									*/
/*				   Magni * (Gadjx + 256) * (2^Gsftx)	  -AMON_HWGAIN_1V * Func().rv				*/
/*		Mgain = -------------------------------------- * -----------------------------				*/
/*				    100	 *		256									1								*/
/*																									*/
/*		Magni : アナログモニタ信号倍率	 [1/100]	--- Pn552 / Pn553(SGDV)							*/
/*		Gadjx : アナログモニタゲイン調	 [1/256]	---	PnE59(Lo/Hi)								*/
/*		Gsftx : アナログモニタシフト倍率 [-]		---	PnE42.3 / PnE43.3							*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタ出力ゲイン計算：未定義														*/
/*--------------------------------------------------------------------------------------------------*/
	if( (Index = LpxSearchAmonDefTable( AmonPrmx & 0xFF )) < 0 )
	{
		AmonOutx->Enable = FALSE;					/* 書き込み中	*/
		AmonOutx->Mgain = 0x0000;
		AmonOutx->Vtype = XAMDEF_VxLONG;
		AmonOutx->GetVarData = GetVarData_Dummy;
		AmonOutx->Enable = TRUE;					/* 書き込み完了	*/
	}
/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタ出力ゲイン計算：Prm指定変数													*/
/*--------------------------------------------------------------------------------------------------*/
	else if( AmonDefTbl[Index].Vtype == XAMDEF_VxPRMVAR )
	{
		LONG  Hgain = MlibPcalKxgain( Xgain, (Gadjx + 256), (100*256), &Gsftx, -1 );
		LpxGcalPrmVariable( Axis, AmonOutx, Hgain );
	}
/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタ出力ゲイン計算：Xls定義Bit変数												*/
/*--------------------------------------------------------------------------------------------------*/
	else if( AmonDefTbl[Index].Vtype == XAMDEF_VxBIT )
	{
	/*------------------------------------------------------------------------------------------*/
		Mgain = AmonDefTbl[Index].GetVarGain( Axis );
		Mgain = MlibPcalKskxkx( Mgain, Xgain * (Gadjx + 256), (100*256), &Gsftx,   0 );
		Mgain = MlibPcalKxgain( Mgain,  AMON_HWGAIN_1000V,     1000,     &Gsftx, -24 );
	/*------------------------------------------------------------------------------------------*/
		AmonOutx->Enable = FALSE;					/* 書き込み中	*/
		AmonOutx->Mgain = Mgain;
		AmonOutx->Vtype = XAMDEF_VxBIT;
		AmonOutx->GetVarData = AmonDefTbl[Index].GetVarData;
		AmonOutx->Enable = TRUE;					/* 書き込み完了	*/
	}
/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタ出力ゲイン計算：Xls定義Long/Short変数											*/
/*--------------------------------------------------------------------------------------------------*/
	else
	{
		Mgain = AmonDefTbl[Index].GetVarGain( Axis );
		Mgain = MlibPcalKskxkx( Mgain, Xgain * (Gadjx + 256), (100*256), &Gsftx,   0 );
		Mgain = MlibPcalKxgain( Mgain, -AMON_HWGAIN_1000V,     1000,     &Gsftx,  24 );
	/*------------------------------------------------------------------------------------------*/
		AmonOutx->Enable = FALSE;					/* 書き込み中	*/
		AmonOutx->Mgain = Mgain;
		AmonOutx->Vtype = AmonDefTbl[Index].Vtype;
		AmonOutx->GetVarData = AmonDefTbl[Index].GetVarData;
		AmonOutx->Enable = TRUE;					/* 書き込み完了	*/
	}
/*--------------------------------------------------------------------------------------------------*/
	return;
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力オフセット計算															*/
/*																									*/
/****************************************************************************************************/
void	PcalAnalogMonitorOffset( AXIS_HANDLE *Axis, LONG chx )
{
	LONG	Offset;
//	PRMDATA	*Prm;									/* パラメータ設定データへのポインタ				*//* <S0DF> */
	CMN_PRMDATA	*Cprm;								/* ユニット共通パラメータ設定データへのポインタ	*/

	/* 変数初期化	*/
//	Prm = Axis->UniPrms->Prm;						/* パラメータ設定データ							*//* <S0DF> */
	Cprm = Axis->UniPrms->Cprm;						/* ユニット共通パラメータ設定データ				*/

/*--------------------------------------------------------------------------------------------------*/
/*		Analog Monitor Offset Cal.																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( chx == 0 )
	{
//		Offset = (Cprm->mnaz0_1.b.l<<6) - 1302 - ((SHORT)Prm->monoffset1 * AMON_OFFSET_P1V);		  /* <S0DF> */
//		Offset = (Cprm->mnaz0_1.b.l<<6) - 1302 - ((SHORT)Cprm->monoffset1 * AMON_OFFSET_P1V);		  /* <S0DF> */	/* <S100> */
		Offset = ((CHAR)Cprm->mnaz0_1.b.l<<6) - 1302 - ((SHORT)Cprm->monoffset1 * AMON_OFFSET_P1V);	  /* <S0DF> */	/* <S100> */
		((AMONOUT*)Axis->AmonOut)[0].Offset = Offset;
	}
	else
	{
//		Offset = (Cprm->mnaz0_1.b.h<<6) - 1302 - ((SHORT)Prm->monoffset2 * AMON_OFFSET_P1V);		  /* <S0DF> */
//		Offset = (Cprm->mnaz0_1.b.h<<6) - 1302 - ((SHORT)Cprm->monoffset2 * AMON_OFFSET_P1V);		  /* <S0DF> */	/* <S100> */
		Offset = ((CHAR)Cprm->mnaz0_1.b.h<<6) - 1302 - ((SHORT)Cprm->monoffset2 * AMON_OFFSET_P1V);	  /* <S0DF> */	/* <S100> */
		((AMONOUT*)Axis->AmonOut)[1].Offset = Offset;
	}
/*--------------------------------------------------------------------------------------------------*/
	return;
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ定義テーブル検索																*/
/*																									*/
/****************************************************************************************************/
LONG	LpxSearchAmonDefTable( LONG SelNo )
{
	LONG	i;
	LONG	w;
	LONG	EntNum = AMONDEFTBL_ENTNUM;							

/*--------------------------------------------------------------------------------------------------*/
/*		検索開始Indexの設定																			*/
/*--------------------------------------------------------------------------------------------------*/
	w = (1 << MlibSrhbiton( EntNum - 1, SRH_FROM_MSB ));	/* 分割幅初期値設定					*/
	i = (SelNo >= AmonDefTbl[w].SelNo)? (EntNum - w) : 0;	/* 検索開始Index設定				*/
/*--------------------------------------------------------------------------------------------------*/
/*		テーブル検索																				*/
/*--------------------------------------------------------------------------------------------------*/
	for( w = w>>1; w > 0; w = w>>1 )						/* 検索Loop							*/
	{
		if( SelNo >= AmonDefTbl[i+w].SelNo ){ i = i + w;}	/* 比較＆Index更新					*/
	}
/*--------------------------------------------------------------------------------------------------*/
/*		検索結果のチェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( SelNo != AmonDefTbl[i].SelNo )						/* 検索結果チェック					*/
	{
		i = -1;												/* 検索失敗(SelNo無し)				*/
	}
	return( i );
}

/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力ゲイン計算 : Prm指定変数													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 下記パラメータで設定される変数をアナログモニタに出力するゲイン計算。					*/
/*						Addr																		*/
/*			No. 	(High)	(Low)	 Gain															*/
/*		------------------------------------------------------------------------					*/
/*			CH0		PnE49	PnE48	 PnE42= n.XAAA  X(左ｼﾌﾄ数),AAA(ｹﾞｲﾝ)							*/
/*			CH1		PnE4B 	PnE4A	 PnE43= n.YBBB  Y(左ｼﾌﾄ数),BBB(ｹﾞｲﾝ)							*/
/*		------------------------------------------------------------------------					*/
/*																									*/
/*																									*/
/*				  PnE42/PnE43(0〜2桁目)																*/
/*		Mgain  = ----------------------- * Hgain													*/
/*						  4096																		*/
/*																									*/
/*				 Magni     (Gadjx + 256)															*/
/*		Hgain = ------- * --------------- * (1 << PnE42.3/PnE43.3)									*/
/*				  100			 256																*/
/*																									*/
/****************************************************************************************************/
#if 0	/* <S074> */
void	LpxGcalPrmVariable( AXIS_HANDLE *Axis, AMONOUT *AmonOutx, LONG Hgain )
{
	LONG	Gainx;
	ULONG	MonAdr;
	/* FIXME:暫定処置 */
#if 0
	USHORT	*PxAsicData;
	VUSHORT	**PxAsicAddr;
#endif
	PRMDATA	*Prm;									/* パラメータ設定データへのポインタ			*/

	/* 変数初期化	*/
	Prm = Axis->UniPrms->Prm;						/* パラメータ設定データ	*/


/*--------------------------------------------------------------------------------------------------*/
/*		モニタＣＨ個別データ設定																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( AmonOutx == (AMONOUT*)&(Axis->AmonOut[0]) )				/* モニタＣＨ０							*/
	{
		MonAdr = Prm->mnptr0l;
		Gainx  = ((LONG)(Prm->mnrng0 << 20) >> 16);
/* FIXME:暫定処置 */
#if 0
		PxAsicData = &BinK.AsicMon0;
		PxAsicAddr = &Gprm.AsicMonAdr0;
#endif
	}
	/*----------------------------------------------------------------------------------------------*/
	else												/* モニタＣＨ１							*/
	{
		MonAdr = Prm->mnptr1l;
		Gainx  = ((LONG)(Prm->mnrng1 << 20) >> 16);
#if 0
		PxAsicData = &BinK.AsicMon1;
		PxAsicAddr = &Gprm.AsicMonAdr1;
#endif
	}
/*--------------------------------------------------------------------------------------------------*/
/*		変数アドレス＆変数サイズ設定																*/
/*--------------------------------------------------------------------------------------------------*/
#if 0
	switch( KpiCheckReadMemAddr( MonAdr, 1 ) )
	{
	case KPI_CHKRDMEM_NG:	/* No Variable Memory : Set to Dummy Variable						*/
		 *PxAsicAddr = (USHORT *)&ReadDummy.Ushort[0];
		 MonAdr = (ULONG)&ReadDummy.Ushort[0];
		 break;
	case KPI_CHKRDMEM_MREG:	/* ASIC Micro Register : ScanA Read Register synchronously			*/
		 *PxAsicAddr = (USHORT *)MonAdr;
		 MonAdr = (ULONG)PxAsicData;
		 break;
	default:				/* Other Variables : RAM Variable, ASIC H/W Register, etc	 		*/
		 *PxAsicAddr = (USHORT *)&ReadDummy.Ushort[0];
		 break;
	}
#endif
/*--------------------------------------------------------------------------------------------------*/
/*		モニタ出力ゲインの計算																		*/
/*--------------------------------------------------------------------------------------------------*/
	Gainx = MlibScalKskxkx( Hgain, -Gainx, 4096, NULL, 24 );
/*--------------------------------------------------------------------------------------------------*/
/*		モニタ出力データの設定																		*/
/*--------------------------------------------------------------------------------------------------*/
	AmonOutx->Enable = FALSE;			/* 書き込み中	*/
	AmonOutx->Mgain = Gainx;
	AmonOutx->Vtype = XAMDEF_VxSHORT;
//	AmonOutx->Vaddr = (void *)MonAdr;
	AmonOutx->GetVarData = GetVarData_Dummy;
	AmonOutx->Enable = TRUE;			/* 書き込み完了	*/
/*--------------------------------------------------------------------------------------------------*/
	return;
}
#endif
void	LpxGcalPrmVariable( AXIS_HANDLE *Axis, AMONOUT *AmonOutx, LONG Hgain )	/* <S074> */
{
LONG	Chx;
LONG	Sizex;
LONG	Gainx;
ULONG	MemAdr;
ULONG	*pVarAdr;
//PRMDATA	*pPrm; /* <S0DF> */
CMN_PRMDATA	*Cprm;								/* ユニット共通パラメータ設定データへのポインタ	*/
LONG	(*pFunc)(void *);

	/* 変数初期化	*/
//	pPrm = Axis->UniPrms->Prm; /* <S0DF> */
	Cprm = Axis->UniPrms->Cprm; /* <S0DF> */
	Chx = (( AmonOutx == (AMONOUT*)&(Axis->AmonOut[0]) ) ? 0 : 1 );

/*--------------------------------------------------------------------------------------------------*/
/*		Set MemAddr, Gain, etc																		*/
/*--------------------------------------------------------------------------------------------------*/
	if( Chx == 0 )											/* Monitor CH: 0						*/
	{
//		pVarAdr = &(pPrm->mnptr0l);					/* <S0DF> */
//		Gainx  = ((LONG)(pPrm->mnrng0 << 20) >> 16);/* <S0DF> */
		pVarAdr = &(Cprm->mnptr0l);					/* <S0DF> */
		Gainx  = ((LONG)(Cprm->mnrng0 << 20) >> 16);/* <S0DF> */
	}
	/*----------------------------------------------------------------------------------------------*/
	else													/* Monitor CH: 1						*/
	{
//		pVarAdr = &(pPrm->mnptr1l);					/* <S0DF> */
//		Gainx  = ((LONG)(pPrm->mnrng1 << 20) >> 16);/* <S0DF> */
		pVarAdr = &(Cprm->mnptr1l);					/* <S0DF> */
		Gainx  = ((LONG)(Cprm->mnrng1 << 20) >> 16);/* <S0DF> */
	}

/*--------------------------------------------------------------------------------------------------*/
/*		Search Memory Address																		*/
/*--------------------------------------------------------------------------------------------------*/
	MemAdr = KpiFindMemNextAddress( *pVarAdr, (ULONG)(AmonOutx->Vaddr) );
	Sizex = KpiGetMemAccessSize( MemAdr );					/* Get AccessSize[byte] 				*/

/*--------------------------------------------------------------------------------------------------*/
/*		Check Memory Address																		*/
/*--------------------------------------------------------------------------------------------------*/
	switch ( KpiCheckReadMemAddr( MemAdr, Sizex>>1 ) )
	{
	case MEMDEF_READ_NG:									/* Read NG */
		MemAdr = (ULONG)&(ReadDummy.dw);					/* Dummy Address */
		pFunc = GetVarData_Dummy;							/* Set Dummy Function */
		*pVarAdr = MemAdr;									/* Update PnE48/PnE4A for Monitor */
		break;
	default:												/* Read OK */
		*pVarAdr = MemAdr;									/* Update PnE48/PnE4A for Monitor  */
	/*----------------------------------------------------------------------------------------------*/
	/*	Set Access Function																			*/
	/*----------------------------------------------------------------------------------------------*/
		switch( Chx )
		{
		case 0: 
			pFunc = (( Sizex == 4 ) ? GetVarData_AmonAdrOutCH0W : GetVarData_AmonAdrOutCH0H );
			break;
		case 1:
			pFunc = (( Sizex == 4 ) ? GetVarData_AmonAdrOutCH1W : GetVarData_AmonAdrOutCH1H );
			break;
		default: 
			pFunc = GetVarData_Dummy;
			break;
		}
	/*----------------------------------------------------------------------------------------------*/
		break;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		Calculate Monitor Gain																		*/
/*--------------------------------------------------------------------------------------------------*/
	Gainx = MlibScalKskxkx( Hgain, -Gainx, 4096, NULL, 24 );

/*--------------------------------------------------------------------------------------------------*/
	AmonOutx->Enable = FALSE;												/* 書き込み中	*/
	AmonOutx->Mgain = Gainx;												/* Monitor Gain */
	AmonOutx->Vtype = ((Sizex == 4 ) ? XAMDEF_VxLONG : XAMDEF_VxSHORT);		/* @@ check */
	AmonOutx->GetVarData = pFunc;											/* Read Function */
	AmonOutx->Vaddr = (void *)MemAdr;										/* Memory Address */
	AmonOutx->Enable = TRUE;												/* 書き込み完了	*/
/*--------------------------------------------------------------------------------------------------*/
	return;
}


/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力処理																		*/
/*																									*/
/****************************************************************************************************/
void	BpxOutputAnalogMonitor( AXIS_HANDLE *Axis )
{
	LONG	AmonCh0;
	LONG	AmonCh1;
	AMONOUT	*AmonOut;
	LONG	Lvalue;
	SHORT	Svalue;
	BOOL	Bvalue;
	FUN_CMN_CONTROL			*FnCmnCtrl;	/* <S0FD> */
	CMN_PRMDATA	*Cprm;					/* ユニット共通パラメータ設定データへのポインタ<S103>	*/
	LONG 	ax_No;						/* SGD7W用軸番号 <S103> */

	AmonOut = (AMONOUT*)&(Axis->AmonOut[0]);
	FnCmnCtrl = Axis->FnCmnCtrl;				/* <S0FD> */

	Cprm = Axis->UniPrms->Cprm;					/* <S103> */

#if 0	/* <S0FD> Delete Start : 仕様変更によりコメントアウト */
/* <S0E7> Start */
	if( (( AmonOut[0].RegVoltMon_Flag_Ch0 == TRUE  )) || (( AmonOut[0].RegVoltMon_Flag_Ch1 == TRUE  )) )
	{
		return;
	}
/* <S0E7> End */
#endif	/* <S0FD> Delete Start : 仕様変更によりコメントアウト */

/* <S0FD> Start */
	if( FnCmnCtrl->AnlgMonVoltTstFlag == TRUE )
	{
		/*	アナログモニタ出力電圧確認試験中フラグ(AnlgMonVoltTstFlag) = TRUEの場合は､	*/
		/*	通常アナログモニタ出力処理を実施しせずに「アナログモニタ出力試験モード」を実行する。*/

		if( FnCmnCtrl->AnlgMonVoltTstChSel == ANLG_MON_CH0_SEL )
		{/* アナログモニタ出力電圧確認試験対象 = Ch0 */
		
			/* アナログモニタCh0にて設定電圧を出力する。 */
			ax_No = ((Cprm->b_prm6 & 0x1000) >> 12);		/* アナログモニタ2軸選択対応<S103> */
			FnOutputAnalogMonitor( &Axis[ax_No], FnCmnCtrl->OutputVoltVal_Ch0, 0 );
		
		}
		else if( FnCmnCtrl->AnlgMonVoltTstChSel == ANLG_MON_CH1_SEL )
		{/* アナログモニタ出力電圧確認試験対象 = Ch1 */

			/* アナログモニタCh1にて設定電圧を出力する。 */
			ax_No = ((Cprm->b_prm7 & 0x1000) >> 12);		/* アナログモニタ2軸選択対応<S103> */
			FnOutputAnalogMonitor( &Axis[ax_No], FnCmnCtrl->OutputVoltVal_Ch1, 1 );

		}
		
		return;
	}
/* <S0FD> end */


/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタＣＨ０出力																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( AmonOut[0].Enable == TRUE )
	{
		ax_No = ((Cprm->b_prm6 & 0x1000) >> 12);				/* アナログモニタ2軸選択対応<S103>	*//* <S1CB> */
		if( ax_No >= MAX_AXIS_NUMBER ){							/* 単軸時の誤設定無効化				*/
			ax_No = MAX_AXIS_NUMBER - 1; }

		switch( AmonOut[0].Vtype )
		{
		case XAMDEF_VxLONG:  /* LONG Variable	*/
			Lvalue = AmonOut[0].GetVarData( &Axis[ax_No] );
			AmonCh0 = MlibMulgain( Lvalue, AmonOut[0].Mgain );
			break;
		case XAMDEF_VxSHORT: /* SHORT Variable	*/
			Svalue = AmonOut[0].GetVarData( &Axis[ax_No] );
			AmonCh0 = MlibMulgain( Svalue, AmonOut[0].Mgain );
			break;
		case XAMDEF_VxBIT:	 /* Bit Signal		*/
			Bvalue = AmonOut[0].GetVarData( &Axis[ax_No] );
			if( Bvalue == TRUE )
			{
				AmonCh0 = AmonOut[0].Mgain;
			}
			else
			{
				AmonCh0 = 0;
			}
			break;
		default:			 /* Default			*/
			 AmonCh0 = 0;
			 break;
		}
	/*----------------------------------------------------------------------------------------------*/
		AmonCh0 += AmonOut[0].Offset;								/* Offset加算					*/
		Axis->SvAsicRegs->AsicHwReg->AREG_PWMU = MlibLimitul( AmonCh0, 0x7FFF, -0x7FFF );	/* アナログモニタ出力			*/
	}
/*--------------------------------------------------------------------------------------------------*/
/*		アナログモニタＣＨ１出力																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( AmonOut[1].Enable == TRUE )
	{
		ax_No = ((Cprm->b_prm7 & 0x1000) >> 12);				/* アナログモニタ2軸選択対応<S103>	*//* <S1C9> */
		if( ax_No >= MAX_AXIS_NUMBER ){							/* 単軸時の誤設定無効化				*/
			ax_No = MAX_AXIS_NUMBER - 1; }

		switch( ((AMONOUT*)Axis->AmonOut)[1].Vtype )
		{
		case XAMDEF_VxLONG:  /* LONG Variable	*/
			Lvalue = AmonOut[1].GetVarData( &Axis[ax_No] );
			AmonCh1 = MlibMulgain( Lvalue, AmonOut[1].Mgain );
			break;
		case XAMDEF_VxSHORT: /* SHORT Variable	*/
			Svalue = (SHORT)AmonOut[1].GetVarData( &Axis[ax_No] );
			AmonCh1 = MlibMulgain( Svalue, AmonOut[1].Mgain );
			break;
		case XAMDEF_VxBIT:	 /* Bit Signal		*/
			Bvalue = AmonOut[1].GetVarData( &Axis[ax_No] );
			if( Bvalue == TRUE )
			{
				AmonCh1 = AmonOut[1].Mgain;
			}
			else
			{
				AmonCh1 = 0;
			}
			break;
		default:			 /* LONG Variable	*/
			AmonCh1 = 0;
			break;
		}
	/*----------------------------------------------------------------------------------------------*/
		AmonCh1 +=  AmonOut[1].Offset;								/* Offset加算					*/
		Axis->SvAsicRegs->AsicHwReg->AREG_PWMV = MlibLimitul( AmonCh1, 0x7FFF, -0x7FFF );	/* アナログモニタ出力			*/
	}
/*--------------------------------------------------------------------------------------------------*/
	return;
}

/* <S0E7> Start */
/****************************************************************************************************/
/*																									*/
/*		アナログモニタ出力処理(レジスタアクセス)													*/
/*																									*/
/*		機能：に指定した値の電圧をアナログモニタより出力する										*/
/*																									*/
/****************************************************************************************************/
//void	FnOutputAnalogMonitor( AXIS_HANDLE *Axis, LONG Value, LONG Ch_No )
void	FnOutputAnalogMonitor( AXIS_HANDLE *Axis, SHORT Value, LONG Ch_No )
{
	LONG	Gsftx;
	LONG	Gadjx;
	LONG	Xgain;
	LONG	Mgain;
	LONG	InputVolt;
	LONG	AmonVal;
	AMONOUT	*AmonOutx;								/* アナログモニタデータへのポインタ				*/
	PRMDATA	*Prm;									/* パラメータ設定データへのポインタ				*/
	CMN_PRMDATA	*Cprm;								/* ユニット共通パラメータ設定データへのポインタ	*/

	/* 変数初期化	*/
	Prm = Axis->UniPrms->Prm;						/* パラメータ設定データ							*/
	Cprm = Axis->UniPrms->Cprm;						/* ユニット共通パラメータ設定データ				*/
	Mgain = 1;										/* アナログモニタ出力ゲイン値 初期値			*/
	InputVolt = (LONG)(SHORT)Value;					/* 入力電圧										*/
/*--------------------------------------------------------------------------------------------------*/
/*		ＣＨ選択処理																				*/
/*--------------------------------------------------------------------------------------------------*/
	if( Ch_No == 0 )								/* アナログモニタＣＨ０							*/
	{
		Xgain = (LONG)((SHORT)Cprm->mongain1);		/* CH0 Gain Parameter(Pn552:アナログモニタ1倍率)*/
		AmonOutx = (AMONOUT*)&(Axis->AmonOut[0]);	/* OutData Pointer								*/
		Gadjx = (CHAR)Cprm->mnag0_1.b.l;			/* Gain Adjust Data(PnE59:モニタ1,2ゼロ調)		*/
		Gsftx = -((USHORT)Cprm->mnrng0 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆		*/
	}
	else											/* アナログモニタＣＨ１							*/
	{
		Xgain = (LONG)((SHORT)Cprm->mongain2);		/* CH1 Gain Parameter(Pn552:アナログモニタ1倍率)*/	
		AmonOutx = (AMONOUT*)&(Axis->AmonOut[1]);	/* OutData Pointer								*/	
		Gadjx = (CHAR)Cprm->mnag0_1.b.h;			/* Gain Adjust Data(PnE59:モニタ1,2ゼロ調)		*/	
		Gsftx = -((USHORT)Cprm->mnrng1 >> 12);		/* MlibPcalKxgain()の指数(sx)は、正負が逆		*/	
	}

	/* アナログモニタ出力ゲイン算出 */
	Mgain = MlibPcalKskxkx( Mgain, Xgain * (Gadjx + 256), (100*256), &Gsftx,   0 );
	Mgain = MlibPcalKxgain( Mgain, AMON_HWGAIN_1000V,     100000,     &Gsftx,  24 );


	/* Offset取得 */
	PcalAnalogMonitorOffset( Axis, Ch_No );

	/* アナログモニタ出力算出 */
	AmonVal = MlibMulgain( InputVolt, Mgain );
	AmonVal += AmonOutx->Offset;

	if( Ch_No == 0 )
	{/* アナログモニタＣＨ０出力 */
		Axis->SvAsicRegs->AsicHwReg->AREG_PWMU = MlibLimitul( AmonVal, 0x7FFF, -0x7FFF );	/* アナログモニタ出力 Ch0 */
		//AmonOutx->RegVoltMonSetVal_Ch0 = Axis->SvAsicRegs->AsicHwReg->AREG_PWMU;	/* <S0FD> */
	}
	else
	{	/* アナログモニタＣＨ１出力 */
		Axis->SvAsicRegs->AsicHwReg->AREG_PWMV = MlibLimitul( AmonVal, 0x7FFF, -0x7FFF );	/* アナログモニタ出力 Ch1 */
		//AmonOutx->RegVoltMonSetVal_Ch1 = Axis->SvAsicRegs->AsicHwReg->AREG_PWMV;	/* <S0FD> */
	}

	return;
}
/* <S0E7> End */
/***************************************** end of file **********************************************/
