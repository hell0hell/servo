/****************************************************************************************************/
/*																									*/
/*																									*/
/*		AdcIf.c : A/D Converter Interface															*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	Function : A/D Converter Interface																*/
/*																									*/
/*			1)A/D Converter data Input 																*/
/*			2)A/D Converter Parameter Calculation 													*/
/*			3)A/D Converter Check Alarms 															*/
/*			4)																						*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/************** Copyright (C) Yaskawa Electric Corporation ******************************************/
/*																									*/
/*																									*/
/*		Rev.1.00 : 2013.8.13	K.Ozaki																*/
/*		Rev.1.10 : 2013.10.1	K.Ozaki			<S00C>												*/
/*		Rev.1.20 : 2013.10.23	K.Ozaki			<S051>												*/
/*																									*/
/*																									*/
/****************************************************************************************************/
#include	"KnlApi.h"
#include	"PnPrmListTbl.h"	/* Register and Parameter Access Interface */	/* <S0CB> */

#if (SVFSEL_ADC_USE == 1)||(SVFSEL_ONLY_OH_ADC_USE == 1)/* <S16D> */
/****************************************************************************************************/
/*																									*/
/*		A/D Converter Register Definition															*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/** ADM0 Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define ADCE   (UINT)(1<<0)
#define ADBSY  (UINT)(1<<1)
#define PWDWNB (UINT)(1<<2)
#define SRESB  (UINT)(1<<15)

/*--------------------------------------------------------------------------------------------------*/
/** ADM1 Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define TRG     (UINT)(1<<0)
#define TRGIN   (UINT)(1<<1)
#define MS      (UINT)(1<<2)
#define RPS     (UINT)(1<<3)
#define BS      (UINT)(1<<4)
#define TRGEN0  (UINT)(1<<8)
#define TRGEN1  (UINT)(1<<9)
#define EGA0    (UINT)(1<<12)
#define EGA1    (UINT)(1<<13)

/*--------------------------------------------------------------------------------------------------*/
/** ADM2 Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define CHSEL0   (UINT)(1<<0)

/*--------------------------------------------------------------------------------------------------*/
/** ADM3 Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define ADSMP0   (UINT)(1<<0)
#define EXWAIT0  (UINT)(1<<8)
#define ADCMP0   (UINT)(1<<16)
#define ADIL0    (UINT)(1<<24)

/*--------------------------------------------------------------------------------------------------*/
/** ADINT Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define INTEN    (UINT)(1<<0)
#define CSEEN    (UINT)(1<<16)
#define INTS     (UINT)(1<<31)

/*--------------------------------------------------------------------------------------------------*/
/** ADSTS Bit Definition 																			*/
/*--------------------------------------------------------------------------------------------------*/
#define INTST0   (UINT)(1<<0)
#define CSEST    (UINT)(1<<16)
#define TRGS     (UINT)(1<<31)


/****************************************************************************************************/
/*																									*/
/*		Function Prototypes																			*/
/*																									*/
/****************************************************************************************************/
#if (SVFSEL_ONLY_OH_ADC_USE == 0)			/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加					*/
/*--------------------------------------------------------------------------------------------------*/
/*		Public Functions																			*/
/*--------------------------------------------------------------------------------------------------*/
void	KpxAdcScanAService( CADC *pAdc	);	/* A/D Converter ScanA Service							*/
void	KpxAdcScanBService( CADC *pAdc	);	/* A/D Converter ScanB Service							*/
void	KpxAdcScanCService( CADC *pAdc  );	/* A/D Converter ScanC Service							*/
void	KpxInitAdc( void *ax );				/* Initialize A/D Interface 							*/
/*--------------------------------------------------------------------------------------------------*/
LONG	KpiInputSpdRefAd( CADC *pAdc );		/* 速度指令ＡＤ入力										*/
KSGAIN	KpiPcalSpdRefAdGain(  				/* Velocity Reference AD gain caluculation 				*/
	LONG	RatSpd,							/* rated speed [rad/s], [m/s] 							*/
	LONG	OvrSpd,							/* overed speed [rad/s], [m/s] 							*/
	LONG	Vrefgn,							/* Pn300: velocity input gain [0.01V/rated speed 		*/
	LONG	Gadjv );						/* PnE55: velocity gain adjust variable					*/
LONG	KpiInputTrqRefAd( CADC *pAdc );		/* トルク指令ＡＤ入力									*/
KSGAIN	KpiPcalTrqRefAdGain( 				/* Torque Reference AD gain calculation					*/
	LONG	MaxTrq, 						/* MaxTrq : 最大トルク[%]								*/
	LONG	Trefgn, 						/* Trefgn : トルク指令入力ゲイン[0.1V/定格トルク]		*/
	LONG	Gadjtp, 						/* Gadjtp : 正側トルク指令ゲイン調 [1/256]				*/
	LONG	Ref );							/* Ref.Voltage : TrefP:15840, TrefN:14850				*/
/*--------------------------------------------------------------------------------------------------*/
void	KriTRefOffsetInc( CADC *pAdc );		/* Increment TREF A/D Offset 							*/
void	KriTRefOffsetDec( CADC *pAdc );		/* Decrement TREF A/D Offset 							*/
void	KriVRefOffsetInc( CADC *pAdc );		/* Increment VREF A/D Offset 							*/
void	KriVRefOffsetDec( CADC *pAdc );		/* Decrement VREF A/D Offset 							*/
/*--------------------------------------------------------------------------------------------------*/
LONG	KpiAdjustRefAdZero( CADC *pAdc );	/* 														*/
/* <S0CB>	Start */
/*--------------------------------------------------------------------------------------------------*/
/*		自動試験機モード 指令ＡＤ調整																*/
/*--------------------------------------------------------------------------------------------------*/
LONG	TciAdjustVrefGain( AXIS_HANDLE *Axis );			/* 速度指令ＡＤゲイン調整					*/
LONG	TciAdjustTrefPGain( AXIS_HANDLE *Axis );		/* トルク指令ＡＤ正側ゲイン調整				*/
LONG	TciAdjustTrefNGain( AXIS_HANDLE *Axis );		/* トルク指令ＡＤ負側ゲイン調整				*/
LONG	KpiInputOHAd( CADC *pAdc );						/* オーバヒートＡＤ入力						*/
void	TciReadVrefAD32Mean( LONG *AdMean );			/* 速度指令平均値読込み						*/
void	TciReadTrefAD16Mean( LONG AdMean[2] );			/* トルク指令平均値読込み					*/
/* <S0CB>	End */

/*--------------------------------------------------------------------------------------------------*/
/*		Private Functions : ADC Data Check															*/
/*--------------------------------------------------------------------------------------------------*/
static void	LpxCheckVrefAdData( CADC *pAdc );		/* 速度指令ＡＤデータチェック処理				*/
static void	LpxPcalCheckVrefAdData( CADC *pAdc );	/* 速度指令ＡＤデータチェック用パラメータ計算	*/
static void	LpxCheckTrqRefAdAlm( CADC *pAdc );		/* トルク指令ＡＤ異常チェック処理				*/

/*--------------------------------------------------------------------------------------------------*/
/*		Private Functions : TCI 																	*/
/*--------------------------------------------------------------------------------------------------*/
static void	TciAdjustRefAdZero( CADC *pAdc );
static void	TciReadTrefVrefADMean( LONG AdMean[3] );
static void	MlibAdd6432( LONG *a, LONG b, LONG *x );

#elif (SVFSEL_ONLY_OH_ADC_USE == 1)					/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加			*/
/*--------------------------------------------------------------------------------------------------*/
/*		Public Functions																			*/
/*--------------------------------------------------------------------------------------------------*/
void	KpxAdcScanCService( CADC *pAdc  );	/* A/D Converter ScanC Service							*/
void	KpxInitAdc( void *ax );				/* Initialize A/D Interface 							*/
LONG	KpiInputOHAd( CADC *pAdc );		/* オーバヒートＡＤ入力									*/
#endif
/****************************************************************************************************/
/*																									*/
/*		Variables																					*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/

/****************************************************************************************************/
/*																									*/
/*		Constant Definition																			*/
/*																									*/
/****************************************************************************************************/
#define	TREFZVADP		0x0C2				/* 正側トルク指令ＡＤゼロＶ入力時のＡＤ値				*/
#define	TREFZVADN		0x098				/* 負側トルク指令ＡＤゼロＶ入力時のＡＤ値				*/
/*--------------------------------------------------------------------------------------------------*/

/****************************************************************************************************/
/*																									*/
/*		Initialize Virtual Serial Message Interface													*/
/*																									*/
/****************************************************************************************************/
void	KpxInitAdc( void *ax )
{
#if (SVFSEL_ADC_USE == 1)||(SVFSEL_ONLY_OH_ADC_USE == 1)	/* <S09F> *//* ここでコンパイルスイッチ必要？ */
AXIS_HANDLE *pAxRsc = (AXIS_HANDLE *)ax;								/* Axis handle */
tADC_REG *areg = CPU_ADC_REG0;											/* 1st channel */
//CADC *pAdc = &(LAdc[ch]);												/* I/F variable */
CADC *pAdc = pAxRsc->pAdc;												/* I/F variable */
/*--------------------------------------------------------------------------------------------------*/
	MlibResetLongMemory( pAdc, sizeof( CADC )/4 );						/* Reset Variables			*/
/*--------------------------------------------------------------------------------------------------*/
/*	Reset CPU ADC																					*/
/*--------------------------------------------------------------------------------------------------*/
	ADC_REG_WR( ADM0, 0 );						/* set ADC Reset */
	KlibWaitus(10);								/* wait 10us */
	ADC_REG_WR( ADM0, SRESB );					/* clear ADC Reset */
/*--------------------------------------------------------------------------------------------------*/
/*	Initialize CPU ADC																				*/
/*--------------------------------------------------------------------------------------------------*/
/*  1) AD変換時間は、(ADSMP(0x07) + ADCMP(0x0E))*ADCLK(4Mhz)*2ch = 10,5us?							*/
/*--------------------------------------------------------------------------------------------------*/
	ADC_REG_WR( ADM1, RPS );					/* ADM1: Software Trigger, Scan Mode, 1 buffer Mode,*/
												/* Repeat Mode 										*/
//	ADC_REG_WR( ADM2, 0x03 );					/* ADM2: Using ch:0,1 								*//* <S0CB> */
#if CSW_BOARD_TYPE != SGD7W_TYPE	/* <S0E1> */
	ADC_REG_WR( ADM2, 0x07 );					/* ADM2: Using ch:0,1,2  							*//* <S0CB> */
#else/* CSW_BOARD_TYPE == SGD7W_TYPE */
	ADC_REG_WR( ADM2, 0x0F );					/* ADM2: Using ch:0,1,2,3  							*/
#endif
	ADC_REG_WR( ADM3, (0x07) | (0x0E)<<16 ); 	/* ADM3: ADSMP=0x07, ADCMP=0x0E, ADID=0 			*/
	/*----------------------------------------------------------------------------------------------*/
	ADC_REG_WR( ADINT, (0x03) );				/* ADINT: use interrupt (ch:0,1)					*/
	ADC_REG_WR( ADSTS, (0x0F) );				/* ADSTS: clear interrupt status 					*/
	ADC_REG_WR( ADIVC, (0x10) );				/* ADIVC: ADCLK = 62.5Mhz/16=  3.90625Mhz			*/
	/*----------------------------------------------------------------------------------------------*/
	ADC_REG_WR( ADM0, SRESB | PWDWNB );			/* ADM0: set ADC Normal Mode 						*/
	KlibWaitus(10);								/* wait 10us(念のため) 								*/
	ADC_REG_WR( ADM0, SRESB | PWDWNB | ADCE );	/* ADM0: start adc 									*/
/*--------------------------------------------------------------------------------------------------*/
	pAdc->hAlm = pAxRsc->AlmManager;			/* 後で消す */
	pAdc->pPrm = pAxRsc->UniPrms->Prm;			/* 後で消す */
	pAdc->pSot = pAxRsc->SeqCtrlOut;			/* 後で消す */

#if (SVFSEL_ONLY_OH_ADC_USE == 0)			/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加					*/
/*--------------------------------------------------------------------------------------------------*/
	LpxPcalCheckVrefAdData( pAdc );				/* Parameter Calculation							*/
/*--------------------------------------------------------------------------------------------------*/
#endif

#endif                 /* <S09F> */
	return;
}

#if (SVFSEL_ONLY_OH_ADC_USE == 0)			/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加					*/
/****************************************************************************************************/
/*																									*/
/*		A/D Converter ( ScanA Cycle )																*/
/*																									*/
/****************************************************************************************************/
void	KpxAdcScanAService( CADC *pAdc	)
{
#define _UDL_REG_ADDR_  (ULONG)0xC0000000
#if 1	/* <S051> */
/*--------------------------------------------------------------------------------------------------*/
/*		Read Reference A/D																			*/
/*--------------------------------------------------------------------------------------------------*/
		if ( ADC_VREFAD_USE != 0 )							
		{
			pAdc->Var[ADC0_VREFAD] = KpiInputSpdRefAd( pAdc );	/* Read Vref A/D */
		}
		if ( ADC_TREFAD_USE != 0 )							
		{
			pAdc->Var[ADC1_TREFAD] = KpiInputTrqRefAd( pAdc );	/* Read Tref A/D */
		}
#endif
	;	
}


/****************************************************************************************************/
/*																									*/
/*		A/D Converter ( ScanB Cycle )																*/
/*																									*/
/****************************************************************************************************/
void	KpxAdcScanBService( CADC *pAdc )
{
#if 0	/* <S051> */
/*--------------------------------------------------------------------------------------------------*/
/*		Read Reference A/D																			*/
/*--------------------------------------------------------------------------------------------------*/
		if ( ADC_VREFAD_USE != 0 )							
		{
			pAdc->Var[ADC0_VREFAD] = KpiInputSpdRefAd( pAdc );	/* Read Vref A/D */
		}
		if ( ADC_TREFAD_USE != 0 )							
		{
			pAdc->Var[ADC1_TREFAD] = KpiInputTrqRefAd( pAdc );	/* Read Tref A/D */
		}
#endif
/*--------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------*/
/*		サーボ制御指令入力処理(Anlg.cへ移動)														*/
/*--------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------*/
/*		トルク制限入力(Anlg.cへ移動)																*/
/*--------------------------------------------------------------------------------------------------*/

	return;
}
#endif
/****************************************************************************************************/
/*																									*/
/*		A/D Converter ( ScanC Cycle )																*/
/*																									*/
/****************************************************************************************************/
void	KpxAdcScanCService( CADC *pAdc )
{
/*--------------------------------------------------------------------------------------------------*/
//		pAdc->Var[ADC3_OHIAD] = KpiInputOHAd( pAdc );	/* Read OH A/D								*//* <S0CB> */
		KpiInputOHAd( pAdc );							/* Read OH A/D								*//* <S0CB> *//* <S0E1>:SGD7W対応 */
#if (SVFSEL_ONLY_OH_ADC_USE == 0)						/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加		*/
		LpxCheckVrefAdData( pAdc );						/* Check VREF A/D Data mulfunction			*/
		LpxCheckTrqRefAdAlm( pAdc );					/* Check Trq ref A/D mulfunction			*/
#endif
/*--------------------------------------------------------------------------------------------------*/
		return;
}



#if (SVFSEL_ONLY_OH_ADC_USE == 0)			/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加					*/
/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤ入力																			*/
/*																									*/
/****************************************************************************************************/
LONG	KpiInputSpdRefAd( CADC *pAdc )
{
LONG InAd;
/*--------------------------------------------------------------------------------------------------*/
/*		指令ＡＤ調整中																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( pAdc->Mode == ADCMD_ADJREFAD )									/* adjusting */
		{
			return (0);														/* return zero */
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Read Velocity Reference A/D																	*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			InAd = SHalDrv_ReadRefAd( (ASIC_HW_IF_STR *)_UDL_REG_ADDR_ );	/* Read A/D Converter 	*/
			InAd = ((InAd<<8)>>1) + pAdc->P.ZadjVelo; 						/* Zero Adjust			*/
		}
/*--------------------------------------------------------------------------------------------------*/
		return (InAd);
}


/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤ演算ゲイン計算																	*/
/*																									*/
/*		<1>24bit AD --> 16bit AD																	*/
/*		<2>実測による補正削除																		*/
/****************************************************************************************************/
/*																									*/
/*					  4.096 * RatSpd * 2^24 * 100 * (Gadjv + 65536)         VrefgnD					*/
/*		Kvrefad = ------------------------------------------------------ * ---------				*/
/*					  2^15 * HWgain * OvrSpd * Vrefgn * 65536 * 2^7          10000					*/
/*																									*/
/*						16384 * RatSpd * (Gadjv + 65536)			VrefgnD							*/
/*				= ---------------------------------------------- * ---------						*/
/*					  10 * HWgain * OvrSpd * Vrefgn * 65536		     10000							*/
/*																									*/
/*																									*/
/*		RatSpd  : 定格速度				[rad/s], [m/s]												*/
/*		OvrSpd  : オーバスピード		[rad/s], [m/s]												*/
/*		Vrefgn  : 速度指令入力ゲイン	[0.01V/定格速度]											*/
/*		VrefgnD	: 同上ディレーティング	[0.01%]	(Pn309)												*/
/*		Gadjv   : 速度指令ゲイン調		[1/65536]													*/
/*		HWgain  : ＨＷ回路ゲイン(HWgain=4/15)														*/
/*		Cx      : 実測による補正(Cx=3390/4096)							====> @SKLT@ にて削除		*/
/*		2^7     : 入力倍率補正(ゼロ調データが2^7倍されているため)									*/
/*																									*/
/*		参 照  : 詳細は、速度指令ＡＤゲイン調(Tstcmdif.c:TciAdjustVrefGain())を参照					*/
/*																									*/
/*																									*/
/****************************************************************************************************/
KSGAIN	KpiPcalSpdRefAdGain(  
	LONG	RatSpd,							/* rated speed [rad/s], [m/s] */
	LONG	OvrSpd,							/* overed speed [rad/s], [m/s] */
	LONG	Vrefgn,							/* Pn300: velocity input gain [0.01V/rated speed */
	LONG	Gadjv )							/* PnE55: velocity gain adjust variable			*/
{
//LONG	VrefgnD;							/* Pn309(未使用)								*/
#if	( SVFSEL_VREFAD_24BIT != 0 )	/* @SKLT@ */
		******** Compile Error @ 実測による補正とは何！@ *********
#else
KSGAIN kx;
LONG sx;
		kx = MlibScalKxgain( 16384,	15,          4*10,         &sx,  0 );
		kx = MlibPcalKxksks( kx,	RatSpd, 	OvrSpd,  &sx,  0 );
		kx = MlibPcalKxgain( kx,	1,          Vrefgn,   &sx,  0 );
		kx = MlibPcalKxgain( kx,	((SHORT)Gadjv + 65536), 65536, &sx, 24 );
		return (kx);
#endif
}

/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ入力																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*																									*/
/*								 AD	|   															*/
/*				  Ad-N				|   	   Ad-P													*/
/*					*				|			* 													*/
/*					  * 	  		|		  * 													*/
/*						* 			|		*  														*/
/*						  *---------+-----*-------- TREFZVADP + TREFZVADN							*/
/*						  |	* 		|	* |  														*/
/*						  |	  *		| *   |															*/
/*						  |		*   *-----+--------	TREFZVADP										*/
/*						  |		  * |     |															*/
/*						  |		*   *-----+-------- TREFZVADN										*/
/*						  |	  *  	| *   |															*/
/*						  | *		|	* |															*/
/*			--------------*---------+-----*-----------------> IN									*/
/*						  |				  |															*/
/*			------------->|<------------->|<-------------  											*/
/*				   負側		  負側+正側		  正側													*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
LONG	KpiInputTrqRefAd( CADC *pAdc )
{
LONG	InAdP;
LONG	InAdN;
LONG	Trefx;
tADC_REG *areg = CPU_ADC_REG0;											/* @@ */
/*--------------------------------------------------------------------------------------------------*/
/*		Read A/D converter																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( pAdc->Mode == ADCMD_ADJREFAD )		/* adjusting */
		{
			return (0);							/* return zero */
		}
		else if ( pAdc->f.TrefAdReadOk == TRUE ) 	/* normal read */
		{
			ADC_REG_RD( ADCR0, InAdP ); 								/* TREFP (SGDV<V883>参照) */
			ADC_REG_RD( ADCR1, InAdN ); 								/* TREFN */
		}
		else									/* velocity A/D checking */
		{										/* reference AD: (2*ScanC)cycle read */
			InAdP = pAdc->TrefAdinP;			/* LpxCheckVrefAdData() */
			InAdN = pAdc->TrefAdinN;			/* LpxCheckVrefAdData() */
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Normalizing	[2^24/MaxTrq]																	*/
/*--------------------------------------------------------------------------------------------------*/
/*
 *		※ゲイン計算はオプションモジュールへ移動(Anlg.c)
 */
/*--------------------------------------------------------------------------------------------------*/
#define INADPX (InAdP + pAdc->P.ZadjTrqP)					/* AD variable with Offset 				*/
#define INADNX (InAdN - pAdc->P.ZadjTrqN)					/* AD variable with Offset 				*/
		if( InAdP > (TREFZVADP + TREFZVADN) )				/* 正側ＡＤのみ使用						*/
		{
			Trefx = (INADPX - TREFZVADP);					/* (SGDV<V883>参照)						*/
		}
		else if( InAdN > (TREFZVADP + TREFZVADN) )			/* 負側ＡＤのみ使用						*/
		{
			Trefx = (TREFZVADN - INADNX);					/* (SGDV<V883>参照)						*/
		}
		else												/* 正側ＡＤ＋負側ＡＤ					*/
		{
			Trefx = (INADPX - TREFZVADP);					/* (SGDV<V883>参照)						*/
			Trefx = ( Trefx + ((TREFZVADN - INADNX)) ) >> 1;
		}
/*--------------------------------------------------------------------------------------------------*/
		return (Trefx);
}

/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ演算ゲイン計算																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*																									*/
/*					 Ref[0.01V]              10              100 * 2^24     (Gadjtp + 256)			*/
/*		Ktrefad = ---------------- * -------------------- * ------------ * -----------------		*/
/*				   1000*((2^12)-1)	 Trefgn[0.1V/RatTrq]     PerMaxTrq         256					*/
/*																									*/
/*		1)JL086のAD変換は12bit																		*/
/*		2)TREFPのRef Voltage(AD値がFFFHになる電圧)は15.091[V]										*/
/*		3)TREFNのRef Voltageは14.299[V]																*/
/*																									*/
/*		MaxTrq : 最大トルク				[%]															*/
/*		Trefgn : トルク指令入力ゲイン	[0.1V/定格トルク]											*/
/*		Gadjtp : 正側トルク指令ゲイン調 [1/256]														*/
/*		Gadjtn : 負側トルク指令ゲイン調 [1/256]														*/
/*																									*/
/*		参 照  : 詳細は、トルク指令ＡＤ正側ゲイン調およびトルク指令ＡＤ負側ゲイン調					*/
/*				 (Tstcmdif.c:TciAdjustTrefPGain(),TciAdjustTrefNGain())を参照						*/
/*																									*/
/*																									*/
/****************************************************************************************************/
KSGAIN	KpiPcalTrqRefAdGain( 
	LONG	MaxTrq, 		/*	MaxTrq : 最大トルク[%]												*/
	LONG	Trefgn, 		/*	Trefgn : Pn400:トルク指令入力ゲイン[0.1V/定格トルク]				*/
	LONG	Gadjtp, 		/*	Gadjtp : トルク指令ゲイン調 [1/256]									*/
	LONG	Ref )			/*  Reference Voltage [0.001V]: TrefP:XXXX, TrefN:XXXX					*/
{
LONG kx,sx;
/*--------------------------------------------------------------------------------------------------*/
	kx = MlibScalKxgain( Ref, 16777216, (Trefgn * MaxTrq), &sx, 0 );
	kx = MlibPcalKxgain( kx, ((CHAR)Gadjtp + 256), (256*4095), &sx, 24 );
/*--------------------------------------------------------------------------------------------------*/
	return (kx);
}


/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ異常チェック処理																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令ＡＤ変換完了のＣＰＵ割込み要求信号を監視し、割込み要求信号がＯＦＦ			*/
/*			場合に異常と判断する。																	*/
/*																									*/
/*	補 足 : Ｖ８５０Ｅ／ＭＡ１のＡＤは、スキャンＡでスタートし、約５us * ＣＨ数でＡＤ変換			*/
/*			を完了するので、ＡＤ正常動作時は、スキャンＣ実行時には、割込み要求信号がセット			*/
/*			されている。																			*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	LpxCheckTrqRefAdAlm( CADC *pAdc )
{
tADC_REG *areg = CPU_ADC_REG0;											/* @@ */
UINT sts;
#if   ADC_TREFAD_USE == 1                /* <S09F> */
/*--------------------------------------------------------------------------------------------------*/
/*		トルク指令ＡＤ異常チェック処理																*/
/*--------------------------------------------------------------------------------------------------*/
	if( /* repeat mode なので不要 KnlV.f.ScanAEnable && */ (pAdc->Mode != ADCMD_ADJREFAD) )
	{
		if( ! KPX_CHK_CPUADINTF( ) )						/* ＡＤ割込み要求信号チェック			*/
		{
			ALMSetServoAlarm( pAdc->hAlm, ALM_TREFADERR );	/* A.B20 : トルク指令用ＡＤ異常			*/
		}
		KPX_CLR_CPUADINTF( );								/* ＡＤ割込み要求信号リセット			*/
	}
/*--------------------------------------------------------------------------------------------------*/
#endif                    /* <S09F> */
	return;
}


/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤデータチェック処理																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ベースイネーブル要求ＯＦＦ時、ＣＰＵのＡＤ入力をトルク指令から速度指令に切替え、		*/
/*			２つの速度指令ＡＤ値(ASIC,CPU)を比較することにより、速度指令ＡＤの正常／異常を			*/
/*			チェックする。																			*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	LpxCheckVrefAdData( CADC *pAdc )
{
#if  ADC_VREFAD_USE == 1                /* <S09F> */
#define INADP(x) ((x) + pAdc->P.ZadjTrqP)					/* AD variable with Offset 				*/
#define INADN(x) ((x) - pAdc->P.ZadjTrqN)					/* AD variable with Offset 				*/
LONG	lwk0;
LONG	lwk1;
UCHAR	AdSel;
LONG	VrefAd;
LONG	TrefAd;
tADC_REG *areg = CPU_ADC_REG0;											/* @@ */
SEQ_CTRL_OUT *pSeqCtrlOut = (SEQ_CTRL_OUT *)pAdc->pSot;					/* 後で消す */
/*--------------------------------------------------------------------------------------------------*/
/*		指令ＡＤ調整中チェック																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( pAdc->Mode == ADCMD_ADJREFAD )				/* adjusting */
		{
			return;										/* 指令ＡＤ調整中は何もしない				*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		アラームマスクチェック																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( ALMCheckSetMask( pAdc->hAlm, ALM_VREFADCHK ) /* KPI_ALARMMSKCHK( ALM_VREFADCHK ) */ )
		{
			KPI_DI();									/* @@ chk */
			KPX_SET_ADSEL_TREF( );						/* トルク指令入力選択						*/
			KPI_EI();									/* @@ chk */
			pAdc->f.TrefAdReadOk = TRUE;				/* トルク指令ＡＤ読込みＯＫ					*/
			return;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ入力切替えスイッチ読込み																*/
/*--------------------------------------------------------------------------------------------------*/
		AdSel = KPX_READ_ADSEL( );

/*--------------------------------------------------------------------------------------------------*/
/*		トルク指令ＡＤ入力処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( AdSel == KPX_ADSEL_TREF )
		{
			ADC_REG_RD( ADCR0, lwk0 ); /* lwk0 += pAdc->P.ZadjTrqP; <S051><V883>の水平展開漏れ */pAdc->TrefAdinP = lwk0;
			ADC_REG_RD( ADCR1, lwk1 ); /* lwk1 -= pAdc->P.ZadjTrqN; <S051><V883>の水平展開漏れ */pAdc->TrefAdinN = lwk1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		速度指令ＡＤデータチェック処理																*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
		/*------------------------------------------------------------------------------------------*/
		/*		ＡＳＩＣ速度指令ＡＤ読込み															*/
		/*------------------------------------------------------------------------------------------*/
			VrefAd = (pAdc->Var[ADC0_VREFAD])>>7; 			/* @@ 暫定 */
		/*------------------------------------------------------------------------------------------*/
		/*		ＣＰＵ速度指令ＡＤ読込み															*/
		/*------------------------------------------------------------------------------------------*/
			ADC_REG_RD( ADCR0, lwk0 ); 		       			/* read AD */
			ADC_REG_RD( ADCR1, lwk1 ); 						/* read AD */
		/*------------------------------------------------------------------------------------------*/
			if( lwk0 > (TREFZVADP + TREFZVADN) )			/* 正側ＡＤのみ使用						*/
			{
				TrefAd = (INADP(lwk0) - TREFZVADP);			/* 										*/
			}
			else if( lwk1 > (TREFZVADP + TREFZVADN) )		/* 負側ＡＤのみ使用						*/
			{
				TrefAd = (TREFZVADN - INADN(lwk1));			/* 										*/
			}
			else											/* 正側ＡＤ＋負側ＡＤ					*/
			{
				TrefAd = (INADP(lwk0) - TREFZVADP);			/* 										*/
				TrefAd = ( TrefAd + ((TREFZVADN - INADN(lwk1))) ) >> 1;
			}
		/*------------------------------------------------------------------------------------------*/
			lwk0 = ((TrefAd >= 0 ) ? (pAdc->P.KvadchkP) : (pAdc->P.KvadchkN)); /* set AD check gain */
			TrefAd = MlibMulgain( TrefAd, lwk0 );
		/*------------------------------------------------------------------------------------------*/
		/*		速度指令ＡＤデータチェック															*/
		/*------------------------------------------------------------------------------------------*/
			lwk0 = MlibAbs32( VrefAd - TrefAd );		/* 誤差演算									*/
			if( lwk0 > (pAdc->P.VrefAdAlmLevel) )		/* 誤差チェック								*/
			{
				if( ++(pAdc->VrefAdDchkCnt) > 10 )		/* １０回連続でアラーム						*/
				{
					(pAdc->VrefAdDchkCnt) = 10;			/* チェックカウンタのクランプ				*/
					ALMSetServoAlarm( pAdc->hAlm, 
									ALM_VREFADCHK );	/* A.B11 : 速度指令用ＡＤデータ異常			*/
				}
			}
			else
			{
				(pAdc->VrefAdDchkCnt) = 0;				/* チェックカウンタのリセット				*/
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ＣＰＵ：ＡＤ入力切替え処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		/*------------------------------------------------------------------------------------------*/
		/* <SGDSと同じ条件に変更>																	*/
		/* 速度指令とトルク指令を交互に読込む仕様から変更する。										*/
		/* [CoutK.f.DbBeReq==FALSE]条件で速度指令読み込みに固定するとＯＴ時にトルク指令を読まない。	*/
		/* サーボオン要求なし、かつ、ＯＴでないとき、ＣＰＵ側ＡＤは速度指令読込みになるように変更 	*/
		/* Fn009(アナログ指令オフセット自動調整)時は、補助機能から指令ＡＤ切替を行っている。		*/
		/* 本関数内上部で、調整機能実行中（Fn009）はreturnで抜けて下記処理を実行しない。			*/
		/* 																							*/
		/* <SGDS不具合水平展開>																		*/
		/* CoutK.f.SvonReq（サーボオン要求）を指令ＡＤ切替条件としていたが、						*/
		/* Pn506≠０でサーボオフしても通電しているにも関わらず、指令ＡＤが速度指令側に切り替わる。	*/
		/* サーボオン要求でなく、通電状態を切替条件とする。											*/
		/* サーボオン要求と、通電状態を切替条件とする。												*/
		/*------------------------------------------------------------------------------------------*/
//SGDV 	if( (CoutK.f.SvonReq == FALSE) && (CoutK.f.BaseEnable == FALSE) && (CoutK.f.Ot == FALSE) )
		if( ( pSeqCtrlOut->BaseEnableReq == FALSE ) 
			&& ( pSeqCtrlOut->BeComplete == FALSE )
			&& ( pSeqCtrlOut->OverTrvlSts == FALSE ) )
		{
			pAdc->f.TrefAdReadOk = FALSE;				/* トルク指令ＡＤ読込み不可					*/
			if( AdSel == KPX_ADSEL_TREF )				/* ＡＤ入力切替処理							*/
			{
				KPI_DI();								/* @@ chk */
				KPX_SET_ADSEL_VREF( );					/* 速度指令入力選択							*/
				KPI_EI();								/* @@ chk */
			}
			else
			{
				KPI_DI();								/* @@ chk */
				KPX_SET_ADSEL_TREF( );					/* トルク指令入力選択						*/
				KPI_EI();								/* @@ chk */
			}
		}
	/*----------------------------------------------------------------------------------------------*/
		else											/* サーボオン時								*/
		{
			if( AdSel == KPX_ADSEL_TREF )
			{
				pAdc->f.TrefAdReadOk = TRUE;			/* トルク指令ＡＤ読込みＯＫ					*/
			}
			else
			{
				KPI_DI();								/* @@ chk */
				KPX_SET_ADSEL_TREF( );					/* トルク指令入力選択						*/
				KPI_EI();								/* @@ chk */
			}
		}
/*--------------------------------------------------------------------------------------------------*/
#endif                    /* <S09F> */
		return;
}


/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤデータチェック用パラメータ計算													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*					   2^23      4    																*/
/*		VrefAdAsic = ------- * ---- * Input   				ＨＷ回路ゲイン(HWgain=4/15)				*/
/*					  4.096		15    						実測による補正(Cx=3390/4096)<-削除		*/
/*																									*/
/*					   1023      3.3																*/
/*		VrefAdCpuP = ------- * ------- * Input				ＨＷ回路ゲイン(HWgain=3.3/15.09)		*/
/*					   3.3      15.09      															*/
/*																									*/
/*					   1023      3.3 																*/
/*		VrefAdCpuN = ------- * ------- * Input				ＨＷ回路ゲイン(HWgain=3.3/14.29)		*/
/*					   3.3      14.29 																*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*	<1> 24Bit --> 16Bit 対応																		*/
/*	<2> 実測による補正削除																			*/
/*	<3> JL086_CPUAD --> 12Bit対応																	*/
/*																									*/
/*					 2^15 *  4            Gadjv + 65536     15.09	      256						*/
/*		KvadchkP = ------------------- * --------------- * ------- * --------------					*/
/*					4.096 * 15                 65536        4095	  Gadjtp + 256					*/
/*																									*/
/*					512 * 15.09	          Gadjv + 65536												*/
/*				 = ------------------- * ---------------											*/
/*					4.096 * 15 * 4095	   Gadjtp + 256  											*/
/*																									*/
/*																									*/
/*					 2^15 *  4            Gadjv + 65536     14.29	      256						*/
/*		KvadchkN = ------------------- * --------------- * ------- * --------------					*/
/*					4.096 * 15                 65536        4095      Gadjtn + 256					*/
/*																									*/
/*					512 * 14.29	          Gadjv + 65536												*/
/*				 = ------------------- * ---------------											*/
/*					4.096 * 15 * 4095	   Gadjtn + 256  											*/
/****************************************************************************************************/
void	LpxPcalCheckVrefAdData( CADC *pAdc )
{
LONG	kx,sx;
#if	( SVFSEL_VREFAD_24BIT != 0 )
		Compile_Error!!									/* 未対応									*/
/*--------------------------------------------------------------------------------------------------*/
/*		正側演算ゲインの計算																		*/
/*--------------------------------------------------------------------------------------------------*/
		kx = MlibScalKxgain( 1,  1718323,  62853,  &sx,  0 );
		kx = MlibPcalKxgain( kx, ((SHORT)Prm.gadjv + 65536), ((CHAR)Prm.gadjtp_n.b.l + 256), &sx, 24 );
		KioP.KvadchkP = kx;

/*--------------------------------------------------------------------------------------------------*/
/*		負側演算ゲインの計算																		*/
/*--------------------------------------------------------------------------------------------------*/
		kx = MlibScalKxgain( 1,  1610928,  62853,  &sx,  0 );
		kx = MlibPcalKxgain( kx, ((SHORT)Prm.gadjv + 65536), ((CHAR)Prm.gadjtp_n.b.h + 256), &sx, 24 );
		KioP.KvadchkN = kx;

/*--------------------------------------------------------------------------------------------------*/
/*		速度指令ＡＤチェックアラームレベル	: (2^23 * 12V / 18.55V) * (20% / 100%)					*/
/*--------------------------------------------------------------------------------------------------*/
		KioP.VrefAdAlmLevel = 1085318;
#else
PRMDATA	*pPrm = pAdc->pPrm;				/* @@ */
/*--------------------------------------------------------------------------------------------------*/
/*		正側演算ゲインの計算	(512*15.09=7726.08, 4.096*15*4095=251596.8)							*/
/*--------------------------------------------------------------------------------------------------*/
		kx = MlibScalKxgain( 1,  7726,  251597,  &sx,  0 );	
		kx = MlibPcalKxgain( kx, ((SHORT)pPrm->gadjv + 65536), ((CHAR)pPrm->gadjtp_n.b.l + 256), &sx, 24 );
		pAdc->P.KvadchkP = kx;

/*--------------------------------------------------------------------------------------------------*/
/*		負側演算ゲインの計算	(512*14.29=7316.48, 4.096*15*4095=251596.8)							*/
/*--------------------------------------------------------------------------------------------------*/
		kx = MlibScalKxgain( 1,  7316,  251597,  &sx,  0 );
		kx = MlibPcalKxgain( kx, ((SHORT)pPrm->gadjv + 65536), ((CHAR)pPrm->gadjtp_n.b.h + 256), &sx, 24 );
		pAdc->P.KvadchkN = kx;

/*--------------------------------------------------------------------------------------------------*/
/*		速度指令ＡＤチェックアラームレベル	: (2^15 * 12V / 15.36V) * (20% / 100%)					*/
/*																									*/
/*			最大許容入力電圧(±12V)の20%を故障チェックレベルにする。								*/
/*			15V入力でAD値0x7D00のため、AD値0x7FFFの時、15.36V入力となる。							*/
/*			(実測による補正Cx=3390/4096は考慮しない)												*/
/*--------------------------------------------------------------------------------------------------*/
		pAdc->P.VrefAdAlmLevel = 5120;
#endif
		return;
}


/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤ異常チェック処理																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ＡＳＩＣの汎用入力(IOSTAT)の指令用24bitＡＤタイムアウトエラーを監視する。				*/
/*			ＡＤ２４ＥＲＲビット(Hi)で異常とする。(アラームリセット可)								*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
#if 0	/* 未対応 */
void	LpxCheckVrefAdAlm( void )
{
/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_VREFAD == 0 ){ return;}				/* Mask Function							*/

/*--------------------------------------------------------------------------------------------------*/
/*		速度指令ＡＤ異常チェック																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( KPX_CHK_CAD24_ERROR( ) )					/* @SKLT@ */
		{
			if( KioV.VrefAdErrChk == 0x00 )
			{
				KioV.VrefAdErrChk = 0x01;				/* １回目は、アラームとしない				*/
			}
			else
			{
				KPI_ALARMSET( ALM_VREFADERR );			/* A.B10 : 速度指令用ＡＤ異常				*/
				KPI_ALARMMSK( ALM_VREFADCHK );			/* A.B11 : 速度A/Dデータ異常マスク	<V048>	*/
			}
			KPX_CAD24ERR_CLEAR( );						/* 速度指令ＡＤエラークリア					*//* @SKLT@ */
		}
		else
		{
			KioV.VrefAdErrChk = 0x00;					/* エラーチェックフラグクリア				*/
		}
/*--------------------------------------------------------------------------------------------------*/
		return;

}
#endif
/*--------------------------------------------------------------------------------------------------*/

/****************************************************************************************************/
/*																									*/
/*		指令ＡＤ零調処理(オンライン用)																*/
/*																									*/
/****************************************************************************************************/
LONG	KpiAdjustRefAdZero( CADC *pAdc )
{
LONG	i;
/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_ADC_USE == 0 )
		{
			return( KPI_ADC_NOTADJ );					/* Error Return								*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		開始処理 (Set Adjust Mode)																	*/
/*--------------------------------------------------------------------------------------------------*/
#if 0
		KPI_DI( );										/* Disable Interrupt						*/
		if( (CoutK.f.SvonReq == TRUE) || (KnlV.KnlMode != KPI_KMD_NORMAL) )
		{
			KPI_EI( );									/* Enable Interrupt							*/
			return( KPI_ADC_NOTADJ );					/* Error Return								*/
		}
		else
		{
			KnlV.KnlMode = KPI_KMD_ADJREFAD;			/* Set Adjust RefAd Mode					*/
			KPI_EI( );									/* Enable Interrupt							*/
		}
#endif

/*--------------------------------------------------------------------------------------------------*/
/*		ベースブロックチェック																		*/
/*--------------------------------------------------------------------------------------------------*/
#if 0
		for( i=0; KPI_CHK_BASE_ENABLE( ); i++ )
		{
			if( i > 1000 )								/* Check Time Over							*/
			{
				KnlV.KnlMode = KPI_KMD_NORMAL;			/* Reset Adjust RefAd Mode					*/
				return( KPI_ADC_NOTADJ );				/* Error Return								*/
			}
			KlibWaitms( 1 );							/* Wait 1ms									*/
		}
#endif

/*--------------------------------------------------------------------------------------------------*/
/*		指令ＡＤ零調処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		pAdc->f.AdjustError = FALSE;					/* Reset AdjustError Flag					*/
		pAdc->Mode = ADCMD_ADJREFAD;					/* set adjust mode							*/
		TciAdjustRefAdZero( pAdc  );					/* Adjust VrefAD and TrefAD					*/

/*--------------------------------------------------------------------------------------------------*/
/*		終了処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		//KnlV.KnlMode = KPI_KMD_NORMAL;				/* Reset Adjust RefAd Mode					*/
		pAdc->Mode = ADCMD_NORMAL;						/* reset adjust mode						*/
		if( pAdc->f.AdjustError == FALSE )
		{
			return( KPI_ADC_ADJOK );					/* Adjust OK								*/
		}
		else
		{
			return( KPI_ADC_ADJERR );					/* Adjust Error								*/
		}
}

/* <S0CB>	Start */
/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤゲイン調(オフライン用)															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 速度指令(Vref)ＡＤのゲイン調を行う。													*/
/*			速度指令入力に、7.5Vを加え以下の式よりゲイン調を求める。								*/
/*																									*/
/*			補正Gain = (7.5/15.36)*Cx*2^23*65536/(A/D平均値 + 零調Data) - 65536						*/
/*																									*/
/*			ゲイン調、-8192 ≦ 補正Gain ≦ 8192(12.5%) の範囲外であった場合は、						*/
/*			調整異常で補正Gainをゼロにする。Cx : 実測による補正										*/
/*																									*/
/*																									*/
/*	補 足 :	本ルーチンは、BURR-BROWN製24bitA/Dｺﾝﾊﾞｰﾀ ADS1252用である。								*/
/*			ADS1252への入力は差分入力で、入力回路のゲインは下式の通りである。						*/
/*																									*/
/*					      10k		1.2k															*/
/*			+Vin =   ----------- * ------ * Vref[V] + 2.5[V]										*/
/*					   20k + 10k	 3k																*/
/*																									*/
/*						  10k		1.2k															*/
/*			-Vin = - ----------- * ------ * Vref[V] + 2.5[V]										*/
/*					   20k + 10k	 3k																*/
/*																									*/
/*			上式より、差動電圧のゲインは、下式で表される。											*/
/*																									*/
/*											   10k		  1.2k		  4								*/
/*			HWgain  =  +Vin - -Vin  =  2 * ----------- * ------  =  ----							*/
/*											20k + 10k	   3k		 15								*/
/*																									*/
/*			入力電圧をVref[V]とすると、ADS1252への入力Vadin[V]は、下式で表される。					*/
/*																									*/
/*											4														*/
/*			Vadin[V] = HWgain * Vref[V]	= ---- * Vref[V]											*/
/*										   15														*/
/*																									*/
/*			ADS1252のリファレンス入力電圧は、4.096[V](AD値=2^23)であるので、上式より、				*/
/*																									*/
/*						 2^23		 2^23	   4				  2^23								*/
/*			Vadin[V] * -------  =  ------- * ---- * Vref[V]  =  ------- * Vref[V]					*/
/*						4.096		4.096	  15				 15.36								*/
/*																									*/
/*			補正Gain(Gadjx)は、実測による補正項(Cx)を加味して、上式より、							*/
/*																									*/
/*					 2^23 * 2^16 * (7.5/15.36) * Cx				   0x7D000000 * Cx					*/
/*			Gadjx = -------------------------------- - 65536 = ---------------------- - 65536		*/
/*						(Vrefad + Zadjx)>>7						(Vrefad + Zadjx)>>14				*/
/*																									*/
/*			実測による補正 : Cx = 3390/4096															*/
/*																									*/
/*			実測による補正を削除 @SKLT@																*/
/****************************************************************************************************/
LONG TciAdjustVrefGain( AXIS_HANDLE *Axis )
{
	LONG			rc;
	LONG			Gadjx;
	LONG			Zadjx;
	LONG			AdMean;
	PRMDATA			*Prm;
	REGIF_CONFIG_T	*RegCfg;

	/* Initialize */
	rc = KPI_ADC_ADJOK;
	Prm = Axis->UniPrms->Prm;
	RegCfg = Axis->RegManager->hPnReg;

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( SVFSEL_ADC_USE == 0 )
	{
		rc = KPI_ADC_NOTADJ;	/* 調整実施条件不成立 */
		return( rc );			/* Error Return */
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ平均値読込み																			*/
/*--------------------------------------------------------------------------------------------------*/
	TciReadVrefAD32Mean( &AdMean );		/* Read Vref AD Mean */

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ演算																		*/
/*--------------------------------------------------------------------------------------------------*/
#if	( SVFSEL_VREFAD_24BIT != 0 )
	/* Make Adjust Data */
	Zadjx = Prm->zadjvl;								/* PnE53 : 速度指令ゼロ調の値読み込み */
	Gadjx = 0x7D000000/((AdMean + Zadjx)>>14) - 65536;	/* 桁落ち修正 */

	/* Check Adjust Data */
	if( (Gadjx < -16384) || (Gadjx > 16384) )
	{
		Gadjx = 0;
		rc = KPI_ADC_NOTADJ;
	}
#else
	/* Make Adjust Data */
	Zadjx = Prm->zadjvl;								/* PnE53 : 速度指令ゼロ調の値読み込み */
	Gadjx = 0x7D000000/((AdMean + Zadjx)>>6) - 65536;	/* 桁落ち修正 */

	/* Check Adjust Data */
	if( (Gadjx < -16384) || (Gadjx > 16384) )
	{
		Gadjx = 0;
		rc = KPI_ADC_NOTADJ;
	}
#endif

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ(PnE55 : 速度指令ゲイン調)格納												*/
/*--------------------------------------------------------------------------------------------------*/
	/* Write Adjust Data to RAM */
	Prm->gadjv = (USHORT)Gadjx;

	/* Write Adjust Data to EEPROM */
	PrmStoreValueToEeprom( RegCfg, &pndef_gadjv, 0 );

	return( rc );
}


/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ正側ゲイン調(オフライン用)													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令正入力(Tref positive)ＡＤのゲイン調を行う。									*/
/*		 	トルク指令入力に、+7.5Vを加え以下の式よりゲイン調を求める。								*/
/*																									*/
/*			補正Gain = (7.5/15.84*1024*256)/(A/D平均値 + 零調Data - 48) - 256						*/
/*																									*/
/*			ゲイン調が、-127 ≦ 補正Gain ≦ 127(49.6%) の範囲外であった場合は、						*/
/*			調整異常で補正Gainをゼロにする。														*/
/*																									*/
/*																									*/
/*	補 足 :	本ルーチンは、V850E/MA1内蔵10bitA/Dコンバータ用である。									*/
/*			V850E/MA1内蔵10bitA/Dの入力回路のゲインは下式の通りである。								*/
/*																									*/
/*						  1k * 2k * 10k         1  *     10k				    1   				*/
/*		Trefp[V] = ------------------------- ( ------------------ * Tref[V] + ----- * 2.5[V] )		*/
/*				    1k*2k + 2k*10k + 10k*1k     1k * (10k + 20k)			   10k					*/
/*																									*/
/*				    20				 15																*/
/*				 = ---- * Tref[V] + ----															*/
/*				    96				 96																*/
/*																									*/
/*					1024	  1024																	*/
/*		Trefp[V] * ------ = ------- * Tref[V] + 48.4848												*/
/*					3.3		 15.84																	*/
/*																									*/
/*		補正Gain(Gadjx)は、上式より、																*/
/*																									*/
/*						256 * 1024 * 7.5 						  124121  							*/
/*		Gadjx = -------------------------------- - 256 = ------------------------ - 256				*/
/*				 15.84 * (Trefpad + Zadjx - 48)			  (Trefpad + Zadjx - 48)					*/
/*																									*/
/*																									*/
/****************************************************************************************************/
LONG	TciAdjustTrefPGain( AXIS_HANDLE *Axis )
{
	LONG			rc;
	LONG			Gadjx;
	LONG			Zadjx;
	LONG			AdMean[2];
	PRMDATA			*Prm;
	REGIF_CONFIG_T	*RegCfg;

	/* Initialize */
	rc = KPI_ADC_ADJOK;
	Prm = Axis->UniPrms->Prm;
	RegCfg = Axis->RegManager->hPnReg;

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( SVFSEL_ADC_USE == 0 )
	{
		rc = KPI_ADC_NOTADJ;	/* 調整実施条件不成立 */
		return( rc );			/* Error Return */
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ平均値読込み																			*/
/*--------------------------------------------------------------------------------------------------*/
	KPX_SET_ADSEL_TREF( );				/* Select Tref AD Select Switch */
	//KpiResetWatchdogWaitms( 1 );		/* Reset Watchdog and Wait */
	TciReadTrefAD16Mean( AdMean );		/* Read P-Tref, N-Tref AD Mean */

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ演算 : 演算式が異なるが、調整範囲なのでＳＧＤＳにあわせる					*/
/*		　ではなく、入力回路ゲインの通りとする。詳細：形式試験問題点報告（JT05793）					*/
/*--------------------------------------------------------------------------------------------------*/
	/* Make Adjust Data */
	Zadjx = Prm->zadjtp_n.b.l;						/* PnE56 : トルク指令ゼロ調(正入力/負入力) -Low Byte- */
//	Gadjx = 124121/(AdMean[0] + Zadjx - 48) - 256;	/* SWPF	: 256*1024*7.5/15.84 */
	Gadjx = 496484/(AdMean[0] + Zadjx - TREFZVADP) - 256;	/* SWPF	: 256*4096*7.5/15.84 */

	/* Check Adjust Data */
	if ( (Gadjx < -127) || (Gadjx > 127) )
	{
		Gadjx = 0;
		rc = KPI_ADC_NOTADJ;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ(PnE57 : トルク指令ゲイン調(正入力/負入力))格納								*/
/*--------------------------------------------------------------------------------------------------*/
	/* Write Adjust Data to RAM */
	Prm->gadjtp_n.b.l = (USHORT)Gadjx;

	/* Write Adjust Data to EEPROM */
	PrmStoreValueToEeprom( RegCfg, &pndef_gadjtp_n, 0 );

	return( rc );
}
/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ負側ゲイン調(オフライン用)													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令負入力(Tref negative)ＡＤのゲイン調を行う。									*/
/*			トルク指令入力に、-7.5Vを加え以下の式よりゲイン調を求める。								*/
/*																									*/
/*			補正Gain = (7.5/14.85*1024*256)/(A/D平均値 - 零調Data - 38) - 256						*/
/*																									*/
/*			ゲイン調、-127 ≦ 補正Gain ≦ 127(49.6%) の範囲外であった場合は、						*/
/*			調整異常で補正Gainをゼロにする。														*/
/*																									*/
/*																									*/
/*	補 足 :	本ルーチンは、V850E/MA1内蔵10bitA/Dコンバータ用である。									*/
/*			V850E/MA1内蔵10bitA/Dの入力回路のゲインは下式の通りである。								*/
/*																									*/
/*					   1k	      10k					      1k		   1k						*/
/*		Trefn[V] = - ------ * ----------- * Tref[V] + ( 1 + ------ ) * ---------- * 2.5[V]			*/
/*				      1.5k	   10k + 20k 					 1.5k	    33k + 1k					*/
/*																									*/
/*				      2				   25															*/
/*				 = - --- * Tref[V] + -----															*/
/*				      9				  204															*/
/*																									*/
/*					1024	    1024																*/
/*		Trefn[V] * ------ = - ------- * Tref[V] + 38.0273											*/
/*					 3.3	   14.85																*/
/*																									*/
/*		補正Gain(Gadjx)は、上式より、																*/
/*																									*/
/*						256 * 1024 * 7.5 						  132396  							*/
/*		Gadjx = -------------------------------- - 256 = ------------------------ - 256				*/
/*				 14.85 * (Trefnad - Zadjx - 38)			  (Trefnad - Zadjx - 38)					*/
/*																									*/
/*																									*/
/****************************************************************************************************/
LONG TciAdjustTrefNGain( AXIS_HANDLE *Axis )
{
	LONG			rc;
	LONG			Gadjx;
	LONG			Zadjx;
	LONG			AdMean[2];
	PRMDATA			*Prm;
	REGIF_CONFIG_T	*RegCfg;

	/* Initialize */
	rc = KPI_ADC_ADJOK;
	Prm = Axis->UniPrms->Prm;
	RegCfg = Axis->RegManager->hPnReg;

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( SVFSEL_ADC_USE == 0 )
	{
		rc = KPI_ADC_NOTADJ;	/* 調整実施条件不成立 */
		return( rc );			/* Error Return */
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ平均値読込み																			*/
/*--------------------------------------------------------------------------------------------------*/
	KPX_SET_ADSEL_TREF( );				/* Select Tref AD Select Switch */
	//KpiResetWatchdogWaitms( 1 );		/* Reset Watchdog and Wait */
	TciReadTrefAD16Mean( AdMean );		/* Read P-Tref, N-Tref AD Mean */

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ演算 : 演算式が異なるが、調整範囲なのでＳＧＤＳにあわせる					*/
/*		　ではなく、入力回路ゲインの通りとする。詳細：形式試験問題点報告（JT05793）					*/
/*--------------------------------------------------------------------------------------------------*/
	/* Make Adjust Data */
	Zadjx = Prm->zadjtp_n.b.h;						/* PnE56 : トルク指令ゼロ調(正入力/負入力) -High Byte- */
//	Gadjx = 132396/(AdMean[1] - Zadjx - 38) - 256;	/* SWPF : 256*1024*7.5/14.85 */
	Gadjx = 529583/(AdMean[1] - Zadjx - TREFZVADP) - 256;	/* SWPF : 256*1024*7.5/14.85 */

	/* Check Adjust Data */
	if ( (Gadjx < -127) || (Gadjx > 127) )
	{
		Gadjx = 0;
		rc = KPI_ADC_NOTADJ;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン調整データ(PnE57 : トルク指令ゲイン調(正入力/負入力))格納								*/
/*--------------------------------------------------------------------------------------------------*/
	/* Write Adjust Data to RAM */
	Prm->gadjtp_n.b.h = (USHORT)Gadjx;

	/* Write Adjust Data to EEPROM */
	PrmStoreValueToEeprom( RegCfg, &pndef_gadjtp_n, 0 );

	return( rc );
}
#endif
/****************************************************************************************************/
/*																									*/
/*		オーバヒートＡＤ入力																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : オーバヒートＡＤ入力値を取得する。														*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
LONG	KpiInputOHAd( CADC *pAdc )
{
	LONG InAd;
	tADC_REG *areg = CPU_ADC_REG0;

/*--------------------------------------------------------------------------------------------------*/
/*		Read A/D converter																			*/
/*--------------------------------------------------------------------------------------------------*/
		pAdc->Var[ADC3_OHIAD] = ADC_REG_RD( ADCR2, InAd ); 									/* 1軸目*/
#if CSW_BOARD_TYPE == SGD7W_TYPE /* <S0A2> */
		pAdc->Var[ADC4_OHIAD] = ADC_REG_RD( ADCR3, InAd ); 									/* 2軸目*/
#endif
/*--------------------------------------------------------------------------------------------------*/
		return (InAd);
}

#if (SVFSEL_ONLY_OH_ADC_USE == 0)			/* <S0E1>:SVFSEL_ONLY_OH_ADC_USE追加					*/
/****************************************************************************************************/
/*																									*/
/*		速度指令ＡＤ平均値読込み																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 速度指令ＡＤ値を４０９６回読込み、その平均値(128倍)を返す。								*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void TciReadVrefAD32Mean( LONG *AdMean )
{
	LONG	i;
	LONG	Adlo;
	LONG	Adhi;
	LONG	VAdBuf[2];

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_ADC_USE == 0 )
		{
			return;										/* ObjectCodes Optimized by return			*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ読込み(4096回) : 30us * 4096 = 122.880 ms												*/
/*--------------------------------------------------------------------------------------------------*/

		VAdBuf[0] = VAdBuf[1] = 0;						/* Clear Vref AD Buffer						*/
		for( i=0; i < 0x1000; i++ )						/* Read Loop 4096 Times						*/
		{
			KlibWaitus( 30 );							/* Wait 30us for AD Conversion				*/
			KPX_REFAD_LATCH( );							/* Latch Vref AD Conv. Data			*/

#if	( SVFSEL_VREFAD_24BIT != 0 )	/* @SKLT@ */
			Adlo = (USHORT)(ASIC_RD( AREG_ACVLL ));				/* Read Low Word					*/
			Adhi = ((LONG)(ASIC_RD( AREG_ACVLH )<<24))>>8;		/* Read High Word					*/
#else		/* 16bit AD */
			Adlo = (USHORT)(((ASIC_HW_IF_STR *)_UDL_REG_ADDR_)->AREG_ACUL);	/* 暫定 */
			Adhi = ((( Adlo << 16 ) >> 16 ) & 0xFFFF0000 );		/* 符合拡張					*/
#endif
			MlibAdd6432( VAdBuf, ((Adhi+Adlo)<<7), VAdBuf );	/* Add  Buffer (128*AdData)	*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		平均値演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		*AdMean = (VAdBuf[1]<<20) | ((((ULONG)VAdBuf[0]>>11)+1)>>1);	/* Vref AD Mean				*/

	return;
}

/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ平均値読込み																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令ＡＤ値を４０９６回読込み、その平均値を返す。									*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void TciReadTrefAD16Mean( LONG AdMean[2] )
{
	LONG	i;
	LONG	Adlo;
	LONG	Adhi;
	LONG	TAdBuf[2];

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_ADC_USE == 0 )
		{
			return;										/* ObjectCodes Optimized by return			*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ読込み(4096回) : 30us * 4096 = 122.880 ms												*/
/*--------------------------------------------------------------------------------------------------*/
/*		<1>CPUADをRepeat Modeにしたため、TrefAdの起動処理を無くした。								*/
/*--------------------------------------------------------------------------------------------------*/
		TAdBuf[0] = TAdBuf[1] = 0;						/* Clear Tref AD Buffer						*/
		for( i=0; i < 0x1000; i++ )						/* Read Loop 4096 Times						*/
		{
			KlibWaitus( 30 );							/* Wait 30us for AD Conversion				*/
			TAdBuf[0] += KPX_READ_CPUAD0();				/* Read and Add Buf	(P-Tref)				*/
			TAdBuf[1] += KPX_READ_CPUAD1();				/* Read and Add Buf (N-Tref)				*/
			KlibWaitus( 18 );							/* Reset Watchdog and Wait					*/
		/*------------------------------------------------------------------------------------------*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		平均値演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		AdMean[0] = (((TAdBuf[0]>>11)+1)>>1);							/* P-Tref AD Mean			*/
		AdMean[1] = (((TAdBuf[1]>>11)+1)>>1);							/* N-Tref AD Mean			*/

		return;

}
/* <S0CB>	End */

/****************************************************************************************************/
/*																									*/
/*		指令ＡＤ零調処理(オフライン／オンライン用)													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 各指令ＡＤの入力ゼロ時の調整用データ(指令入力ゼロ時のオフセット量)を作成し、			*/
/*			それぞれパラメータに設定する。															*/
/*			なお、オフセット量が以下の範囲を外れる場合は、調整異常としてオフセット量を				*/
/*			ゼロにする。																			*/
/*																									*/
/*			1) T-ref P [ﾄﾙｸ指令A/D 正側] : -64 ≦ ｵﾌｾｯﾄ ≦ 64	(64/4096=1.56%)						*/
/*																									*/
/*			2) T-ref N [ﾄﾙｸ指令A/D 負側] : -64 ≦ ｵﾌｾｯﾄ ≦ 64	(64/4096=1.56%)						*/
/*																									*/
/*			3) V-ref   [速度指令A/D]	 : -52500000 ≦ ｵﾌｾｯﾄ ≦ 52500000	(24Bit AD の場合)		*/
/*										 : -200000   ≦ ｵﾌｾｯﾄ ≦ 200000		(16Bit AD の場合)		*/
/*																									*/
/*											24Bit AD の場合 ==> (52500000/(2^23*128)=4.889%)		*/
/*											16Bit AD の場合 ==> (  200000/(2^15*128)=4.768%)		*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	TciAdjustRefAdZero( CADC *pAdc )
{
LONG	Zerox;
LONG	Zeroy;
LONG	AdMean[3];
SHORT	XSat,YSat;
/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_ADC_USE == 0 )
		{
			return;										/* ObjectCodes Optimized by return			*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ平均値読込み																			*/
/*--------------------------------------------------------------------------------------------------*/
		KPX_SET_ADSEL_TREF( );							/* Select Tref AD Select Switch				*/
		KlibWaitms( 1 );								/* Reset Watchdog and Wait					*/
		TciReadTrefVrefADMean( AdMean );				/* Read P-Tref, N-Tref, Vref AD Mean		*/

/*--------------------------------------------------------------------------------------------------*/
/*		トルク指令零調データ演算＆格納																*/
/*--------------------------------------------------------------------------------------------------*/
		Zerox = -AdMean[0] + TREFZVADP;					/* Make  P-Tref Adjust Zero Data			*/
		//if( (Zerox < -64) || (Zerox > 64) )				/* @@ (10bit->12bit chk!!)    Check P-Tref Adjust Zero Data			*/
		if( (Zerox < -127) || (Zerox > 127) )				/* @@ (10bit->12bit chk!!)    Check P-Tref Adjust Zero Data			*/ /* <S169> */
		{
			pAdc->f.AdjustError = TRUE;
		}
	/*----------------------------------------------------------------------------------------------*/
		Zeroy = +AdMean[1] - TREFZVADN;					/* Make  N-Tref Adjust Zero Data			*/
		//if( (Zeroy < -64) || (Zeroy > 64) )				/* @@ (10bit->12bit chk!!)    Check N-Tref Adjust Zero Data			*/
		if( (Zeroy < -127) || (Zeroy > 127) )				/* @@ (10bit->12bit chk!!)    Check N-Tref Adjust Zero Data			*/ /* <S169> */
		{
			pAdc->f.AdjustError = TRUE;
		}
	/*----------------------------------------------------------------------------------------------*/
		XSat = YSat = FALSE;

		if( Zerox >= TREFZVADP )						/* Check P-Tref Adjust Data is Saturated	*/
		{
			XSat = TRUE;
		}
		if( Zeroy <= -(TREFZVADN) )						/* Check N-Tref Adjust Data is Saturated	*/
		{
			YSat = TRUE;
		}
	/*----------------------------------------------------------------------------------------------*/
		if ( pAdc->f.AdjustError )
		{
			Zerox = 0;
			Zeroy = 0;
		}
		else if(XSat == TRUE && YSat == FALSE)
		{
			Zerox = Zeroy;
		}
		else if(XSat == FALSE && YSat == TRUE)
		{
			Zeroy = Zerox;
		}
		else if(XSat == TRUE && YSat == TRUE)
		{
			pAdc->f.AdjustError = TRUE;
			Zerox = 0;
			Zeroy = 0;
		}
		pAdc->P.ZadjTrqP = Zerox;								/* set Zero Adjust Variable */
		pAdc->P.ZadjTrqN = Zeroy;								/* set Zero Adjust Variable */
		Zerox = (Zerox & 0xFF) + (Zeroy << 8);					/* Combine P-Tref and N-Tref		*/
//TODO:		Prm.zadjtp_n.w = (USHORT)Zerox;							/* Write Adjust Data to RAM			*/
//TODO:EEEPROM	KriWriteEepromPrm( Prm.zadjtp_n.w, &pndef_zadjtp_n );	/* Write Adjust Data to EEPROM		*/

/*--------------------------------------------------------------------------------------------------*/
/*		速度指令零調データ演算＆格納																*/
/*--------------------------------------------------------------------------------------------------*/
#if	( SVFSEL_VREFAD_24BIT != 0 )
		Zerox = -AdMean[2];									/* Make  Vref Adjust Zero Data			*/
		if ( (Zerox < -52500000) || (Zerox > 52500000) )	/* Check Vref Adjust Zero Data			*/
		{
			Zerox = 0;
			KnlV.f.AdjustError = TRUE;
		}
#else
/*--------------------------------------------------------------------------------------------------*/
/*		-240000〜+240000以外の場合、エラーにする：	(15.36/0x7FFF)×(240000/128) = 879mV			*/
/*																									*/
/*		オフセット調整範囲は、マニュアル上では±750mVであるが、										*/
/*		Fn00Aの処理上、オフセット調整範囲が15000で割り切れる方が都合が良いので±240000にする		*/
/*--------------------------------------------------------------------------------------------------*/
		Zerox = -AdMean[2];									/* Make  Vref Adjust Zero Data			*/
		if ( (Zerox < -240000) || (Zerox > 240000) )		/* Check Vref Adjust Zero Data			*/
		{
			Zerox = 0;
			pAdc->f.AdjustError = TRUE;
		}
#endif
	/*----------------------------------------------------------------------------------------------*/
		pAdc->P.ZadjVelo = Zerox;
//TODO:		Prm.zadjvl = (USHORT)Zerox;						/* Write Adjust Data to RAM					*/
//TODO:		Prm.zadjvh = (USHORT)(Zerox>>16);				/* Write Adjust Data to RAM					*/
//TODO:EEPROM		KriWriteEepromPrm( Zerox, &pndef_zadjvl );		/* Write Adjust Data to EEPROM				*/

		return;
}

/****************************************************************************************************/
/*																									*/
/*		トルク指令ＡＤ＆速度指令ＡＤ平均値読込み(オフライン／オンライン用)							*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : トルク指令ＡＤ値及び速度指令ＡＤ値を４０９６回読込み、その平均値を返す。				*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	TciReadTrefVrefADMean( LONG AdMean[3] )
{
LONG	i;
LONG	Adlo;
LONG	Adhi;
LONG	TAdBuf[2];
LONG	VAdBuf[2];

/*--------------------------------------------------------------------------------------------------*/
/*		機能有無チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( SVFSEL_ADC_USE == 0 )
		{
			return;										/* ObjectCodes Optimized by return			*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		ＡＤ読込み(4096回) : 30us * 4096 = 122.880 ms												*/
/*--------------------------------------------------------------------------------------------------*/
/*		<1>CPUADをRepeat Modeにしたため、TrefAdの起動処理を無くした。								*/
/*--------------------------------------------------------------------------------------------------*/
		TAdBuf[0] = TAdBuf[1] = 0;						/* Clear Tref AD Buffer						*/
		VAdBuf[0] = VAdBuf[1] = 0;						/* Clear Vref AD Buffer						*/
		for( i=0; i < 0x1000; i++ )						/* Read Loop 4096 Times						*/
		{
			KlibWaitus( 30 );							/* Wait 30us for AD Conversion				*/
			TAdBuf[0] += KPX_READ_CPUAD0();				/* Read and Add Buf	(P-Tref)				*/
			TAdBuf[1] += KPX_READ_CPUAD1();				/* Read and Add Buf (N-Tref)				*/
			KlibWaitus( 18 );							/* Reset Watchdog and Wait					*/
		/*------------------------------------------------------------------------------------------*/
			KPX_REFAD_LATCH( );									/* Latch Vref AD Conv. Data			*/

#if	( SVFSEL_VREFAD_24BIT != 0 )	/* @SKLT@ */
			Adlo = (USHORT)(ASIC_RD( AREG_ACVLL ));				/* Read Low Word					*/
			Adhi = ((LONG)(ASIC_RD( AREG_ACVLH )<<24))>>8;		/* Read High Word					*/
			MlibAdd6432( VAdBuf, ((Adhi+Adlo)<<7), VAdBuf );	/* Add  Buffer	(128*AdData)		*/
#else		/* 16bit AD */
			Adlo = (SHORT)(((ASIC_HW_IF_STR *)_UDL_REG_ADDR_)->AREG_ACUL);	/* 暫定 */
			Adhi = ((( Adlo << 16 ) >> 16 ) & 0xFFFF0000 );		/* <VZADJ>符合拡張					*/
#endif
			MlibAdd6432( VAdBuf, ((Adhi+Adlo)<<7), VAdBuf );	/* <V031>Add  Buffer (128*AdData)	*/
		}

/*--------------------------------------------------------------------------------------------------*/
/*		平均値演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		AdMean[0] = (((TAdBuf[0]>>11)+1)>>1);							/* P-Tref AD Mean			*/
		AdMean[1] = (((TAdBuf[1]>>11)+1)>>1);							/* N-Tref AD Mean			*/
	 	AdMean[2] = (VAdBuf[1]<<20) | ((((ULONG)VAdBuf[0]>>11)+1)>>1);	/* Vref AD Mean				*/

		return;

}

/****************************************************************************************************/
/*																									*/
/*		加算(64bit+32bit)																			*/
/*																									*/
/*		TODO: 後で消す																				*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
#define	ADD6432( a, b, xx )		{							/* r0: *a, r1: b, r2: *x */			\
									long wk1; 				/* 作業用 */						\
									long wk2; 				/* 作業用 */						\
									long wk3; 				/* 作業用 */						\
									__asm 														\
									{															\
										LDR wk1, [a,0] 		;/* 1:wk1 <- a[0]   */				\
										LDR wk2, [a,4] 		;/* 2:wk2 <- a[1]   */				\
 										MOV wk3, b			;/* 3:wk3 <- b                   */	\
										ASRS wk3, wk3, 31	;/* 4:wk3 <- (b>>31) = 0/-1      */	\
										ADDS wk1, wk1, b	;/* 5:wk1 <- a[0] + b            */	\
										ADCS wk2, wk2, wk3	;/* 6:wk2 <- a[1] + wk3 + carry  */	\
										STR wk1, [xx,0]		;/* 7:x[0] <- wk1  */				\
										STR wk2, [xx,4]		;/* 8:w[1] <- wk2  */				\
									}															\
								}
void	MlibAdd6432( LONG *a, LONG b, LONG *x )
{

		ADD6432( a, b, x );

		return;

}


#endif
#endif/* (SVFSEL_ADC_USE == 1)||(SVFSEL_ONLY_OH_ADC_USE == 1) */
/***************************************** end of file **********************************************/
