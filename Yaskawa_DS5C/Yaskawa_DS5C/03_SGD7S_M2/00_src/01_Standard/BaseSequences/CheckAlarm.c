/****************************************************************************************************/
/*																									*/
/*																									*/
/*		CheckAlarm.c : アラーム監視処理定義															*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : アラーム監視処理																		*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/************** Copyright (C) Yaskawa Electric Corporation ******************************************/
/*																									*/
/*	Note	:	初版	2010.02.23	Y.Oka	For INGRAM												*/
/*																									*/
/*	Log		:	Ver1.00																				*/
/*																									*/
/****************************************************************************************************/
#include "Basedef.h"
#include "MLib.h"
#include "KLib.h"
#include "HwDeviceIf.h"
#include "SerialEncIf.h"
#include "AlarmManager.h"
#include "CheckAlarm.h"

/* <S154> Start */
/*--------------------------------------------------------------------------------------------------*/
/*			過負荷演算区間選択																			*/
/*--------------------------------------------------------------------------------------------------*/
#define NORMAL_AREA			1U
#define LOWSPD_AREA			2U
#define LOCK_AREA			3U

/*--------------------------------------------------------------------------------------------------*/
/*		内部制御基板温度異常アラームチェック処理定義												*/
/*--------------------------------------------------------------------------------------------------*/
#define MINUTE		60000U

/* <S154> End */

/****************************************************************************************************/
/*		PROTOTYPE																					*/
/****************************************************************************************************/
static void	AdetCheckSencAlarmCode( MENCV *MencV, ALMMAN_HANDLE *AlmMngr );
//static void	AdetExeCheckOLAmpMot( LONG AbsMotSpd, LONG Ixsqr, CHECK_OL *ol_ptr, ALMMAN_HANDLE *AlmMngr );			/* <S154> */
static void	AdetExeCheckOLAmpMot( LONG AbsMotSpd, LONG Ixsqr, CHECK_OL *ol_ptr, ALMMAN_HANDLE *AlmMngr, UCHAR Mode );	/* <S154> */
static BOOL	AdetPcalOverLoadLevelAmpLow( CHECK_ALARM *CheckAlarm, LONG AbsMotSpd); 										/* <S154> */




/****************************************************************************************************/
/*																									*/
/*		Initialize Servo Alarm Check Variables														*/
/*																									*/
/****************************************************************************************************/
void	AdetInitCheckAlarm( CHECK_ALARM *pChkAlm, ULONG AlmOLInfo )
{
/*--------------------------------------------------------------------------------------------------*/
/*		アラームチェック用全変数ゼロクリア															*/
/*--------------------------------------------------------------------------------------------------*/
	MlibResetLongMemory( &(pChkAlm->MotOL.var), sizeof( pChkAlm->MotOL.var )/4 );
	MlibResetLongMemory( &(pChkAlm->AmpOL.var), sizeof( pChkAlm->AmpOL.var )/4 );
	MlibResetLongMemory( &(pChkAlm->HwbbTiming.var), sizeof( pChkAlm->HwbbTiming.var )/4 );

/*--------------------------------------------------------------------------------------------------*/
/*		アンプ＆モータ過負荷チェック用変数初期化													*/
/*--------------------------------------------------------------------------------------------------*/
	if( AlmOLInfo & ALMDEF_OLINFO_OLF )
	{
#if 1	/* <S154> */
		pChkAlm->MotOL.var.SumImax = (pChkAlm->MotOL.conf.NormalArea.AlmLvlmax >> 1);
		pChkAlm->MotOL.var.SumImid = (pChkAlm->MotOL.conf.NormalArea.AlmLvlmid >> 1);
		pChkAlm->AmpOL.var.SumImax = (pChkAlm->AmpOL.conf.NormalArea.AlmLvlmax >> 1);
		pChkAlm->AmpOL.var.SumImid = (pChkAlm->AmpOL.conf.NormalArea.AlmLvlmid >> 1);
#else	/* <S154> */
		pChkAlm->MotOL.var.SumImax = (pChkAlm->MotOL.conf.AlmLvlmax >> 1);
		pChkAlm->MotOL.var.SumImid = (pChkAlm->MotOL.conf.AlmLvlmid >> 1);
		pChkAlm->AmpOL.var.SumImax = (pChkAlm->AmpOL.conf.AlmLvlmax >> 1);
		pChkAlm->AmpOL.var.SumImid = (pChkAlm->AmpOL.conf.AlmLvlmid >> 1);
#endif	/* <S154> */
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＤＢ過負荷チェック用変数初期化																*/
/*--------------------------------------------------------------------------------------------------*/
	if( AlmOLInfo & ALMDEF_OLINFO_DBOL )
	{
		pChkAlm->DbOL.var.DbolPowSum = (pChkAlm->DbOL.conf.DbolAlmLevel >> 1);
	}

}



/****************************************************************************************************/
/*																									*/
/*		ＡＳＩＣハード検出異常チェック処理															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ＡＳＩＣハードウェアが検出する異常を監視する											*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
USHORT	AdetCheckAsicHwAlarm( CHECK_ALARM *pChkAlm, ASICS *SvAsic,
										BOOL EncDisable, ALMMAN_HANDLE *AlmMngr )
{
	USHORT 	faultState;
	USHORT	microFault;

	faultState = SHalDrv_GetFaultStatus(SvAsic->AsicHwReg, SHAL_FAULTS);
/*----------------------------------------------------------------------------------------------*/
/*		Micro異常																				*/
/*----------------------------------------------------------------------------------------------*/
	if( (faultState & SHAL_FAULT_BB) == 0 )
	{ /* FLTSTAT_bit10  0:ベースブロック正常 */
//		microFault = SvAsic->AsicMicroReg->MREG_FCCSTMON;
		microFault = SHalDrv_GetMicroFaultSts( SvAsic->AsicMicroReg );
		if( (microFault & 0x0001) != 0 )
		{
			ALMSetServoAlarm( AlmMngr, ALM_CURAD_U );	/* A.B31 : 電流検出異常１(Ｕ相)			*/
		}
		if( (microFault & 0x0002) != 0 )
		{
			ALMSetServoAlarm( AlmMngr, ALM_CURAD_V );	/* A.B32 : 電流検出異常２(Ｖ相)			*/
		}
	}

/*--------------------------------------------------------------------------------------------------*/
/*		Host-CPU : ウォッチドッグ異常																*/
/*--------------------------------------------------------------------------------------------------*/
	if( (faultState & SHAL_FAULT_WDOUT) != 0 )
	{ /* FLTSTAT_bit9  1:ホストCPU用WDTタイムオーバー */
		/* A.BF4 : システムアラーム４(CpuWDT) */
		ALMSetServoAlarm( AlmMngr, ALM_JL056_GUP );
	}

/*--------------------------------------------------------------------------------------------------*/
/*		Asic-CPU : ウォッチドッグ異常																*/
/*--------------------------------------------------------------------------------------------------*/
	if( ((faultState & SHAL_FAULT_GUP1) != 0) && (EncDisable == FALSE) )
	{ /* FLTSTAT_bit11 1:マイクロ演算部WDTタイムオーバー */
		if( pChkAlm->Gup1Timer >= KPI_SCANC_MS( 8 ))
		{
			/* A.B33 : 電流検出異常３(MicroWDT) */
			//ALMSetServoAlarm( AlmMngr, ALM_JL056_GUP1 );
			ALMSetGlobalAlarm( ALM_JL056_GUP1 );/*<S1BC>*/
			pChkAlm->Gup1Timer = KPI_SCANC_MS( 8 );
		}
		pChkAlm->Gup1Timer++;
	}
	else
	{
		pChkAlm->Gup1Timer = 0;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		過電流(OC)チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
#if 0/* <S126>:本関数では実施しない */
	{/* 0軸目	*/
	if( (SHalDrv_GetMicroWdtStatus(SvAsic->AsicHwReg) == 0)
		&& ((faultState & SHAL_FAULT_OC) != 0) )
	{ /* WDT1SET_bit6  0:マイクロ演算部用WDT動作中 && FLTSTAT_bit5  1:過電流異常発生 */
		/* A.100 : 過電流(ＯＣ) */
		ALMSetServoAlarm( AlmMngr, ALM_OC );
	}
	}
#endif
/*--------------------------------------------------------------------------------------------------*/
/*		ヒートシンク過熱(OH)チェック																*/
/*--------------------------------------------------------------------------------------------------*/
#if 0	/* 以下MDの処理 <S058> */
	if( (faultState & SHAL_FAULT_OH) != 0 )
	{ /* FLTSTAT_bit4  1:ヒートシンク過熱異常発生(INGRAMではJL-077BのOVポートにてOH検出) */
		ALMSetServoAlarm( AlmMngr, ALM_OH );				/* A.7A0 : ヒートシンク過熱				*/
	}
#endif
/*--------------------------------------------------------------------------------------------------*/
/*		過電圧(OV)チェック <S058>																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( (faultState & SHAL_FAULT_OV) != 0 )
	{
//-		SHalDrv_BaseBlock( SvAsic->AsicHwReg );		/* ＡＳＩＣベースブロック						*/
		/* BaseBlock */
		SHalDrv_BaseBlock(SvAsic->AsicHwReg, SvAsic->AsicMicroReg); /* <S0E4> */

		ALMSetServoAlarm( AlmMngr, ALM_OV );		/* A.400 : 過電圧(ＯＶ)							*/
	}

	pChkAlm->faultState = faultState;
	return faultState;
}


/****************************************************************************************************/
/*																									*/
/*		ＡＳＩＣハード検出異常チェック処理															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ＡＳＩＣハードウェアが検出する異常を監視する											*/
/*																									*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckOCAlarmDetections( ALMMAN_HANDLE *AlmMngr, ASICS *SvAsic, LONG axisNo, BOOL BeSts )
{
	USHORT 	faultState;

	if(axisNo == 0)
	{/* 0軸目	*/
		faultState = SHalDrv_GetFaultStatus(SvAsic->AsicHwReg, SHAL_FAULTS);
//		if( (SHalDrv_GetMicroWdtStatus(SvAsic->AsicHwReg) == 0)		/* <S137> */
		if(( BeSts == TRUE )
			&& ((faultState & SHAL_FAULT_OC1) != 0) )
		{ /* WDT1SET_bit6  0:マイクロ演算部用WDT動作中 && FLTSTAT_bit5  1:過電流異常発生 */
			/* A.100 : 過電流(ＯＣ) */
			ALMSetServoAlarm( AlmMngr, ALM_OC );
		}
	}
	else
	{/* 1軸目	*/
		faultState = SHalDrv_GetSetreg1Status(SvAsic->AsicHwReg);
//		if( (SHalDrv_GetMicroWdtStatus((ASIC_HW_IF_STR *)(0xC0001000)) == 0)		/* <S137> */
		if(( BeSts == TRUE )
			&& ((faultState & SHAL_FAULT_OC2) != 0) )
		{ /* WDT1SET_bit6  0:マイクロ演算部用WDT動作中 && FLTSTAT_bit5  1:過電流異常発生 */
			/* A.100 : 過電流(ＯＣ) */
			ALMSetServoAlarm( AlmMngr, ALM_OC );
		}
	}

	/* Get OC Status for Auto Test *//* <S1C9> */
	faultState = SHalDrv_GetFaultStatus(SvAsic->AsicHwReg, SHAL_FAULTS);
	AlmMngr->OCAlmOccurFlag1 = ((faultState & SHAL_FAULT_OC1) != 0) ? TRUE : FALSE;					  /* <Oka05> */
	faultState = SHalDrv_GetSetreg1Status(SvAsic->AsicHwReg);
	AlmMngr->OCAlmOccurFlag2 = ((faultState & SHAL_FAULT_OC2) != 0) ? TRUE : FALSE;					  /* <Oka05> */

}



/*<S1F5> START*/
/*****************************************************************************
  Description: モータ過電流検出チェック処理
------------------------------------------------------------------------------
  Parameters:
	AlmMngr             アラーム管理ＩＦデータ
	SvAsic				ASICアドレステーブルへのポインタ
	MencP				エンコーダパラメータ定義
	BeSts               ベースイネーブル完了状態
  Return:

------------------------------------------------------------------------------
  Note:

*****************************************************************************/
void	AdetCheckMotorOverCurrent( ALMMAN_HANDLE *AlmMngr, ASICS *SvAsic, BOOL BeSts, BOOL BaseEnableSts )
{
	USHORT 	faultState;

//	if( BaseEnableSts == TRUE )
//	{ /* SVON中の軸がある場合 */
//		faultState = SHalDrv_GetSetreg1Status(SvAsic->AsicHwReg);
//		if(( BeSts == TRUE ) && ( ((faultState & SHAL_FAULT_OCALMULT) != 0) ||
//				((faultState & SHAL_FAULT_OCALMVLT) != 0) || ((faultState & SHAL_FAULT_OCALMWLT) != 0) ) )
//		{/* U 相、V 相、W相いずれかのアラームラッチ値が「異常発生」であった場合 */
//			ALMSetServoAlarm( AlmMngr, ALM_OVERCURRENT );		/* A.101 : モータ過電流				*/
//		}
//	}
/* <S1F7> */
	if( BeSts == TRUE )
	{
		faultState = SHalDrv_GetSetreg1Status(SvAsic->AsicHwReg);
		if( faultState & ( SHAL_FAULT_OCALMULT | SHAL_FAULT_OCALMVLT | SHAL_FAULT_OCALMWLT ))
		{
			ALMSetServoAlarm( AlmMngr, ALM_OVERCURRENT );		/* A.101 : モータ過電流				*/
		}
	}
}
/*<S1F5> END*/



/****************************************************************************************************/
/*																									*/
/*		シリアルエンコーダアラーム監視処理(Called from ScanC)										*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : シリアルエンコーダ通信異常,オーバヒート及びアラームコードを監視する。					*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckSencAlarm( ALMMAN_HANDLE *AlmMngr, MENCV *MencV, USHORT RxAlmCode )
{
/*--------------------------------------------------------------------------------------------------*/
/*		Update Motor Encoder Ready Flag																*/
/*--------------------------------------------------------------------------------------------------*/
	if( MencV->EncConnect && (!MencV->EncDisable) )
	{
		MencV->EncReady = MencV->SenReady;
	}
	else
	{
		MencV->EncReady = FALSE;
	}
	MencV->RxAlmCode = RxAlmCode;
/*--------------------------------------------------------------------------------------------------*/
/*		チェック実行 : 通信正常 and スキャンＡ実行中												*/
/*--------------------------------------------------------------------------------------------------*/
	if( (MencV->SeRxErr == FALSE) && (MencV->EncDisable == FALSE) )
	{
		AdetCheckSencBaseTimer( MencV, AlmMngr );			/* エンコーダベースタイマー監視<S0B9>	*/
		AdetCheckSencAlarmCode( MencV, AlmMngr );			/* エンコーダアラームコード監視			*/
	/*----------------------------------------------------------------------------------------------*/
//		if( MencV->AbsoEncoder == TRUE ) /* <S03A> */
		if( (MencV->AbsoEncoder == TRUE) || (MencV->IncDetOhFlg == TRUE) )
		{
			AdetCheckSencOverHeat( MencV, AlmMngr );		/* エンコーダオーバヒート監視			*/
		}
	/*----------------------------------------------------------------------------------------------*/
		if( MencV->ChkAlarmCnt < 10 )
		{
			MencV->ChkAlarmCnt++;							/* チェックカウンタの更新				*/
		}
	}
/*--------------------------------------------------------------------------------------------------*/
/*		チェック非実行 : 通信異常 or スキャンＡ停止中												*/
/*--------------------------------------------------------------------------------------------------*/
	else
	{
		MencV->ChkAlarmCnt = 0;								/* チェックカウンタのクリア				*/
	}

}



/****************************************************************************************************/
/*																									*/
/*		シリアルエンコーダベースタイマー監視<S0B9>													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : シリアルエンコーダがＰ１モード時に、エンコーダのタイムベースタイマが変化				*/
/*			しなかった場合、エンコーダ通信異常アラームを発生する。									*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckSencBaseTimer( MENCV *MencV, ALMMAN_HANDLE *AlmMngr )
{
	LONG	BaseTimer;
	BaseTimer = MencV->BaseTimer;								/* タイムベースタイマ今回値			*/
/*--------------------------------------------------------------------------------------------------*/
	if( MencV->ChkAlarmCnt >= 2 )								/* ３回目以降チェックする			*/
	{
		if( BaseTimer == MencV->ChkBaseTimer )					/* タイムベースタイマ変化無し?		*/
		{
			/* エンコーダ通信異常チェック */
			if( !ALMCheckEachState( AlmMngr, ALM_PGCOM ) )
			{
				ALMSetServoAlarm( AlmMngr, ALM_PGCOM2 );		/* A.C92 : エンコーダ通信タイマ異常	*/
			}
		}
	}
/*--------------------------------------------------------------------------------------------------*/
	MencV->ChkBaseTimer = BaseTimer;							/* タイムベースタイマ前回値更新		*/

}



/****************************************************************************************************/
/*																									*/
/*		シリアルエンコーダアラームコード監視														*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : Ｐ１モードシリアルエンコーダ受信アラームコードをアブソエンコーダと						*/
/*			インクリメンタルエンコーダに分けて判別する。											*/
/*			受信に失敗していたらアラームコード用変数(p1mode_d0)をクリアする。						*/
/*			受信成功の場合のみアラームを確認する、ただし読み出し直前の受信失敗も確認する。			*/
/*			読み込んだアラームコードを２回読みフィルタをかけた後で、アブソまたはインクレ			*/
/*			を認識して各アラームコード解析関数をコールする。										*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
static void	AdetCheckSencAlarmCode( MENCV *MencV, ALMMAN_HANDLE *AlmMngr )
{
	LONG	AlmCode;
/*--------------------------------------------------------------------------------------------------*/
/*		エンコーダアラームコード監視処理															*/
/*--------------------------------------------------------------------------------------------------*/
	if( MencV->ChkAlarmCnt >= 2 )						/* ３回目以降チェックする				*/
	{
		MencV->ChkAlmCode[0] =
			( ((MencV->ChkAlmCode[1] | MencV->RxAlmCode) & MencV->ChkAlmCode[0] )
				| (MencV->ChkAlmCode[1] & MencV->RxAlmCode) );
		MencV->ChkAlmCode[1] = MencV->RxAlmCode;

		/* アラームコードを代入 */
		AlmCode = MencV->ChkAlmCode[0];

		if( MencV->AbsoEncoder == TRUE )
		{ /* アブソエンコーダ */
			if( MencV->AxisMotType == MOTTYPE_LINEAR )
			{ /* リニア型 */
			/*--------------------------------------------------------------------------------------------------*/
			/*		EnDatスケール時マスク																		*/
			/*--------------------------------------------------------------------------------------------------*/
				if( MencV->SerialConvType == SCONVTYPE_ENDAT_ABS )
				{
					AlmCode = ( AlmCode & 0x0b );
				}
			/*--------------------------------------------------------------------------------------------------*/
			/*		Mitutoyo, SMSスケール時マスク																*/
			/*--------------------------------------------------------------------------------------------------*/
				else
				{
					AlmCode = ( AlmCode & 0x3a );
				}

				if( AlmCode & 0x01 )
				{
					/* A.890 : エンコーダスケールエラー */
					ALMSetServoAlarm( AlmMngr, ALM_SCL_ERR );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x02 )
				{
					/* A.891 : エンコーダモジュールエラー */
					ALMSetServoAlarm( AlmMngr, ALM_MOD_ERR );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x08 )
				{
					/* A.840 : エンコーダデータアラーム */
					ALMSetServoAlarm( AlmMngr, ALM_PG4 );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x10 )
				{
					/* A.850 : エンコーダオーバスピード */
					ALMSetServoAlarm( AlmMngr, ALM_PG5 );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x20 )
				{
					/* A.860 : エンコーダオーバヒート */
					ALMSetServoAlarm( AlmMngr, ALM_PG6 );
				}
			}
			else
			{ /* 回転型 */
				if( MencV->AbsoEncType != MENC_MABSO_TYPE )
				{ /* インクレ使用時 or １回転アブソ時マスク */
					AlmCode = ( AlmCode & 0x3a );
				}

				/* アラームコードチェック処理 */
				if( AlmCode & 0x01 )
				{ /* A.810 : エンコーダバックアップアラーム */
					ALMSetServoAlarm( AlmMngr, ALM_PG1 );
				}
				if( AlmCode & 0x02 )
				{ /* A.820 : エンコーダサムチェックアラーム */
					ALMSetServoAlarm( AlmMngr, ALM_PG2 );
				}
				if( AlmCode & 0x04 )
				{
					if( (4000 > KlibGetTimeAfterPowerOn()) && (MencV->BatWrnMode == FALSE) )
					{ /* A.830 : エンコーダバッテリアラーム */
						ALMSetServoAlarm( AlmMngr, ALM_PG3 );
					}
			/*------------------------------------------------------------------------------------------*/
					else if(MencV->BatWrnMode == TRUE)
					{ /* A.930 : エンコーダバッテリワーニング */
						ALMSetServoAlarm( AlmMngr, WRN_PGBAT );
					}
				}
				else
				{ /* A.930 : エンコーダバッテリワーニング */
					ALMClearWarning( AlmMngr, WRN_PGBAT );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x08 )
				{ /* A.840 : エンコーダデータアラーム */
					ALMSetServoAlarm( AlmMngr, ALM_PG4 );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x10 )
				{ /* A.850 : エンコーダオーバスピード */
					ALMSetServoAlarm( AlmMngr, ALM_PG5 );
				}
			/*----------------------------------------------------------------------------------------------*/
				if( AlmCode & 0x20 )
				{ /* A.860 : エンコーダオーバヒート */
					ALMSetServoAlarm( AlmMngr, ALM_PG6 );
				}
			}
		}
		else
		{ /* インクレエンコーダ */
			/*	アラームコードチェック処理 */
			if( AlmCode & 0x02 )
			{ /* A.820 : エンコーダサムチェックアラーム */
				ALMSetServoAlarm( AlmMngr, ALM_PG2 );
			}
			if( AlmCode & 0x08 )
			{ /* A.840 : エンコーダデータアラーム */
				ALMSetServoAlarm( AlmMngr, ALM_PG4 );
			}
		}
	}
/*--------------------------------------------------------------------------------------------------*/
	else													/* ２回目まではチェックしない			*/
	{
		MencV->ChkAlmCode[0] = 0;						/* アラームコードリセット				*/
		MencV->ChkAlmCode[1] = 0;						/* アラームコードリセット				*/
	}

}



/****************************************************************************************************/
/*																									*/
/*		シリアルエンコーダオーバヒート監視															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : エンコーダ内気温の検出及びオーバーヒートの検出を行う。									*/
/*																									*/
/*			0x00 〜 0xD7 :  0 〜 215 deg															*/
/*			0xFF 〜 0xD8 : -1 〜 -40 deg															*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckSencOverHeat( MENCV *MencV, ALMMAN_HANDLE *AlmMngr )
{
//	LONG	enc_temperatur; /* <S03A> */
	USHORT	enc_temperatur;

//	enc_temperatur = MencV->RxAlmCode & 0xff00;	/* <S03A> */
//	enc_temperatur = enc_temperatur >> 8;		/* <S03A> */
	enc_temperatur = (MencV->RxAlmCode >> 8) & 0x00ff;

/*--------------------------------------------------------------------------------------------------*/
/*		エンコーダ内気温設定																		*/
/*--------------------------------------------------------------------------------------------------*/
	if( enc_temperatur < 0xd8 )
	{
//		MencV->Temperature = enc_temperatur;					/* エンコーダ内気温(正)				*//* <S03A> */
		MencV->Temperature = (UCHAR)enc_temperatur;				/* エンコーダ内気温(正)				*/
	}
	else
	{
//		MencV->Temperature = -enc_temperatur;					/* エンコーダ内気温(負)				*//* <S03A> */
		MencV->Temperature = (CHAR)enc_temperatur;				/* エンコーダ内気温(負)				*/
	}
/*--------------------------------------------------------------------------------------------------*/
/*		エンコーダ内気温チェック																	*/
/*--------------------------------------------------------------------------------------------------*/
	if( MencV->Temperature > PG_OH_LEVEL )					/* 温度レベルチェック					*/
	{
		if( MencV->OverHeatCnt < KPI_SCANC_MS( 500 ) )		/* エラーカウンタチェック				*/
		{
			MencV->OverHeatCnt++;							/* Count up Error Counter				*/
		}
		else												/* 500ms以上連続でアラーム				*/
		{
			ALMSetServoAlarm( AlmMngr, ALM_PG6 );			/* A.860 : エンコーダオーバヒート		*/
		}
	}
	else
	{
		MencV->OverHeatCnt = 0;							/* エラーカウンタリセット				*/
	}
}



/****************************************************************************************************/
/*																									*/
/*		過速度(ＯＳ)チェック処理																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ回転速度が過速度検出レベルを超えた場合、過速度アラームを発生する。				*/
/*			過速度検出レベルは、エンコーダパラメータのモータ最大回転速度(PnF05.上位バイト)、		*/
/*			ＯＳ検出レベル(PnF06.下位バイト)とシステム定数のＯＳ検出レベル(PnE62.上位バイト)		*/
/*			によって決まるが、24bit(0x1000000)にノーマライズされている。							*/
/*																									*/
/*	注意　：使用しているモータ回転速度の更新周期が250usであるため見直しが必要						*/
/****************************************************************************************************/
void	AdetCheckOverSpeed( ALMMAN_HANDLE *AlmMngr, CHECK_ALARM *pChkAlm, LONG MotSpd, BPRMDAT *Bprm )
{
	LONG	AbsMotSpd;

	AbsMotSpd = MlibLABS( MotSpd );
/*--------------------------------------------------------------------------------------------------*/
/*		過速度(ＯＳ)チェック																		*/
/*--------------------------------------------------------------------------------------------------*/
//	if( AbsMotSpd >= Bprm->NorOvrSpd )
	if( AbsMotSpd >= Bprm->OsAlmLvl )	/* <S1D0> */
	{
		pChkAlm->OSCount++;
		if( pChkAlm->OSCount >= Bprm->OSCountMax )
		{
			pChkAlm->OSCount = Bprm->OSCountMax;
			ALMSetServoAlarm( AlmMngr, ALM_OSF1 );			/* A.510 : 過速度(ＯＳ)アラーム			*/
		}
	}
	else
	{
		pChkAlm->OSCount = 0;
	}
}



/****************************************************************************************************/
/*																									*/
/*		A.511:分周パルス出力過速度チェック処理									<S02D>				*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ回転速度が過速度検出レベルを超えた場合、過速度アラームを発生する。				*/
/*			過速度検出レベルは、エンコーダパラメータのモータ最大回転速度(PnF05.上位バイト)、		*/
/*			ＯＳ検出レベル(PnF06.下位バイト)とシステム定数のＯＳ検出レベル(PnE62.上位バイト)		*/
/*			によって決まるが、24bit(0x1000000)にノーマライズされている。							*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckDivOverSpeed( ALMMAN_HANDLE *AlmMngr, LONG MotSpd, LONG DivOvrSpd )
{
	LONG	AbsMotSpd;

	AbsMotSpd = MlibLABS( MotSpd );

/*--------------------------------------------------------------------------------------------------*/
/*		分周出力パルス過速度チェック																*/
/*--------------------------------------------------------------------------------------------------*/
	if( ALMCheckEachState( AlmMngr, ALM_OSF1 ) ) /*<S079>*/
	{
		;											/* A.510時は、分周出力パルス過速度チェック無し	*/
	}
	else if( AbsMotSpd >= DivOvrSpd )
	{
		ALMSetServoAlarm( AlmMngr, ALM_OSDIV );				/* A.511 : 分周パルス出力過速度			*/
	}
/*--------------------------------------------------------------------------------------------------*/

}



/****************************************************************************************************/
/*																									*/
/*		アンプ＆モータ過負荷チェック処理		低速ＯＬ：ＳＧＤＳ方式								*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ、アンプの許容範囲を超えて電流が流れた場合、異常処理する。						*/
/*			モータ、アンプは別の過負荷特性をもつので、分けて処理する。								*/
/*																									*/
/*			トルク指令∝電流、電流^2∝発熱量と考え、トルク指令の２乗を積分することにより			*/
/*			発熱量を求める。定格トルク以下では温度は許容値内で飽和すると考え、						*/
/*																									*/
/*			Σ(トルク指令^2−定格トルク^2)＞過負荷検出レベル										*/
/*																									*/
/*			となった場合、過負荷異常とみなす。														*/
/*																									*/
/*			実際の過負荷特性はトルク指令の２乗計算と合わないので、２乗計算２本で近似する。			*/
/*			大きいトルクで短時間で過負荷検出になる方を瞬時過負荷、定格トルクを越えた辺りで			*/
/*			時間がかかる過負荷検出になる方を連続過負荷と区別する。									*/
/*			処理方式の都合でできた検出であるが、瞬時過負荷は機械のかみ込みなどアクシデント			*/
/*			による異常の意味合いが強く、連続過負荷は経時変化により負荷が大きくなったと解釈			*/
/*			できる。よって、２つの過負荷検出のアラームコードを分けて区別することにする。			*/
/*																									*/
/*			システム補助機能で過負荷検出をマスクした場合、検出処理を通らない。						*/
/*																									*/
/****************************************************************************************************/
//void	AdetCheckOverLoadAmpMot( ALMMAN_HANDLE *AlmMngr, CHECK_ALARM *CheckAlarm,
//								 LONG IdRefMon, LONG IqRefMon, LONG AbsMotSpd, BOOL EncConnect )	/* <S154> */
BOOL	AdetCheckOverLoadAmpMot( ALMMAN_HANDLE *AlmMngr, CHECK_ALARM *CheckAlarm,
								 LONG IdRefMon, LONG IqRefMon, LONG AbsMotSpd, BOOL EncConnect )	/* <S154> */
{
	LONG		Ixsqr;
	CHECK_OL	*MotOL;
	CHECK_OL	*AmpOL;
	CHECK_LOWOL *LowOL;		/* <S154> */
	LOWOLCHKP	*LowOLChkP;	/* <S154> */
	BOOL		ret;		/* <S154> */


	/* ローカル変数の初期化 */
	Ixsqr =	(IdRefMon * IdRefMon) + (IqRefMon * IqRefMon);
	MotOL = &(CheckAlarm->MotOL);
	AmpOL = &(CheckAlarm->AmpOL);
	LowOL = &(CheckAlarm->AmpLowOL);	/* <S154> */
	LowOLChkP = &(LowOL->LowOLChkP);	/* <S154> */
	ret = TRUE;							/* <S154> */


	/****************************************************************************************/
	/*		モータ過負荷アラームチェック													*/
	/****************************************************************************************/
	/*--------------------------------------------------------------------------------------*/
	/* 	モータ通常区間ＯＬチェック															*/
	/*--------------------------------------------------------------------------------------*/
//	AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, MotOL, AlmMngr );				/* <S154> */
	AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, MotOL, AlmMngr, NORMAL_AREA );	/* <S154> */

/* <S154> Start */
	/****************************************************************************************/
	/*		アンプ過負荷アラームチェック													*/
	/****************************************************************************************/
#if	CSW_SVCF_CHKAMPLOL == 1	/* 低速ＯＬあり：CSW_SVCF_CHKAMPLOL(機種定義による低速ＯＬ機能の有無)	*/
	/*--------------------------------------------------------------------------------------*/
	/*	アンプ通常区間ＯＬチェック：低速ＯＬ実行不可、または、モータ速度が通常区間		*/
	/*--------------------------------------------------------------------------------------*/
	if( (LowOLChkP->conf.LowSpdOLChkEnable == (UCHAR)FALSE) || (AbsMotSpd > LowOLChkP->conf.LowSpdOLchg) )
	{
		AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, AmpOL, AlmMngr, NORMAL_AREA);
	}
	/*--------------------------------------------------------------------------------------*/
	/*	アンプ低速区間ＯＬチェック：モータ速度が低速区間									*/
	/* 		AdetPcalOverLoadLevelAmpLow( )…アンプ低速区間過負荷チェック用パラメータ計算関数	*/
	/*		AdetExeCheckOLAmpMot( )…アンプ低速区間ＯＬチェック関数							*/
	/*--------------------------------------------------------------------------------------*/
	else if( (AbsMotSpd <= LowOLChkP->conf.LowSpdOLchg) && (LowOLChkP->conf.LockSpdOLchg <= AbsMotSpd) )
	{
		ret = AdetPcalOverLoadLevelAmpLow( CheckAlarm, AbsMotSpd);
		AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, AmpOL, AlmMngr, LOWSPD_AREA);
	}
	/*--------------------------------------------------------------------------------------*/
	/*	アンプロック区間ＯＬチェック：モータ速度がロック区間								*/
	/*--------------------------------------------------------------------------------------*/
	else
	{
		AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, AmpOL, AlmMngr,LOCK_AREA);
	}
#else
	/*--------------------------------------------------------------------------------------*/
	/*	低速ＯＬなし																		*/
	/* 	アンプ通常区間ＯＬチェック															*/
	/*--------------------------------------------------------------------------------------*/
		AdetExeCheckOLAmpMot( AbsMotSpd, Ixsqr, AmpOL, AlmMngr, NORMAL_AREA);
#endif
/* <S154> End */

	/****************************************************************************************/
	/*		過負荷ワーニングチェック														*/
	/****************************************************************************************/
	if( EncConnect == TRUE )				/* エンコーダ未接続場合はワーニング検出しない	*/
	{
		if( MotOL->var.WrnInfo || AmpOL->var.WrnInfo )
		{
			ALMSetServoAlarm( AlmMngr, WRN_OLF );			/* A.910 : 過負荷ワーニング検出	*/
		}
		else
		{
			ALMClearWarning( AlmMngr, WRN_OLF );			/* A.910 : 過負荷ワーニング解除	*/
		}
	}
	return ret;		/* <S154> */
}

/* <S154> Start */
#if		( CSW_SVCF_CHKAMPLOL == 1 ) 	
/*****************************************************************************
  Description:		アンプ低速過負荷レベルの計算(オンライン)
------------------------------------------------------------------------------
  Parameters:
	AlmMngr;		アラーム管理データポイント
	CheckAlarm;		アラーム管理データポイント
	AbsMotSpd;		Absolute Motor Speed
  Return:
	BOOL			TRUE アラームなし
					FALSE	アラームあり
------------------------------------------------------------------------------
  Note:
	モータ低速回転時に、ＯＬパラメータを速度に応じて連続的に補間してＯＬカーブを連続的に切替える。
	モータ回転速度は低速区間内であれば、中間ＯＬ電流と最大ＯＬ時間をモータ速度に応じて計算する。
	計算した中間ＯＬ電流と最大ＯＬ時間を使用して、低速区間のＯＬ検出アラームレベルを設定する。
*****************************************************************************/
static BOOL	AdetPcalOverLoadLevelAmpLow( CHECK_ALARM *CheckAlarm, LONG AbsMotSpd)
{
	LONG	Ix;
	LONG	Iy;
	LONG	Ibsqr;
	LONG	Ixsqr;
	LONG	Iysqr;
	LONG	Izsqr;
	LONG	wk;
	BOOL	ret;

	OLPRM *AmpLow;
	CHECK_OLP *AmpLowOLP;
	CHECK_OL *MotOLP;
	CHECK_OL *AmpOLP;
	CHECK_LOWOL *LowOL;
	LowOL = &(CheckAlarm->AmpLowOL);
	MotOLP = &(CheckAlarm->MotOL);
	AmpOLP = &(CheckAlarm->AmpOL);
	AmpLow = &(LowOL->LowOLPrm.AmpLow);
	AmpLowOLP = &(AmpOLP->conf.LowSpdArea);
	ret = TRUE;


	/********************************************************************************************/
	/*		低速区間中間ＯＬ電流と低速区間最大ＯＬ時間の算出									*/
	/********************************************************************************************/
	/*------------------------------------------------------------------------------------------*/
	/*	低速区間中間ＯＬ電流の計算：	Ix														*/
	/*------------------------------------------------------------------------------------------*/
	/*	wk = (モータ速度 - ロック区間変曲点速度) * (中間ＯＬ電流変換係数) 						*/
	/*	低速区間中間ＯＬ電流 = ロック区間変曲点ＯＬ電流 ＋ wk									*/
	/*------------------------------------------------------------------------------------------*/
	wk = MlibMulgain( (AbsMotSpd - LowOL->LowOLChkP.conf.LockSpdOLchg), LowOL->LowOLChkP.conf.TransOLImid );
	Ix = LowOL->LowOLChkP.conf.LowSpdOffsetImid + wk;

	/*------------------------------------------------------------------------------------------*/
	/*	低速区間最大ＯＬ時間の計算：	Iy														*/
	/*------------------------------------------------------------------------------------------*/
	/*	wk = (モータ速度-ロック区間変曲点速度) * (最大ＯＬ時間変換係数) 						*/
	/*	低速区間最大ＯＬ時間 = ロック区間変曲点ＯＬ時間＋wk										*/
	/*------------------------------------------------------------------------------------------*/
	wk = (LONG)MlibSqrtu32( AbsMotSpd - LowOL->LowOLChkP.conf.LockSpdOLchg );
	wk = MlibMulgain( wk, LowOL->LowOLChkP.conf.TransOLTmax );
	Iy = LowOL->LowOLChkP.conf.LowSpdOffsetTmax + wk;

	/*------------------------------------------------------------------------------------------*/
	/*	低速区間連続ベース電流^2：		Ibsqrmid,	Ibsqr										*/
	/*------------------------------------------------------------------------------------------*/
	Ibsqr = AmpOLP->conf.NormalArea.Ibsqrmid;
	AmpLowOLP->Ibsqrmid = Ibsqr;						/* 連続ＯＬベース電流^2のセット				*/

	/********************************************************************************************/
	/*		低速区間連続過負荷レベルの計算														*/
	/********************************************************************************************/
	/*																							*/
	/*		Ibsqr = Ibse * Ibse																	*/
	/*																							*/
	/*				  (Imid^2 - Ibse^2) * Tmid													*/
	/*		AlmLvl = ----------------------------												*/
	/*						  Cycle																*/
	/*																							*/
	/********************************************************************************************/
	/*------------------------------------------------------------------------------------------*/
	/* 	中間ＯＬ電流のチェック：	Ix															*/
	/*------------------------------------------------------------------------------------------*/
	Ix = (Ix > 0x7FFF)? 0x7FFF : Ix;
	Ixsqr = (Ix * Ix) >> 16;						/* 中間ＯＬ電流^2							*/

	/*------------------------------------------------------------------------------------------*/
	/*	連続ＯＬ検出レベル、レベルゲインの計算													*/
	/*------------------------------------------------------------------------------------------*/
	/*	Izsqr		：連続ＯＬ検出アラームレベルの分子項(中間ＯＬ電流^2 - 連続ＯＬベース電流^2)	*/
	/*	AlmLvlmid	：連続ＯＬアラーム検出レベル												*/
	/*	OlLvlmidGain：連続ＯＬ検出レベルゲイン													*/
	/*------------------------------------------------------------------------------------------*/
	Izsqr = Ixsqr - Ibsqr;
	AmpLowOLP->AlmLvlmid = MlibScalKxgain( Izsqr, 100*AmpLow->Tmid, KPI_SCCYCLEMS, NULL, -30 );
	AmpLowOLP->OlLvlmidGain = MlibScalKxgain( AmpOLP->conf.NormalArea.AlmLvlmid, 1, AmpLowOLP->AlmLvlmid, NULL, 24 );
	if( AmpLowOLP->AlmLvlmid >= 0x40000000 )
	{
//			ALMSetPramError( AlmMngr, pndef_olspdlvl.RegNumber);			/* A.040 : パラメータ設定異常				*/
		ret = FALSE;
	}

	/********************************************************************************************/
	/*		低速区間瞬時過負荷レベルの計算														*/
	/********************************************************************************************/
	/*																							*/
	/*				 (Imid^2 * Tmid) - (Imax^2 * Tmax)											*/
	/*		Ibsqr = -----------------------------------											*/
	/*						 (Tmid - Tmax)														*/
	/*																							*/
	/*				  (Imax^2 - Ibsqr) * Tmax													*/
	/*		AlmLvl = ----------------------------												*/
	/*						   Cycle															*/
	/*																							*/
	/********************************************************************************************/
	/*------------------------------------------------------------------------------------------*/
	/*	通常区間最大ＯＬ電流のチェック：	OlPrm->Imax											*/
	/*------------------------------------------------------------------------------------------*/
	if( AmpLow->Imax > 0x7FFF )						/* 下記値を片側の設定値に合わせる			*/
	{
		AmpLowOLP->Ibsqrmax = MotOLP->conf.NormalArea.Ibsqrmax;		/* 低速区間の瞬時ＯＬベース電流				*/
		AmpLowOLP->AlmLvlmax = AmpOLP->conf.NormalArea.AlmLvlmax;	/* 低速区間の瞬時ＯＬレベル					*/
		AmpLowOLP->WrnLvlmax = AmpOLP->conf.NormalArea.WrnLvlmax;	/* 低速区間の瞬時ＯＬワーニングレベル		*/
//			return;
	}
	else
	{
		Ix = AmpLow->Imax;

		Iysqr = (Ix * Ix) >> 16;						/* Iysqr：最大ＯＬ電流^2					*/

		/*------------------------------------------------------------------------------------------*/
		/*	瞬時ＯＬベース電流^2の計算：	Ibsqr													*/
		/*------------------------------------------------------------------------------------------*/
		wk = (Ixsqr * AmpLow->Tmid) - (Iysqr * Iy);		/* 瞬時ＯＬベース電流の分子項計算 			*/
		Ibsqr = ( wk ) / ( AmpLow->Tmid - Iy);			/* Ibsqr：瞬時ＯＬベース電流^2				*/

		/*------------------------------------------------------------------------------------------*/
		/* 瞬時ＯＬベース電流^2の分子項チェック 													*/
		/*------------------------------------------------------------------------------------------*/
		if( wk > 0 )
		{
			/*--------------------------------------------------------------------------------------*/
			/* 瞬時ＯＬベース電流^2のチェック														*/
			/*--------------------------------------------------------------------------------------*/
			if( Ibsqr < 0 )									/* 下記値を片側の設定値に合わせる		*/
			{
				AmpLowOLP->Ibsqrmax = MotOLP->conf.NormalArea.Ibsqrmax;		/* 瞬時ＯＬベース電流 					*/
			}
			/*--------------------------------------------------------------------------------------*/
			/* 瞬時ＯＬベース電流^2と連続ＯＬベース電流^2の大小関係チェック 						*/
			/*--------------------------------------------------------------------------------------*/
			if( Ibsqr < AmpLowOLP->Ibsqrmid )					/* 下記値を連続ＯＬの設定値に合わせる	*/
			{
				AmpLowOLP->Ibsqrmax  = AmpLowOLP->Ibsqrmid;		/* 瞬時ＯＬベース電流^2					*/
				AmpLowOLP->OlLvlmaxGain = AmpLowOLP->OlLvlmidGain;/* 瞬時ＯＬレベルゲイン				*/
			}
			/*--------------------------------------------------------------------------------------*/
			/* 瞬時ＯＬベース電流^2の設定、瞬時ＯＬレベル、レベルゲインの計算						*/
			/*--------------------------------------------------------------------------------------*/
			/*	Izsqr		：瞬時ＯＬ検出アラームレベルの分子項(最大ＯＬ電流^2 - 瞬時ベース電流^2)	*/
			/*	Ibsqrmax	：瞬時ＯＬベース電流^2													*/
			/*	AlmLvlmax	：瞬時ＯＬアラーム検出レベル											*/
			/*	OlLvlmaxGain：瞬時ＯＬ検出レベルゲイン												*/
			/*--------------------------------------------------------------------------------------*/
			else
			{
				Izsqr = Iysqr - Ibsqr;
				AmpLowOLP->Ibsqrmax  = Ibsqr;
				AmpLowOLP->AlmLvlmax = MlibScalKxgain( Izsqr, (100*Iy), KPI_SCCYCLEMS, NULL, -30 );
				AmpLowOLP->OlLvlmaxGain = MlibScalKxgain( AmpOLP->conf.NormalArea.AlmLvlmax, 1, AmpLowOLP->AlmLvlmax, NULL, 24 );
				if( AmpLowOLP->AlmLvlmax >= 0x40000000 )
				{
//						ALMSetPramError( AlmMngr, pndef_olspdlvl.RegNumber);		/* A.040 : パラメータ設定異常			*/
					ret = FALSE;
				}
			}
		}

		/********************************************************************************************/
		/*	低速区間の連続ＯＬレベル、瞬時ＯＬレベル、連続ワーニングレベル、瞬時ワーニングレベル設定*/
		/*		低速区間の検出レベルを通常区間の検出レベルに設定する								*/
		/********************************************************************************************/
		AmpLowOLP->AlmLvlmid = AmpOLP->conf.NormalArea.AlmLvlmid;		/* 低速区間の連続ＯＬレベル					*/
		AmpLowOLP->AlmLvlmax = AmpOLP->conf.NormalArea.AlmLvlmax;		/* 低速区間の瞬時ＯＬレベル					*/
		AmpLowOLP->WrnLvlmid = AmpOLP->conf.NormalArea.WrnLvlmid;		/* 低速区間の連続ＯＬワーニングレベル		*/
		AmpLowOLP->WrnLvlmax = AmpOLP->conf.NormalArea.WrnLvlmax;		/* 低速区間の瞬時ＯＬワーニングレベル		*/
	}
	return	ret;
}
/*--------------------------------------------------------------------------------------------------*/
#endif
/* <S154> End */

/****************************************************************************************************/
/*																									*/
/*		アンプ＆モータ過負荷チェック処理実行関数													*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 電流指令の２乗からベース値を減算したものを積算する。									*/
/*			積算値が過負荷アラーム検出レベルを越えたら過負荷アラームとする。						*/
/*			積算値が負の場合は、温度上昇は停止していると判断され積算値は０でリミットする。			*/
/*			積算値がシステム定数で決められた割合に相当する値に達したらワーニングとする。			*/
/*																									*/
/****************************************************************************************************/
//static void	AdetExeCheckOLAmpMot( LONG AbsMotSpd, LONG Ixsqr, CHECK_OL *ol_ptr, ALMMAN_HANDLE *AlmMngr )			/* <S154> */
static void	AdetExeCheckOLAmpMot( LONG AbsMotSpd, LONG Ixsqr, CHECK_OL *ol_ptr, ALMMAN_HANDLE *AlmMngr, UCHAR Mode )	/* <S154> */
{
	CHECK_OLP	*CheckOLP;		/* <S154> */
	LONG	Sumx;
	LONG	Ixsqr_s;
	LONG	reduceLoad;
//	LONG	reduceLoad_s;
	LONG	ltmp;

	/* ローカル変数の初期化 */
	Ixsqr_s = Ixsqr >> 16;

/* <S154> Start */
/*--------------------------------------------------------------------------------------------------*/
/*		過負荷演算区間選択																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( Mode == NORMAL_AREA )
	{
		CheckOLP = &(ol_ptr->conf.NormalArea);
	}
	else if( Mode == LOWSPD_AREA )
	{
		CheckOLP = &(ol_ptr->conf.LowSpdArea);
	}
	else if( Mode == LOCK_AREA )
	{
		CheckOLP = &(ol_ptr->conf.LowSpdArea);
	}
	else
	{
		CheckOLP = &(ol_ptr->conf.NormalArea);
	}
/* <S154> End */

#if (FLOAT_USE==TRUE)
//	reduceLoad = 16384 - (LONG)( (float)AbsMotSpd * ol_ptr->conf.CoolRateGain);		/* 自走冷却率	*/	/* <S154> */
	reduceLoad = 16384 - (LONG)( (float)AbsMotSpd * CheckOLP->CoolRateGain);		/* 自走冷却率	*/	/* <S154> */
#else
//	reduceLoad = 16384 - MlibMulgain( AbsMotSpd, ol_ptr->conf.CoolRateGain );		/* 自走冷却率	*/	/* <S154> */
	reduceLoad = 16384 - MlibMulgain( AbsMotSpd, CheckOLP->CoolRateGain );			/* 自走冷却率	*/	/* <S154> */
#endif /* FLOAT_USE */
//	reduceLoad_s = reduceLoad >> 14;

/*--------------------------------------------------------------------------------------------------*/
/*		開始処理																					*/
/*--------------------------------------------------------------------------------------------------*/
	ol_ptr->var.WrnInfo = 0x00;					/* ワーニング情報リセット					*/

	/********************************************************************************************/
	/*		瞬時過負荷のチェック																*/
	/********************************************************************************************/
#if 1	/* <S154> */
#if (FLOAT_USE==TRUE)
	if( CheckOLP->CoolRateGain == 0 )
	{
		ltmp = (LONG)( (float)(Ixsqr_s - CheckOLP->Ibsqrmax) * CheckOLP->OlLvlmaxGain );
	}
	else
	{
		ltmp = (LONG)( (float)((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - CheckOLP->Ibsqrmax) * CheckOLP->OlLvlmaxGain );
	}
#else
	if( CheckOLP->CoolRateGain == 0 )
	{
		ltmp = MlibMulgain( (Ixsqr_s - CheckOLP->Ibsqrmax), CheckOLP->OlLvlmaxGain );
	}
	else
	{
	//	ltmp = MlibMulgain( (((SHORT)Ixsqr_s * (SHORT)reduceLoad_s) - CheckOLP->Ibsqrmax), CheckOLP->OlLvlmaxGain );
		ltmp = MlibMulgain( ((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - CheckOLP->Ibsqrmax), CheckOLP->OlLvlmaxGain );
	}
#endif /* FLOAT_USE */
#else	/* <S154> */
#if (FLOAT_USE==TRUE)
	if( ol_ptr->conf.CoolRateGain == 0 )
	{
		ltmp = (LONG)( (float)(Ixsqr_s - ol_ptr->conf.Ibsqrmax) * ol_ptr->conf.OlLvlmaxGain );
	}
	else
	{
		ltmp = (LONG)( (float)((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - ol_ptr->conf.Ibsqrmax) * ol_ptr->conf.OlLvlmaxGain );
	}
#else
	if( ol_ptr->conf.CoolRateGain == 0 )
	{
		ltmp = MlibMulgain( (Ixsqr_s - ol_ptr->conf.Ibsqrmax), ol_ptr->conf.OlLvlmaxGain );
	}
	else
	{
	//	ltmp = MlibMulgain( (((SHORT)Ixsqr_s * (SHORT)reduceLoad_s) - ol_ptr->conf.Ibsqrmax), ol_ptr->conf.OlLvlmaxGain );
		ltmp = MlibMulgain( ((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - ol_ptr->conf.Ibsqrmax), ol_ptr->conf.OlLvlmaxGain );
	}
#endif /* FLOAT_USE */
#endif	/* <S154> */
	Sumx = (LONG)( ol_ptr->var.SumImax + ltmp );

	/*------------------------------------------------------------------------------------------*/
//	if( Sumx >= ol_ptr->conf.AlmLvlmax )			/* 積算値 >= アラームレベル					*/	/* <S154> */
	if( Sumx >= CheckOLP->AlmLvlmax )				/* 積算値 >= アラームレベル					*/	/* <S154> */
	{
		ol_ptr->var.SumImax = Sumx;
		ALMSetServoAlarm( AlmMngr, ALM_OLF1 );		/* A.710 : 過負荷(瞬時最大負荷)				*/
	}
//	if( Sumx >= ol_ptr->conf.WrnLvlmax )			/* 積算値 >= ワーニングレベル 				*/	/* <S154> */
	if( Sumx >= CheckOLP->WrnLvlmax )				/* 積算値 >= ワーニングレベル 				*/	/* <S154> */
	{
		ol_ptr->var.SumImax = Sumx;
		ol_ptr->var.WrnInfo |= 0x01;				/* ワーニング情報設定						*/
	}
	else if( Sumx >= 0 )							/* 積算値 >= 0								*/
	{
		ol_ptr->var.SumImax = Sumx;
	}
	else											/* 積算値 < 0								*/
	{
		ol_ptr->var.SumImax = 0;
	}

	/********************************************************************************************/
	/*		連続過負荷のチェック																*/
	/********************************************************************************************/
#if 1	/* <S154> */
#if (FLOAT_USE==TRUE)
	if( CheckOLP->CoolRateGain == 0 )
	{
		ltmp = (LONG)( (float)(Ixsqr_s - CheckOLP->Ibsqrmid) * CheckOLP->OlLvlmidGain );
	}
	else
	{
		ltmp = (LONG)( (float)((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - CheckOLP->Ibsqrmid) * CheckOLP->OlLvlmidGain );
	}
#else
	if( CheckOLP->CoolRateGain == 0 )
	{
		ltmp = MlibMulgain( (Ixsqr_s - CheckOLP->Ibsqrmid), CheckOLP->OlLvlmidGain );
	}
	else
	{
	//	ltmp = MlibMulgain( ( ((SHORT)Ixsqr_s * (SHORT)reduceLoad_s) - CheckOLP->Ibsqrmid), CheckOLP->OlLvlmidGain );
		ltmp = MlibMulgain( ((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - CheckOLP->Ibsqrmid), CheckOLP->OlLvlmidGain );
	}
#endif /* FLOAT_USE */
#else	/* <S154> */
#if (FLOAT_USE==TRUE)
	if( ol_ptr->conf.CoolRateGain == 0 )
	{
		ltmp = (LONG)( (float)(Ixsqr_s - ol_ptr->conf.Ibsqrmid) * ol_ptr->conf.OlLvlmidGain );
	}
	else
	{
		ltmp = (LONG)( (float)((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - ol_ptr->conf.Ibsqrmid) * ol_ptr->conf.OlLvlmidGain );
	}
#else
	if( ol_ptr->conf.CoolRateGain == 0 )
	{
		ltmp = MlibMulgain( (Ixsqr_s - ol_ptr->conf.Ibsqrmid), ol_ptr->conf.OlLvlmidGain );
	}
	else
	{
	//	ltmp = MlibMulgain( ( ((SHORT)Ixsqr_s * (SHORT)reduceLoad_s) - ol_ptr->conf.Ibsqrmid), ol_ptr->conf.OlLvlmidGain );
		ltmp = MlibMulgain( ((((SHORT)Ixsqr_s * (SHORT)reduceLoad)>>14) - ol_ptr->conf.Ibsqrmid), ol_ptr->conf.OlLvlmidGain );
	}
#endif /* FLOAT_USE */
#endif	/* <S154> */
	Sumx = (LONG)( ol_ptr->var.SumImid + ltmp );

	/*------------------------------------------------------------------------------------------*/
//	if( Sumx >= ol_ptr->conf.AlmLvlmid )			/* 積算値 >= アラームレベル					*/	/* <S154> */
	if( Sumx >= CheckOLP->AlmLvlmid )				/* 積算値 >= アラームレベル					*/	/* <S154> */
	{
		ol_ptr->var.SumImid = Sumx;
		ALMSetServoAlarm( AlmMngr, ALM_OLF2 );		/* A.720 : 過負荷(連続最大負荷)				*/
	}
//	if( Sumx >= ol_ptr->conf.WrnLvlmid )			/* 積算値 >= ワーニングレベル				*/	/* <S154> */
	if( Sumx >= CheckOLP->WrnLvlmid )				/* 積算値 >= ワーニングレベル				*/	/* <S154> */
	{
		ol_ptr->var.SumImid = Sumx;
		ol_ptr->var.WrnInfo |= 0x02;				/* ワーニング情報設定						*/
	}
	else if( Sumx >= 0 )							/* 積算値 >= 0								*/
	{
		ol_ptr->var.SumImid = Sumx;
	}
	else											/* 積算値 < 0								*/
	{
		ol_ptr->var.SumImid = 0;
	}
}



/****************************************************************************************************/
/*																									*/
/*		ＤＢ過負荷チェック処理																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ＤＢ電力積算値を計算し、過負荷レベルを越えた場合、ＤＢ過負荷アラームとする。			*/
/*			また、平均ＤＢ電力値を計算する。														*/
/*			温度上昇によるＤＢ過負荷も検出する。													*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckDbrakeOverLoad( ALMMAN_HANDLE *AlmMngr, CHECK_DBOL *DbOL, BOOL DbOn, LONG AbsMotSpd )
{
	LONG	x;
	LONG	DbPower;

/*--------------------------------------------------------------------------------------------------*/
/*		ＤＢ電力の計算																				*/
/*--------------------------------------------------------------------------------------------------*/
/*																									*/
/*					 PowerMax * Speed * Speed														*/
/*		DbPower  = --------------------------- = Kdbpower * (Speed>>9) * (Speed>>9)					*/
/*					   SpdLevel * SpdLevel															*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
	if( DbOn )
	{
		if( AbsMotSpd >= DbOL->conf.DbolSpdLevel )
		{
			DbPower = DbOL->conf.DbolPowMax;
		}
		else
		{
			x = (AbsMotSpd >> 9);
#if (FLOAT_USE==TRUE)
			DbPower = x * x * DbOL->conf.Kdbpower;
#else
			DbPower = MlibMulgainSx48( (x * x), DbOL->conf.Kdbpower );
#endif /* FLOAT_USE */
		}
	}
	else
	{
		DbPower = 0;
		DbOL->var.DbHeat = 0;							/* 温度上昇によるDB過負荷積算値クリア	*/
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＤＢ電力積算値の計算																		*/
/*--------------------------------------------------------------------------------------------------*/
	DbOL->var.DbolPowSum += (DbPower - DbOL->conf.DbolPowBase );
	/*----------------------------------------------------------------------------------------------*/
	/*	DB電力積算値オーバーフロー対策																*/
	/*	⇒DB状態で外力によって回され続けるとDB電力積算値がオーバーフローするのでリミット処理を追加	*/
	/*		現在のモータ定数から１サンプルで積算される最大値(DbOL->conf.DbolPowMax)は、				*/
	/*		検討の結果18bit未満であるため、リミットレベルを2^30とする。								*/
	/*----------------------------------------------------------------------------------------------*/
	if( DbOL->var.DbolPowSum > 0x40000000)
	{
		DbOL->var.DbolPowSum = 0x40000000;
	}
	if( DbOL->var.DbolPowSum < 0 )
	{
		DbOL->var.DbolPowSum = 0;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		ＤＢ過負荷のチェック																		*/
/*--------------------------------------------------------------------------------------------------*/
	if( DbOL->var.DbolPowSum >= DbOL->conf.DbolAlmLevel )
	{
		/* A.730 : ＤＢ過負荷 */
		ALMSetServoAlarm( AlmMngr, ALM_DBOL );
	}

/*--------------------------------------------------------------------------------------------------*/
/*		Un00B : ＤＢ抵抗消費電力用データ(10secＤＢ消費電力平均値)	CoutV.UnMeanDbPower				*/
/*		Un144 : ＤＢ抵抗消費電力用データ(2msＤＢ消費電力値)			CoutV.UnDBPower					*/
/*--------------------------------------------------------------------------------------------------*/
#if (FLOAT_USE==TRUE)
	DbOL->var.UnDbPower = DbPower * DbOL->conf.KundbpowerCycle;
#else
	DbOL->var.UnDbPower = MlibMulgain( DbPower, DbOL->conf.KundbpowerCycle );
#endif /* FLOAT_USE */
	DbOL->var.DbPowerSum += DbPower;

	DbOL->var.DbMeanCycle++;
	if( DbOL->var.DbMeanCycle >= KPI_SCANC_MS( 10000 ) )
	{
#if (FLOAT_USE==TRUE)
		DbOL->var.UnMeanDbPower = DbOL->var.DbPowerSum * DbOL->conf.Kundbpower;
#else
		DbOL->var.UnMeanDbPower = MlibMulgain( DbOL->var.DbPowerSum, DbOL->conf.Kundbpower );
#endif /* FLOAT_USE */
		DbOL->var.DbPowerSum  = 0;
		DbOL->var.DbMeanCycle = 0;
	}

/*--------------------------------------------------------------------------------------------------*/
/*		温度上昇によるＤＢ過負荷ワーニング・アラーム検出処理										*/
/*--------------------------------------------------------------------------------------------------*/
	if ( DbOL->conf.DbOHeatCheck )
	{
		DbOL->var.DbHeat += (DbPower - DbOL->conf.DbolPowBase );
		if ( DbOL->var.DbHeat >= DbOL->conf.DbOHeatAlmLvl )
		{
			/* A.921 : 温度上昇によるＤＢ過負荷ワーニングクリア */
			ALMClearWarning( AlmMngr, WRN_DBOL_LVL );
			/* ワーニング検出中フラグクリア */
			DbOL->var.DbOHeatWarn = FALSE;
			/* A.731 : 温度上昇によるＤＢ過負荷セット */
			ALMSetServoAlarm( AlmMngr, ALM_DBOL_LVL );
		}
		else if ( (DbOL->var.DbHeat >= DbOL->conf.DbOHeatWrnLvl)
				&& (DbOL->var.DbOHeatWarn == FALSE) )
		{
			/* A.921 : 温度上昇によるＤＢ過負荷ワーニングセット */
			ALMSetServoAlarm( AlmMngr, WRN_DBOL_LVL );
			/* ワーニング検出中フラグセット */
			DbOL->var.DbOHeatWarn = TRUE;
		}
	}

	if ( (DbOL->var.DbolPowSum == 0) && (DbOL->var.DbOHeatWarn == TRUE) )
	{
		/* A.921 : 温度上昇によるＤＢ過負荷ワーニングクリア */
		ALMClearWarning( AlmMngr, WRN_DBOL_LVL );
		/* ワーニング検出中フラグクリア */
		DbOL->var.DbOHeatWarn = FALSE;
		/* 積算値クリア */
		DbOL->var.DbHeat = 0;
	}

}

/****************************************************************************************************/
/*																									*/
/*		速度リップル補償情報不一致ワーニングチェック処理											*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : EEPROMに保存した前回接続時のモータのシリアル番号が、今回接続したモータのシリアル番号と	*/
/*          一致しない場合に、速度リップル補償情報不一致ワーニングを検出する						*/
/*																									*/
/*																									*/
/****************************************************************************************************//*<S1FD>*/
void	AdetCheckRippleWrn( ALMMAN_HANDLE *AlmMngr, BOOL RippleWrnState )
{
	/* 速度リップル補償情報不一致ワーニング状態取得 */
	if( RippleWrnState == FALSE )
	{
		ALMSetServoAlarm( AlmMngr, WRN_RIPPLE );	/* A.942 : 速度リップル補償情報不一致検出 */
	}
	else
	{
		ALMClearWarning( AlmMngr, WRN_RIPPLE );		/* A.942 : 速度リップル補償情報不一致解除 */
	}
}

#if	0	/*<S1F6>*/
/****************************************************************************************************/
/*																									*/
/*		入力信号タイミング異常チェック処理															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : BBON1LT/BBON2LT信号がアクティブになる時間差がパラメータ設定値以上の時間差の場合に		*/
/*			アラームとする。これは、２重化信号の異常（ハードウェアの故障、入力信号の断線）を		*/
/*			検出するための処置である。本処理では、セーフティオプションカードの有無により			*/
/*			アラームコード（ｶｰﾄﾞ有/無=A.Eb2/A.Eb1）およびアラーム検出に用いる設定値					*/
/*			（カード有/無= PnE4C/Pn620）を変更する。												*/
/*																									*/
/****************************************************************************************************/
BOOL	AdetCheckBbonSignal( CHECK_HWBB_TIMING *pHwbbTmg, BOOL LackOneBbon )
{
	BOOL err;

	err = FALSE;
	/*--------------------------------------------------------------------------------------------------*/
	/*		BBON信号入力タイミング異常チェック処理														*/
	/*--------------------------------------------------------------------------------------------------*/
		if( LackOneBbon )
		{
			pHwbbTmg->var.BbonTimeDiffCnt += KPI_SCCYCLEMS;
			if( pHwbbTmg->var.BbonTimeDiffCnt > pHwbbTmg->conf.MaxBbonTimeDiff )
			{
				/* 上限を設定値でクランプ */
				pHwbbTmg->var.BbonTimeDiffCnt = pHwbbTmg->conf.MaxBbonTimeDiff;

				/* A.Eb1 : 停止信号入力時間差過大(カード無) */
				err = TRUE;
			}
		}
		else		/* <S0E5> */
		{
			pHwbbTmg->var.BbonTimeDiffCnt = 0;
		}
		return err;
}
#endif	/*<S1F6>*/

#if 0	/*<S1F5>*/
/****************************************************************************************************/
/*																									*/
/*		セーフティ機能　内部信号異常検出処理 (Test Pulse Diagnostic)					<S0F1>		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : アンプ側の内部信号(DPIN1/DPIN2信号)がパルス信号でない場合は異常検出する					*/
/*			HWBB状態の場合は異常検出しない															*/
/*																									*/
/****************************************************************************************************/
BOOL	AdetTestPulseDiagnostic( BOOL DpInState, BOOL DpInLastState, BOOL CheckEnable, BOOL Bbon )	/*<S1DC>*/
{
	BOOL err;

	err = FALSE;

#if((PRODUCT_SERIES_SEVEN  ==  TRUE) && ( CSW_BOARD_TYPE == SGD7S_TYPE ) ) || ( CSW_HW_HWBB_SUPPORT == TRUE)		/* SGD7WでA.EC8,A.EC9誤検出を修正<S105> */
/*--------------------------------------------------------------------------------------------------*/
/*		DPIN信号チェック処理（BBON=OFF：HWBB状態はチェックしない）									*/
/*--------------------------------------------------------------------------------------------------*/
	if( CheckEnable )
	{
		/*------------------------------------------------------------------------------------------*/
		/*	DPIN信号が4ms周期のパルス信号でない場合は異常											*/
		/*------------------------------------------------------------------------------------------*/
		if( !(DpInState^DpInLastState) )
		{
			err = TRUE;
		}
	}
/* <S1DC> >>>>> */
	else if( Bbon )
	{
		/*------------------------------------------------------------------------------------------*/
		/*	BBON=OFF(HIGH)のとき、DPIN信号がHIGHでない場合は異常										*/
		/*------------------------------------------------------------------------------------------*/
		if( DpInState )
		{
			err = TRUE;
		}
	}
/* <<<<< <S1DC> */
#endif

	return err;
}
#endif	/*<S1F5>*/

#if 0
/****************************************************************************************************/
/*																									*/
/*		ゲートドライブ異常チェック処理																*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : ハード的にHWBB検出回路が存在し、かつ、ソフト的にHWBB機能を無効とする機種において、		*/
/*			HWBB状態を検出した場合にアラームとする。ノイズ等でBBON信号がアクティブになりハード		*/
/*			ワイヤードベースブロック状態になった場合を考慮したもので、ソフトウェアでもHWBB検出		*/
/*			処理は走らせておき、HWBB状態を検出した際には『HBB』表示はせずにゲートドライブ異常		*/
/*			アラームとする。本来はハードウェアにてHWBB状態にはなり得ない処置が取られているが		*/
/*			ソフトウェア的にもインタロックはとっておく。											*/
/*																									*/
/****************************************************************************************************/
BOOL	AdetCheckGateDriveDefect( DET_HWBB_STS *pDetHwbbSts )
{
/*--------------------------------------------------------------------------------------------------*/
/*		ゲートドライブ異常チェック処理																*/
/*--------------------------------------------------------------------------------------------------*/
	return pDetHwbbSts->GateDrvDefect;
}
#endif



/****************************************************************************************************/
/*																									*/
/*		モータ暴走チェック処理																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : モータ線(Ｕ,Ｖ,Ｗ相)の誤配線による暴走の検出を行う。									*/
/*			アラームの検出は電源投入時の最初のモータの動き始めだけを見る。							*/
/*																									*/
/*			検出条件は、																			*/
/*			＜回転形の場合＞																		*/
/*				暴走アラームマスクしていない														*/
/*			  ∩電源投入後サーボオンしてモータが動き始めてから0.5msec以内							*/
/*			  ∩速度FBとトルク指令が逆極性															*/
/*			  ∩前回トルク指令と今回トルク指令が同極性												*/
/*			  ∩トルク指令≧暴走検出トルク															*/
/*			  ∩速度FB≧暴走検出速度																*/
/*			  ∩トルク指令が0でない																	*/
/*			  ∩今回速度≧前回速度(加速中)															*/
/*			  ∩今回速度≧過去に発生した最大速度													*/
/*			の状態が、20ms連続した場合にアラームとする。											*/
/*																									*/
/*			＜リニアの場合＞																		*/
/*				速度FBとトルク指令が逆極性															*/
/*			  ∩前回トルク指令と今回トルク指令が同極性												*/
/*			  ∩トルク指令≧暴走検出トルク															*/
/*			  ∩速度FB≧暴走検出速度																*/
/*			  ∩トルク指令が0でない																	*/
/*			  ∩今回速度≧前回速度(加速中)															*/
/*			  ∩今回速度≧過去に発生した最大速度													*/
/*			の状態が、14ms連続した場合にアラームとする。											*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckMotorOverrun( ALMMAN_HANDLE *AlmMngr, CHECK_OVRRUN *OvrRun,
								 LONG MotSpd, LONG TrqRefMon, LONG BaseEnableSts, BOOL MotTypeLinear )
{
	LONG	Condition0;
	LONG	Condition1;
	LONG	DetectTime;
	LONG	AbsTrqRefMon;
	LONG	AbsMotSpd;

	AbsTrqRefMon = MlibLABS( TrqRefMon );
	AbsMotSpd = MlibLABS( MotSpd );

	if(MotTypeLinear != FALSE)
	{ /* リニア型 */
		Condition0 = TRUE;
		Condition1 = FALSE;
		DetectTime = KPI_SCANC_MS( 14 );
		OvrRun->OvrPeakMotSpd = 0;				/* 最大速度常時クリア */
	}
	else
	{ /* 回転型 */
		/* BaseEnable && 電源投入から0.5sec */
		if( (BaseEnableSts == 0) && (OvrRun->OvrChkCnt < KPI_SCANC_MS( 500 )) )
		{
			Condition0 = TRUE;
		}
		else
		{
			Condition0 = FALSE;
		}
		/* 速度 ≧ OS速度の1/10? */
		if( (OvrRun->OvrChkCnt != 0) || (AbsMotSpd >= MOTSPD_OS_10) )
		{
			Condition1 = TRUE;
		}
		else
		{
			Condition1 = FALSE;
		}
		DetectTime = KPI_SCANC_MS( 20 );
	}

	if( Condition0 )
	{
		if( Condition1 )
		{
			OvrRun->OvrChkCnt++;
		}
	/*----------------------------------------------------------------------------------------------*/
		if( ((MotSpd ^ TrqRefMon) < 0)						/* 速度FBとトルク指令の極性は逆?	*/
			&& ((TrqRefMon ^ OvrRun->OvrTrqRef) >= 0)		/* 前回トルクと今回トルクは同極性?	*/
			&& (AbsTrqRefMon >= OvrRun->OvrTrqLevel)		/* トルク指令 ≧ 暴走検出トルク?	*/
			&& (AbsMotSpd >= OvrRun->OvrSpdLevel)			/* 速度FB     ≧ 暴走検出速度?		*/
			&& (TrqRefMon != 0) )							/* トルク指令が0でない?				*/
		{
			if( AbsMotSpd >= OvrRun->OvrAbsMotSpd )
			{ /* 今回速度 ≧ 前回速度? */
				if( AbsMotSpd >= OvrRun->OvrPeakMotSpd )
				{ /* 今回速度 ≧ 過去の最大速度? */
					if( OvrRun->OvrAlmCnt >= DetectTime )
					{ /* 検出時間経過? */
						/* A.C10 : 暴走防止検出 */
						ALMSetServoAlarm( AlmMngr, ALM_RWF );
					}
					else
					{
						/* 暴走検出カウンタのカウントアップ */
						OvrRun->OvrAlmCnt++;
					}
				}
				else
				{
					/* 暴走検出カウンタのクリア */
					OvrRun->OvrAlmCnt = 0;
				}
			}
			else
			{
				if( OvrRun->OvrAbsMotSpd > OvrRun->OvrPeakMotSpd )
				{ /* 前回速度 ≧ 最大速度? */
					/* 最大速度の更新 */
					OvrRun->OvrPeakMotSpd = OvrRun->OvrAbsMotSpd;
				}
				/* 暴走検出カウンタのクリア */
				OvrRun->OvrAlmCnt = 0;
			}
		}
		else
		{
			/* 暴走検出カウンタのクリア */
			OvrRun->OvrAlmCnt = 0;
		}
	}

	/* 前回トルクの更新 */
	OvrRun->OvrTrqRef = TrqRefMon;
	/* 前回モータ速度の更新 */
	OvrRun->OvrAbsMotSpd = AbsMotSpd;
}



/****************************************************************************************************/
/*																									*/
/*		サーボオン時位置偏差過大チェック処理														*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 位置制御モード時のサーボオン時の位置偏差を監視する。									*/
/*																									*/
/*			1) 位置偏差が位置偏差過大アラームレベルを超えている場合、アラームとする。				*/
/*			2) 位置偏差が位置偏差過大ワーニングレベルを超えている場合、ワーニングとする。			*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckSvonPerrOverFlow( ALMMAN_HANDLE *AlmMngr, CHECK_OVRPOSERR *OvrPosErr, LONG PositionError )
{
	LONG	AbsPosError;

	/* ローカル変数の初期化 */
	AbsPosError = MlibLABS( PositionError );

#if 0
/*--------------------------------------------------------------------------------------------------*/
/*		制御モードチェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( pSeqCtrl->CtrlMode.b.cm != CTRLMODE_POS )
	{
		ALMClearWarning( AlmMngr, WRN_BEOF );			/* A.901 : サーボオン時位置偏差過大			*/
		return;
	}
/*--------------------------------------------------------------------------------------------------*/
/*		ベースイネーブル要求チェック																*/
/*--------------------------------------------------------------------------------------------------*/
	if( (pSeqCtrl->DbBeReq == FALSE) || (pSeqCtrl->BeReqSeqOut == TRUE) )
	{ /* ベースイネーブル要求なし || サーボオン完了 */
		ALMClearWarning( AlmMngr, WRN_BEOF );			/* A.901 : サーボオン時位置偏差過大			*/
		return;
	}
#endif
/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差チェック(ベースイネーブル要求あり && サーボオン未完の場合)							*/
/*--------------------------------------------------------------------------------------------------*/
	if( AbsPosError >= OvrPosErr->SvonPerAlmLevel )
	{
		ALMSetServoAlarm( AlmMngr, ALM_BEOF );			/* A.D01 : サーボオン時位置偏差過大			*/
	}
	/*----------------------------------------------------------------------------------------------*/
	if( AbsPosError >= OvrPosErr->SvonPerWrnLevel )
	{
		ALMSetServoAlarm( AlmMngr, WRN_BEOF );			/* A.901 : サーボオン時位置偏差過大			*/
	}
	else
	{
		ALMClearWarning( AlmMngr, WRN_BEOF );			/* A.901 : サーボオン時位置偏差過大			*/
	}
}



/****************************************************************************************************/
/*																									*/
/*		位置偏差過大チェック処理																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機 能 : 位置制御モード時の位置偏差を監視する。													*/
/*																									*/
/*			1) 位置偏差が位置偏差過大アラームレベルを超えている場合、アラームとする。				*/
/*			2) 位置偏差が位置偏差過大ワーニングレベルを超えている場合、ワーニングとする。			*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
void	AdetCheckPerrOverFlow( ALMMAN_HANDLE *AlmMngr, CHECK_OVRPOSERR *OvrPosErr,
										BOOL PosCtrlMode, LONG PositionError, BOOL SvonSpdLmt )
{
	LONG	AbsPosError;

	/* ローカル変数の初期化 */
	AbsPosError = MlibLABS( PositionError );

/*--------------------------------------------------------------------------------------------------*/
/*		制御モードチェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( FALSE == PosCtrlMode )
	{
		/* A.900 : 位置偏差過大ワーニング */
		ALMClearWarning( AlmMngr, WRN_OF );
		return;
	}
/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
	if( AbsPosError >= OvrPosErr->PerAlmLevel )
	{
		if( SvonSpdLmt )
		{
			/* A.D02 : サーボオン時速度制限位置偏差過大 */
			ALMSetServoAlarm( AlmMngr, ALM_BEVLMTOF );
		}
		else
		{
			/* A.D00 : 位置偏差過大 */
			ALMSetServoAlarm( AlmMngr, ALM_OF );
		}
	}
	/*----------------------------------------------------------------------------------------------*/
	if( AbsPosError >= OvrPosErr->PerWrnLevel )
	{
		/* A.900 : 位置偏差過大ワーニング */
		ALMSetServoAlarm( AlmMngr, WRN_OF );
	}
	else
	{
		/* A.900 : 位置偏差過大ワーニング */
		ALMClearWarning( AlmMngr, WRN_OF );
	}
}

#if	(CSW_SVCF_FULC_MODE != CSW_FULC_NO_SUPPORT)
/****************************************************************************************************/
/*																									*/
/*		モータ負荷位置間偏差過大チェック処理														*/
/*																									*/
/****************************************************************************************************//* <S04D> */
static BOOL LpxCheckSemiFullPerrOverFlow(CHECK_FENCPOSERR *ChkFposErr,
                                         	   BOOL PosCtrlMode, LONG MencPos, LONG FencPos)
{
	LONG	err_d10;
	LONG	wk;
	LONG	dMotPos, dFencPos;
	LONG	MtPGSubUnit, ExtPGSubUnit;

	err_d10 = FALSE;

	dMotPos = MencPos - ChkFposErr->MencPosLast;
	dFencPos = FencPos - ChkFposErr->FencPosLast;
	ChkFposErr->MencPosLast = MencPos;
	ChkFposErr->FencPosLast = FencPos;

	if( FALSE == PosCtrlMode )
	{/* 位置制御モード以外の時	*/
		MlibResetLongMemory( &ChkFposErr->sfperra, sizeof(ChkFposErr->sfperra)/4 );
		KlibRstLongTimer(&ChkFposErr->FSOFAlmCnt);
		return err_d10;
	}

	MtPGSubUnit = MlibEgearRvscnv( dMotPos, &ChkFposErr->Egear, &ChkFposErr->MtPGRem );		/*  実位置	[指令単位]	*/
	ExtPGSubUnit = MlibEgearRvscnv( dFencPos, &ChkFposErr->Egear, &ChkFposErr->ExtPGRem );	/*  実位置	[指令単位]	*/
	MlibPerrcala( ExtPGSubUnit, MtPGSubUnit, &ChkFposErr->sfgear, &ChkFposErr->sfperra );

	if ( MlibAbs32( FencPos- ChkFposErr->FencPosOneTurn ) >= ChkFposErr->fcpgpls )
	{
		ChkFposErr->FencPosOneTurn = FencPos;

		/* モータ1回転時は偏差を減少率(Pn52A)分減らす	*/
		if ( ChkFposErr->fpgcutrate == 100 )
		{
			MlibResetLongMemory( &ChkFposErr->sfperra, sizeof(ChkFposErr->sfperra)/4 );	/* 位置管理用変数初期化	*/
		}
		else
		{
#if (FLOAT_USE==TRUE)
			wk = ChkFposErr->sfperra.per32s * ChkFposErr->fpgcutratelv;
#else
			wk = MlibMulgain32( ChkFposErr->sfperra.per32s, ChkFposErr->fpgcutratelv );
#endif /* FLOAT_USE */
			MlibPerrcala( -wk, 0, &ChkFposErr->sfgear, &ChkFposErr->sfperra );
		}
	}

	if ( ChkFposErr->fpgoverLevel != 0 )
	{/* フルクローズド制御 && Pn51C:Pn51B != 0	*/
		if ( (ChkFposErr->sfperra.per64[1] > 0) ||
			 (ChkFposErr->sfperra.per64[1] < -1) ||
			 (MlibAbs32(ChkFposErr->sfperra.per64[0]) >= (LONG)ChkFposErr->fpgoverLevel) )
		{
			/* 20ms 継続でアラーム	*/
			if ( KlibGetLongTimerMs(ChkFposErr->FSOFAlmCnt) >= 20 )
			{	/* A.D10 : モータ−負荷位置間偏差過大		*/
//				KPI_ALARMSET( ALM_FSOF );
				err_d10 = TRUE;
			}
		}
		else
		{
			KlibRstLongTimer(&ChkFposErr->FSOFAlmCnt);
		}
	}
	else
	{
		KlibRstLongTimer(&ChkFposErr->FSOFAlmCnt);
	}

	return err_d10;
}

/****************************************************************************************************/
/*																									*/
/*		モータ負荷位置間偏差過大チェック処理														*/
/*																									*/
/****************************************************************************************************//* <S04D> */
void AdetCheckFullcEncoderAlarm(CHECK_FENCPOSERR *ChkFposErr, MENCV *FencV,
                            	BOOL PosCtrlMode, LONG MencPos, LONG FencPos, ALMMAN_HANDLE *AlmMngr )
{
	UCHAR AlmCode;

	/*----------------------------------------------------------------------*/
	/*		アラームコードチェック（BIT 0〜3）								*/
	/*----------------------------------------------------------------------*/
	AlmCode = FencGetFencAlarm(FencV);
	switch(AlmCode & 0x0F)
	{
	case 0x01:
		if(FencV->SerialConvType == SCONVTYPE_ENDAT_ABS)
		{	/* A.8A0 : ＦＰＧスケール異常 */
			ALMSetServoAlarm(AlmMngr, ALM_FPGFSCALE);
		}
		break;
	case 0x02:
		/* A.8A1 : ＦＰＧモジュール異常	*/
		ALMSetServoAlarm(AlmMngr, ALM_FPGMODULE);
		break;
	case 0x03:
		if(FencV->SerialConvType == SCONVTYPE_ENDAT_ABS)
		{	/* A.8A0 : ＦＰＧスケール異常 */
			ALMSetServoAlarm(AlmMngr, ALM_FPGFSCALE);
		}
		/* A.8A1 : ＦＰＧモジュール異常	*/
		ALMSetServoAlarm(AlmMngr, ALM_FPGMODULE);
		break;
	case 0x08:
		if(FencV->AbsoEncoder != FALSE)
		{	/* A.8A3 : ＦＰＧポジション異常(アブソ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGPOS);
		}
		else
		{	/* A.8A2 : ＦＰＧセンサ異常(インクレ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGSEN);
		}
		break;
	case 0x09:
		if(FencV->AbsoEncoder != FALSE)
		{
			if(FencV->SerialConvType == SCONVTYPE_ENDAT_ABS)
			{	/* A.8A0 : ＦＰＧスケール異常 */
				ALMSetServoAlarm(AlmMngr, ALM_FPGFSCALE);
			}
			/* A.8A3 : ＦＰＧポジション異常(アブソ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGPOS);
		}
		else
		{	 /* A.8A2 : ＦＰＧセンサ異常(インクレ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGSEN);
		}
		break;
	case 0x0A:
		/* A.8A1 : ＦＰＧモジュール異常 */
		ALMSetServoAlarm(AlmMngr, ALM_FPGMODULE);
		if(FencV->AbsoEncoder != FALSE)
		{	/* A.8A3 : ＦＰＧポジション異常(アブソ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGPOS);
		}
		else
		{	/* A.8A2 : ＦＰＧセンサ異常(インクレ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGSEN);
		}
		break;
	case 0x0B:
		/* A.8A1 : ＦＰＧモジュール異常	*/
		ALMSetServoAlarm(AlmMngr, ALM_FPGMODULE);
		if(FencV->AbsoEncoder != FALSE)
		{
			if(FencV->SerialConvType == SCONVTYPE_ENDAT_ABS)
			{	/* A.8A0 : ＦＰＧスケール異常 */
				ALMSetServoAlarm(AlmMngr, ALM_FPGFSCALE);
			}
			/* A.8A3 : ＦＰＧポジション異常(アブソ)	*/
			ALMSetServoAlarm(AlmMngr, ALM_FPGPOS);
		}
		else
		{	/* A.8A2 : ＦＰＧセンサ異常(インクレ) */
			ALMSetServoAlarm(AlmMngr, ALM_FPGSEN);
		}
		break;
	default:
		break; /* アラームなし	*/
	}

	/*----------------------------------------------------------------------*/
	/*		アラームコードチェック（BIT 4〜7）								*/
	/*----------------------------------------------------------------------*/
	if(0 != (AlmCode & 0x10))
	{	/* A.8A5 : ＦＰＧｵｰﾊﾞｽﾋﾟｰﾄﾞ異常 */
		ALMSetServoAlarm(AlmMngr, ALM_FPGOVSPD);
	}
	if(0 != (AlmCode & 0x20))
	{	/* A.8A6 : ＦＰＧｵｰﾊﾞﾋｰﾄ異常 */
		ALMSetServoAlarm(AlmMngr, ALM_FPGOVHEAT);
	}

	/*----------------------------------------------------------------------*/
	/*		モータ負荷位置間偏差過大チェック								*/
	/*----------------------------------------------------------------------*/
	if(FALSE != LpxCheckSemiFullPerrOverFlow(ChkFposErr, PosCtrlMode, MencPos, FencPos))
	{	/* A.D10 : モータ−負荷位置間偏差過大 */
		ALMSetServoAlarm(AlmMngr, ALM_FSOF);
	}

}


#endif	// (CSW_SVCF_FULC_MODE != CSW_FULC_NO_SUPPORT)



/***************************************** end of file **********************************************/
