/****************************************************************************
Description	: Vibration Frequency Analysis Module
----------------------------------------------------------------------------
Author        : Yaskawa Electric Corp., 
				Copyright (c) 2010 All Rights Reserved

Project       : INGRAM

----------------------------------------------------------------------------
Changes		:
Name   Date          Description
------------------------------------------------------------------------
Y.Oka  2010.11.16    created

*****************************************************************************/
#include "TuneLib.h"
#include "PnPrmListTbl.h"
#include "MLib.h"



/****************************************************************************************************/
/*																									*/
/*		Function Definition																			*/
/*																									*/
/****************************************************************************************************/
/* void		FftCalculateInitPrm( FFTANALYZE *FftAna );												*/
/* SHORT	FftAnalyzeExecute( FFTANALYZE *FftAna, SHORT *TraceData );								*/
/* void		FftSetAnaCondition( FFTANALYZE *FftAna, LONG SumpleNum, LONG AnaMaxFreq,				*/
/*															LONG AnaMinFreq, BOOL TuneLessSts );	*/
/* USHORT	FftGetAnaRsltVibmRf( FFTANALYZE *FftAna );												*/
/* void		FftSetForceAnaReq( FFTANALYZE *FftAna, BOOL Setting );									*/
/* BOOL		FftGetForceAnaReq( FFTANALYZE *FftAna );												*/
/****************************************************************************************************/
static	SHORT	fftAnalyzeCalc( 					/* 振動周波数解析メイン関数						*/
					FFTANALYZE *FftAna,					/* 振動周波数解析用データ					*/
					SHORT *TraceData, 					/* トレースデータ							*/
					LONG *fpeak ); 						/* 解析周波数								*/
static	void	fftClearPeakDatas( 					/* ピークデータクリア関数						*/
					FFTANALYZE *FftAna );				/* 振動周波数解析用データ					*/
static	void	fftSpectrumPeakDetect(				/* スペクトラムピーク周波数検出関数				*/
					FFTANALYZE *FftAna,					/* 振動周波数解析用データ					*/
					ULONG swork,						/* スペクトラム								*/
					ULONG freq );						/* 該当する周波数							*/
static	USHORT	fftSpectrumPeakCollect(				/* スペクトラムピーク周波数整理関数				*/
					FFTANALYZE *FftAna,					/* 振動周波数解析用データ					*/
					LONG *swork,						/* スペクトラムピーク積算値					*/
					UCHAR sw,							/* 積算計算処理切り替えスイッチ				*/
					LONG Fmax,							/* 解析最大周波数／周波数分割数				*/
					LONG Fmin );						/* 解析最小周波数／周波数分割数				*/
static	LONG	fftAddThta(							/* 位相増分計算関数								*/
					LONG thta_a,						/* 元位相									*/
					LONG thta_b,						/* 位相増分値								*/
					USHORT *sin_thta,					/* (元位相＋位相増分値)：SIN計算用			*/
					USHORT *cos_thta );					/* (元位相＋位相増分値＋π/2)：COS計算用	*/
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		振動周波数解析機能初期パラメータ計算関数													*/
/*																									*/
/****************************************************************************************************/
void	FftCalculateInitPrm( FFTANALYZE *FftAna, LONG SampleTimeUs )
{
	/*----------------------------------------------------------------------------------------------*/
	/*		振動解析合否判定スペクトル補正値 : FftAna->FftAnaPrm.Spectrumval						*/
	/*----------------------------------------------------------------------------------------------*/
//	KPI_DI();												/* Disable Interrupt					*/
	FftAna->FftAnaPrm.Spectrumval = ONFFT_OK_LMT;			/* [1倍]換算は内部						*/
	FftAna->FftAnaPrm.Spectrumval2 = ONFFT_OK_LMT2;			/* [1倍]換算は内部						*/
	FftAna->FftAnaPrm.SampleTime = SAMPLETIME(SampleTimeUs);
//	KPI_EI();												/* Enable Interrupt						*/

	return;
}



/****************************************************************************************************/
/*																									*/
/*		振動周波数解析メイン関数																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	FFTアルゴリズム（改良DFT）で周波数スペクトラムを求め、振動周波数解析を行う。			*/
/*																									*/
/*		arg			: *TraceData	トレースデータ													*/
/*					: Sno			データサンプル数												*/
/*					: Fmax_calc		解析最大周波数		[Hz]										*/
/*					: Fmin_calc		解析最小周波数		[Hz]										*/
/*		out			: rc			リターンコード		[OK or NG]									*/
/* 		g-out		: *fpeak		振動周波数解析値	[Hz]										*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/*																									*/
/****************************************************************************************************/
static	SHORT	fftAnalyzeCalc( FFTANALYZE *FftAna, SHORT *TraceData, LONG *fpeak )
{
	/*----------------------------------------------------------------------------------------------*/
	/*	ローカル変数定義																			*/
	/*----------------------------------------------------------------------------------------------*/
	USHORT	sft;
	USHORT	work1, work2;							/* ループカウンタ	ＤＦＴ一般式のｋとｎに相当	*/
	USHORT	thh1, thh2;								/* sinX、cosX演算用。1024 = 2π					*/
	USHORT	cnt;									/* まとめられたピーク数							*/
	LONG	Sno;									/* データサンプル数								*/
	LONG	Fmax_calc;								/* 解析最大周波数								*/
	LONG	Fmin_calc;								/* 解析最小周波数								*/
	LONG	Fdiv;									/* 周波数分解能									*/
	LONG	Fmax;									/* 解析最大周波数／周波数分割数					*/
	LONG	Fmin;									/* 解析最小周波数／周波数分割数					*/
	LONG	Sno_2;									/* 計算分割数（計算上のサンプル数）				*/

	LONG 	thta0, thtaw, thtaw2, dthta, thta;		/* 位相											*/
	LONG	rew, imw ,rew2, imw2;					/* A(k)～A(k+3)で使用するＤＦＴ計算共通項		*/
	LONG	res0, ims0;								/* A(k)の各ｋの実数部の積算値、虚数部の積算値	*/
	LONG	res1, res11, ims1, ims11;				/* A(k+1)の各ｋの実数部の積算値、虚数部の積算値	*/
	LONG	res2, ims2;								/* A(k+2)の各ｋの実数部の積算値、虚数部の積算値	*/
	LONG	res3, res31, ims3 ,ims31;				/* A(k+3)の各ｋの実数部の積算値、虚数部の積算値	*/
	LONG	res4, res5, res6, res7;					/* a(N/4)										*/
	LONG	ims4, ims5, ims6 ,ims7;

	LONG	x0;										/* A(k)～A(k+3)の実数部、虚数部の絶対値			*/
	LONG	smax;									/* A(k)～A(k+3)の実数部、虚数部の絶対値の最大値	*/
	ULONG	swork;									/* 各周波数のスペクトラム値						*/
	LONG	freq;									/* 検出周波数									*/
	LONG	swork2_32;								/* スペクトラム積算値ワーク						*/
	ULONG	swork_sum;								/* スペクトラム積算値							*/
	ULONG	swork_av;								/* スペクトラム平均値							*/
	LONG	s,wk;									/* 周波数検出合否判別での演算ライブラリ用ワーク	*/

	SHORT	rc;										/* リターンコード								*/
													/*	rc = 0  -> 正常終了、rc = -1 -> エラー終了	*/

	LONG	Sno_div2;								/* Sno/2		<V51E>							*/
	LONG	Sno_div4;								/* Sno/4		<V51E>							*/
	LONG	Sno_3div4;								/* Sno*3/4		<V51E>							*/

	/*----------------------------------------------------------------------------------------------*/
	/*	データ・変数の初期化																		*/
	/*----------------------------------------------------------------------------------------------*/
	Sno = FftAna->FftAnaPrm.SumpleNum;				/* データサンプル数								*/
	Fmax_calc = FftAna->FftAnaPrm.AnaMaxFreq;		/* 解析最大周波数								*/
	Fmin_calc = FftAna->FftAnaPrm.AnaMinFreq;		/* 解析最小周波数								*/
	fftClearPeakDatas( FftAna );					/* ピークデータクリア関数						*/
	cnt = 0;										/* まとめられたピーク個数クリア					*/
	swork_sum = 0;									/* スペクトル積算値クリア						*/
	smax = 0;										/* スペクトラム最大値クリア						*/
	rc = OK;										/* リターンコードを「正常終了」で初期化			*/

	/*----------------------------------------------------------------------------------------------*/
	/*	内部設定使用値の算出、設定																	*/
	/*----------------------------------------------------------------------------------------------*/
	Fdiv = FftAna->FftAnaPrm.SampleTime/Sno;		/* 周波数分解能	(1/データ取得周期/データ数)		*/
	Fmax = Fmax_calc/Fdiv;							/* 解析最大周波数 / 周波数分割数				*/
	Fmin = Fmin_calc/Fdiv;							/* 解析最小周波数 / 周波数分割数				*/
	Sno_2 = Sno*2;									/* 計算分割数（計算上のサンプル数）				*/
	Sno_div2 = Sno>>1;								/* FFT演算で使用する中間変数	Sno/2			*/
	Sno_div4 = Sno>>2;								/* FFT演算で使用する中間変数	Sno/4			*/
	Sno_3div4 = (Sno*3)>>2;							/* FFT演算で使用する中間変数	Sno*3/4			*/

	/*----------------------------------------------------------------------------------------------*/
	/*	異常設定状態検出																			*/
	/*  ①検出周波数の上限値が下限値以下[(Fmax-Fmin)<=0]の設定										*/
	/*	②解析最大周波数０以下[Fmax_calc<=0]、解析最小周波数０未満[Fmin_calc<0]						*/
	/*	上記状態時は異常設定としてリターンコードをＮＧに設定する。									*/
	/*	異常時の周波数解析値はPn409の上限値（5000Hz)を設定する										*/
	/*	(Pn409=5000Hz  ⇒  1段目ノッチフィルタ無効)													*/
	/*----------------------------------------------------------------------------------------------*/
	if( ((Fmax - Fmin) <= 0) || (Fmax_calc<=0) || (Fmin_calc<0) )
	{
		/* 異常設定時はリターンコードＮＧを返す */
		rc = NG;

		/* 異常設定時は周波数解析値に5000をセットする */
		fpeak[0] = pndef_ntchfil1.UpperLimit;
		fpeak[1] = fpeak[0];
		fpeak[2] = fpeak[0];
		return ( rc );
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	高速ＤＦＴ処理	Ａ（ｋ）の計算																*/
	/* 		work1は、１ループで４インクリメントされる。												*/
	/* 		上記以外にもwork1++を処理する箇所があるので注意！										*/
	/*----------------------------------------------------------------------------------------------*/
	for( work1= (USHORT)Fmin; work1 < (USHORT)Fmax; work1++ ) {

		/*------------------------------------------------------------------------------------------*/
		/*	２πｋ／Ｎの計算	thta0 = work1 * 1024 / SNO_2(sinXはX=1024=2πとなる)				*/
		/*------------------------------------------------------------------------------------------*/
		thta0= (work1 << 18) / Sno_2;				/* <<18は、後で >>8 するので					*/
													/* 結局、<<10 = 1024。sinXはX=1024=2πとなる	*/

		/*------------------------------------------------------------------------------------------*/
		/*	a(0)、a(N/2)算出																		*/
		/*	「<<2」は、精度向上のためのシフト														*/
		/*------------------------------------------------------------------------------------------*/
		/* k=n時 a(0)+a(N/2) */
		res0= ((SHORT)TraceData[0] + (SHORT)TraceData[Sno_div2]) << 2;
		/* k=n+1,n+3の時 a(0) */
		res1= res3= (SHORT)TraceData[0] << 2;
		/* k=n+2時 a(0)-a(N/2) */
		res2= ((SHORT)TraceData[0] - (SHORT)TraceData[Sno_div2]) << 2;
		/* k=n+1,n+3の時 j×a(N/2) */
		ims11= ims31= (SHORT)TraceData[Sno_div2] << 2;

		/*------------------------------------------------------------------------------------------*/
		/*	下記、「work2」ループ内変数の初期化														*/
		/*------------------------------------------------------------------------------------------*/
		thtaw = 0;									/* 2πnk / Nのクリア							*/
		res11= res31= 0;
		ims0= ims1= ims2= ims3= 0;

		/*------------------------------------------------------------------------------------------*/
		/*	Σａ(ｎ)×ｅｘｐ(-j2πnk/N)の計算を行なう。												*/
		/*	本ループ内では、a(1)～a(N-1)を計算。ただし、a(N/4)を除く								*/
		/*------------------------------------------------------------------------------------------*/
		for( work2= 1; work2 < Sno_div4; work2++ ) {
			/*--------------------------------------------------------------------------------------*/
			/*	2πk / Nの計算。位相の増分値	dtata = work2 * 1024 / Sno_2						*/
			/*--------------------------------------------------------------------------------------*/
			dthta=  (work2 << 18) / Sno_2;			/* <<18は、後で >>8 するので					*/
													/* 結局、<<10 = 1024。sinXはX=1024=2πとなる	*/

			/*--------------------------------------------------------------------------------------*/
			/*	DFT計算の共通項の計算																*/
			/* 		a(work2) + a(N-work2)															*/
			/* 		a(N/2+work2) + a(N/2-work2)														*/
			/* 		a(work2) - a(N-work2)															*/
			/* 		a(N/2+work2) - a(N/2-work2)														*/
			/*--------------------------------------------------------------------------------------*/
			rew= (SHORT)TraceData[work2] + (SHORT)TraceData[Sno - work2];
			rew2 = ((SHORT)TraceData[Sno_div2 + work2] + (SHORT)TraceData[Sno_div2 - work2]);
			imw= (SHORT)TraceData[work2] - (SHORT)TraceData[Sno - work2];
			imw2 = ((SHORT)TraceData[Sno_div2 + work2] - (SHORT)TraceData[Sno_div2 - work2]);

			/*--------------------------------------------------------------------------------------*/
			/*	Ａ(ｋ)計算																			*/
			/*		sinの出力が0～16384のため、「>>12」して値が大きくならないようにしている			*/
			/*--------------------------------------------------------------------------------------*/
			thtaw = fftAddThta( thta0, thtaw, &thh1, &thh2 );		/* thtaw += thta0 				*/

			res0 += (((SHORT)(rew + rew2) * MlibFASTSINS16(thh2)) >> 12);
			ims0 += (((SHORT)(imw + imw2) * MlibFASTSINS16(thh1)) >> 12);

			/*--------------------------------------------------------------------------------------*/
			/*	Ａ(ｋ＋１)計算																		*/
			/*		sinの出力が0～16384のため、「>>12」して値が大きくならないようにしている			*/
			/*--------------------------------------------------------------------------------------*/
			thtaw2 = fftAddThta( dthta, thtaw, &thh1, &thh2 );		/* thtaw2 = thtaw + dthta		*/

			res1 += (((SHORT)imw * MlibFASTSINS16(thh2)) >> 12);
			ims1 += (((SHORT)rew * MlibFASTSINS16(thh1)) >> 12);
			res11 += (((SHORT)imw2 * MlibFASTSINS16(thh1)) >> 12);
			ims11 += (((SHORT)rew2 * MlibFASTSINS16(thh2)) >> 12);

			/*--------------------------------------------------------------------------------------*/
			/*	Ａ(ｋ＋２)計算																		*/
			/*		sinの出力が0～16384のため、「>>12」して値が大きくならないようにしている			*/
			/*--------------------------------------------------------------------------------------*/
			thtaw2 = fftAddThta( dthta, thtaw2, &thh1, &thh2 );		/* thtaw2 = thtaw2 + dthta		*/

			res2 += (((SHORT)(rew - rew2) * MlibFASTSINS16(thh2)) >> 12);
			ims2 += (((SHORT)(imw - imw2) * MlibFASTSINS16(thh1)) >> 12);

			/*--------------------------------------------------------------------------------------*/
			/*	Ａ(ｋ＋３)計算																		*/
			/*		sinの出力が0～16384のため、「>>12」して値が大きくならないようにしている			*/
			/*--------------------------------------------------------------------------------------*/
			thtaw2 = fftAddThta( dthta, thtaw2, &thh1, &thh2 );		/* thtaw2 = thtaw2 + dthta		*/

			res3 += (((SHORT)imw * MlibFASTSINS16(thh2)) >> 12);
			ims3 += (((SHORT)rew * MlibFASTSINS16(thh1)) >> 12);
			res31 += (((SHORT)imw2 * MlibFASTSINS16(thh1)) >> 12);
			ims31 += (((SHORT)rew2 * MlibFASTSINS16(thh2)) >> 12);

		}

		/*------------------------------------------------------------------------------------------*/
		/*	a(N/4)算出																				*/
		/*		Snoが４で割り切れない場合の対策として、ここで計算する。これがないと計算誤差が出る	*/
		/*		sinの出力が0～16384のため、「>>12」して値が大きくならないようにしている				*/
		/*------------------------------------------------------------------------------------------*/
		rew= (SHORT)TraceData[Sno_div4] + (SHORT)TraceData[Sno_3div4];
		imw= (SHORT)TraceData[Sno_div4] - (SHORT)TraceData[Sno_3div4];

		thta= work1 << 7;										/* π/4 × work1 					*/
																/* 2π×(Sno/4)/Sno_2=π/4 -> 128	*/
		thta = fftAddThta( thta, 0, &thh1, &thh2 );				/* thta = thta + 0					*/
		res4 = (((SHORT)rew * MlibFASTSINS16(thh2)) >> 12);		/* sin(thh2) = cos(thh)				*/
		ims4 = (((SHORT)imw * MlibFASTSINS16(thh1)) >> 12);
		res6 = (((SHORT)rew * MlibFASTSINS16(thh1)) >> 12);
		ims6 = (((SHORT)imw * MlibFASTSINS16(thh2)) >> 12);

		thta = fftAddThta( thta, 128, &thh1, &thh2 );			/* thta = thta + π/4				*/
		res5 = (((SHORT)imw * MlibFASTSINS16(thh2)) >> 12);
		ims5 = (((SHORT)rew * MlibFASTSINS16(thh1)) >> 12);
		res7 = (((SHORT)imw * MlibFASTSINS16(thh1)) >> 12);
		ims7 = (((SHORT)rew * MlibFASTSINS16(thh2)) >> 12);

		/*------------------------------------------------------------------------------------------*/
		/*	実数部、虚数部の計算																	*/
		/*		Ａ（ｋ）～Ａ（ｋ＋３）の実数部と虚数部の計算を行う。								*/
		/*		絶対値を演算して最大値を保存。後でスペクトラム値の計算時に正規化の基準に使用する。	*/
		/*------------------------------------------------------------------------------------------*/
		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ)の実数部																			*/
		/*------------------------------------------------------------------------------------------*/
		FftAna->var.Reals[work1]= res0 + res4;
		x0 = MlibAbs32(FftAna->var.Reals[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ)の虚数部																			*/
		/*------------------------------------------------------------------------------------------*/
		FftAna->var.Images[work1]= ims0 + ims4;
		x0 = MlibAbs32(FftAna->var.Images[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋１)の実数部																		*/
		/*------------------------------------------------------------------------------------------*/
		work1 ++;												/* work1 インクリメント				*/
		FftAna->var.Reals[work1]= res1 - res11 + res5;
		x0 = MlibAbs32(FftAna->var.Reals[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋１)の虚数部																		*/
		/*------------------------------------------------------------------------------------------*/
		FftAna->var.Images[work1]= ims1 + ims11 + ims5;
		x0 = MlibAbs32(FftAna->var.Images[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋２)の実数部																		*/
		/*------------------------------------------------------------------------------------------*/
		work1 ++;												/* work1 インクリメント				*/
		FftAna->var.Reals[work1]= res2 - res6;
		x0 = MlibAbs32(FftAna->var.Reals[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋２)の虚数部																		*/
		/*------------------------------------------------------------------------------------------*/
		FftAna->var.Images[work1]= ims2 + ims6;
		x0 = MlibAbs32(FftAna->var.Images[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋３)の実数部																		*/
		/*------------------------------------------------------------------------------------------*/
		work1 ++;												/* work1 インクリメント				*/
		FftAna->var.Reals[work1]= res3 + res31 - res7;
		x0 = MlibAbs32(FftAna->var.Reals[work1]);
		if( x0 > smax ) smax = x0;

		/*------------------------------------------------------------------------------------------*/
		/*	Ａ(ｋ＋３)の虚数部																		*/
		/*------------------------------------------------------------------------------------------*/
		FftAna->var.Images[work1]= ims3 - ims31 + ims7;
		x0 = MlibAbs32(FftAna->var.Images[work1]);
		if( x0 > smax ) smax = x0;
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	正規化処理																					*/
	/*----------------------------------------------------------------------------------------------*/
	sft = (USHORT)(smax / REGULAR_SFT);							/* 16384で正規化					*/

	/*----------------------------------------------------------------------------------------------*/
	/*	スペクトラム解析（｜Re｜^2＋｜Im｜^2）														*/
	/*----------------------------------------------------------------------------------------------*/
	for( work1= (USHORT)Fmin; work1 < (USHORT)Fmax; work1++ ) {	
		/*------------------------------------------------------------------------------------------*/
		/*	スペクトラム算出																		*/
		/*------------------------------------------------------------------------------------------*/
		if(sft == 0){
			swork = FftAna->var.Reals[work1] * FftAna->var.Reals[work1] ;
			swork += FftAna->var.Images[work1] * FftAna->var.Images[work1] ;
			sft = 1;
		}
		else{
			swork = (FftAna->var.Reals[work1] / sft) * (FftAna->var.Reals[work1] / sft);
			swork += ((FftAna->var.Images[work1] / sft) * (FftAna->var.Images[work1] / sft));
		}
		/*------------------------------------------------------------------------------------------*/
		/*	周波数算出																				*/
		/*------------------------------------------------------------------------------------------*/
		freq = (LONG)work1 * Fdiv;				

		/*------------------------------------------------------------------------------------------*/
		/*	スペクトラムピーク値検出																*/
		/*		上位５番目までのピーク値と周波数を保持する											*/
		/*------------------------------------------------------------------------------------------*/
		fftSpectrumPeakDetect( FftAna, swork, freq );			/* スペクトラムピーク検出			*/

		/*------------------------------------------------------------------------------------------*/
		/*	スペクトラムピーク値整理																*/
		/*		解析の中間周波数まできたら、一旦、近い周波数をまとめる。							*/
		/*		ピーク値は上位３番までにまとめる													*/
		/*------------------------------------------------------------------------------------------*/
		if( work1 == (Fmax>>1) )
		{
			/* 検出周波数整理 */
			cnt = fftSpectrumPeakCollect( FftAna, &swork2_32, 0, Fmax, Fmin );
			/* 平均値計算から、まとめられた周波数のスペクトルを省く*/
			swork_sum -= swork2_32;
		}
		/* (Fmax-Fmin)による除算はオーバーフロー対策と平均値算出のため */
		swork_sum += (swork / (Fmax - Fmin));
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	スペクトラムピーク値整理（ピーク値のうち近い周波数をまとめる）								*/
	/*----------------------------------------------------------------------------------------------*/
	/* 検出周波数整理 */
	cnt += fftSpectrumPeakCollect( FftAna,&swork2_32, 0, Fmax, Fmin );
	/* 平均値計算から、ピークスペクトル全てを省く */
	swork_sum -= swork2_32;
	
	/*----------------------------------------------------------------------------------------------*/
	/*	周波数検出合否判別																			*/
	/*		以下の条件を満たす場合周波数検出失敗とする												*/
	/*			・ピーク周波数が検出周波数下限値(MINIMAM_FREQ[Hz])以下の場合						*/
	/*			・スペクトルピーク(smax)が下限値(MINIMAM_SPECTRUM)以下の場合						*/
	/*			・検出周波数のスペクトル値がスペクトル平均値のPn464[%]より小さい					*/
	/*----------------------------------------------------------------------------------------------*/
	if((smax <= MINIMAM_SPECTRUM))
	{
		rc = NG;
	}
	/*----------------------------------------------------------------------------------------------*/
	/* スペクトルピークと平均値との比較																*/
	/* 		本来平均値は 積算値をﾙｰﾌﾟ回数で除算する必要があるが、swork_sumはループ回数(Fmax - Fmin)	*/
	/*		で除算したものを積算しているため、swork_sum自体が平均値となる。							*/
	/* 		ただし、検出周波数整理処理でまとめられたｽﾍﾟｸﾄﾙ数を考慮すると平均値は下式のようになる	*/
	/*		平均値 = swork_sum * (Fmax - Fmin) / (Fmax - Fmin - cnt)								*/
	/*----------------------------------------------------------------------------------------------*/
	s = 0;
	wk =MlibScalKxgain( (Fmax - Fmin), 1 , (Fmax - Fmin - cnt), &s, 24 );
#if (FLOAT_USE==TRUE)
	swork_av = (ULONG)( swork_sum * wk );
#else
	swork_av = (ULONG)MlibMulgain( swork_sum, wk );
#endif /* FLOAT_USE */

	if((swork_av * FftAna->FftAnaPrm.Spectrumval) > FftAna->var.swork_max[0])
	{ /* エラー終了 */
		rc = NG;
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	調整レスオンライン自動ノッチ用周波数検出合否判定											*/
	/*----------------------------------------------------------------------------------------------*/
	if( (FftAna->FftAnaPrm.TuneLessSts == TRUE) && (FftAna->FftAnaPrm.ActiveFFtOn == FALSE) )
	{ /* 調整レスオンライン自動ノッチ設定の場合 */
		if( (smax <= MINIMAM_SPECTRUM2) )
		{ /* スペクトルピーク以下 */
			/* エラー終了 */
			rc = NG;
		}

		if( (swork_av * FftAna->FftAnaPrm.Spectrumval2) > FftAna->var.swork_max[0] )
		{ /* ピーク周波数が規定倍率以下 */
			/* エラー終了 */
			rc = NG;
		}
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	平均値と比較して検出周波数を再設定															*/
	/*----------------------------------------------------------------------------------------------*/
	if( (swork_av * FftAna->FftAnaPrm.Spectrumval) > FftAna->var.swork_max[0] )
	{
		FftAna->var.freq_max[0] = 0;
		FftAna->var.swork_max[0] = 0;
	}
	if( (swork_av * FftAna->FftAnaPrm.Spectrumval) > FftAna->var.swork_max[1] )
	{
		FftAna->var.freq_max[1] = 0;
		FftAna->var.swork_max[1] = 0;
	}
	if( (swork_av * FftAna->FftAnaPrm.Spectrumval) > FftAna->var.swork_max[2] )
	{
		FftAna->var.freq_max[2] = 0;
		FftAna->var.swork_max[2] = 0;
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	検出周波数を設定																			*/
	/*----------------------------------------------------------------------------------------------*/
	fpeak[0] = FftAna->var.freq_max[0];
	fpeak[1] = FftAna->var.freq_max[1];
	fpeak[2] = FftAna->var.freq_max[2];

	return(rc);
}



/****************************************************************************************************/
/*																									*/
/*		ピークデータクリア関数																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	ピークスペクトラムとそのスペクトラムの周波数変数の初期化								*/
/*																									*/
/*		arg			: なし																			*/
/*		out			: なし																			*/
/* 		g-out		: なし																			*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/****************************************************************************************************/
static	void	fftClearPeakDatas( FFTANALYZE *FftAna )
{
	MlibResetLongMemory( &(FftAna->var), sizeof(FftAna->var)>>2 );

	/* スペクトル最小値の初期値設定 */
	FftAna->var.swork_min = 0xFFFFFFFF;
	return;
}



/****************************************************************************************************/
/*																									*/
/*		スペクトラムピーク周波数検出関数															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	上位５番目までのスペクトラムピークとそのスペクトラムの周波数を検出する					*/
/*																									*/
/*		arg			: swork		スペクトラム値														*/
/*					: freq		スペクトラムに該当する周波数										*/
/*		out			: なし																			*/
/* 		g-out		: FftAna->var.swork_max[PEAK_DETECT_NUM]	スペクトラムピークデータ			*/
/*					: FftAna->var.freq_max[PEAK_DETECT_NUM]		周波数ピークデータ					*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/****************************************************************************************************/
static	void	fftSpectrumPeakDetect( FFTANALYZE *FftAna, ULONG swork, ULONG freq )
{
	UCHAR	i;

	/*----------------------------------------------------------------------------------------------*/
	/*	最大スペクトラムピーク値検出																*/
	/*		→上位１番目から５番目までを更新														*/
	/*----------------------------------------------------------------------------------------------*/
	if( swork > FftAna->var.swork_max[0] )
	{
		for(i = 4; i > 0; i--)
		{
			FftAna->var.swork_max[i] = FftAna->var.swork_max[i-1];
			FftAna->var.freq_max[i] = FftAna->var.freq_max[i-1];
		}
		FftAna->var.swork_max[0] = swork;
		FftAna->var.freq_max[0] = freq;
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	第２位スペクトラムピーク値検出																*/
	/*		→上位２番目から５番目までを更新														*/
	/*----------------------------------------------------------------------------------------------*/
	else if( swork > FftAna->var.swork_max[1] )
	{
		for(i = 4; i > 1; i--)
		{
			FftAna->var.swork_max[i] = FftAna->var.swork_max[i-1];
			FftAna->var.freq_max[i] = FftAna->var.freq_max[i-1];
		}
		FftAna->var.swork_max[1] = swork;
		FftAna->var.freq_max[1] = freq;
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	第３位スペクトラムピーク値検出																*/
	/*		→上位３番目から５番目までを更新														*/
	/*----------------------------------------------------------------------------------------------*/
	else if( swork > FftAna->var.swork_max[2] )
	{
		for(i = 4; i > 2; i--)
		{
			FftAna->var.swork_max[i] = FftAna->var.swork_max[i-1];
			FftAna->var.freq_max[i] = FftAna->var.freq_max[i-1];
		}
		FftAna->var.swork_max[2]= swork;
		FftAna->var.freq_max[2]= freq;
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	第４位スペクトラムピーク値検出																*/
	/*		→上位４番目と５番目を更新																*/
	/*----------------------------------------------------------------------------------------------*/
	else if( swork > FftAna->var.swork_max[3] )
	{
		FftAna->var.swork_max[4] = FftAna->var.swork_max[3];
		FftAna->var.swork_max[3] = swork;
		FftAna->var.freq_max[4] = FftAna->var.freq_max[3];
		FftAna->var.freq_max[3] = freq;
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	第５位スペクトラムピーク値検出																*/
	/*		→５番目を更新																			*/
	/*----------------------------------------------------------------------------------------------*/
	else if( swork > FftAna->var.swork_max[4] )
	{
		FftAna->var.swork_max[4] = swork;
		FftAna->var.freq_max[4] = freq;
	}

	/*----------------------------------------------------------------------------------------------*/
	/*	スペクトラム最小値検出																		*/
	/*----------------------------------------------------------------------------------------------*/
	if( swork < FftAna->var.swork_min )
	{
		FftAna->var.swork_min = swork;
		FftAna->var.freq_min = freq;
	}
}



/****************************************************************************************************/
/*																									*/
/*		スペクトラムピーク周波数整理関数															*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	上位５番目までのスペクトラムピークの中で、±１００[Hz]内のピークスペクトラムを			*/
/*			スペクトラムが大きい周波数に統合し、上位３つまでにまとめる								*/
/*			第４、５位の周波数、およびスペクトラムは、ゼロクリアする								*/
/*		 	また、第１～５位までのスペクトルに対し、本関数処理前後でのスペクトルの積算値を求める	*/
/*			（スペクトル平均値計算で使用）															*/
/*																									*/
/*		arg			: *swork	スペクトラムピーク積算値(sw値で算出結果が異なる)					*/
/*					: sw		積算計算処理切り替えスイッチ										*/
/*									＝０：*swork＝まとめ前後でのピークスペクトルの積算値の差		*/
/*									≠０：*swork＝まとめ前のピークスペクトルの積算値				*/
/*		out			: cnt		まとめられたピーク数												*/
/* 		g-out		: FftAna->var.swork_max[PEAK_DETECT_NUM]	スペクトラムピークデータ			*/
/*					: FftAna->var.freq_max[PEAK_DETECT_NUM]		周波数ピークデータ					*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/****************************************************************************************************/
static	USHORT	fftSpectrumPeakCollect( FFTANALYZE *FftAna, LONG *swork32, UCHAR sw, LONG Fmax, LONG Fmin )
{
	USHORT	i;
	USHORT	cnt;

	/*----------------------------------------------------------------------------------------------*/
	/*	変数の初期化																				*/
	/*----------------------------------------------------------------------------------------------*/
	cnt = 0;												/* スペクトルピーク数カウンタクリア		*/
	*swork32 = 0;											/* スペクトルピーク積算値				*/
	/*----------------------------------------------------------------------------------------------*/
	/*	ピーク周波数のスペクトラムを積算															*/
	/*		平均化およびオーバーフロー対策として積算値を(Fmax - Fmin)で除算する						*/
	/*----------------------------------------------------------------------------------------------*/
	for(i = 0; i < PEAK_DETECT_NUM; i ++)
	{
		if( FftAna->var.swork_max[i] != 0 )
		{ /* スペクトルピーク有り */
			cnt++;
			*swork32 += FftAna->var.swork_max[i] / (Fmax - Fmin);
		}
	}

	/************************************************************************************************/
	/*	FftAna->var.freq_max[1]をチェック															*/
	/************************************************************************************************/
	/*----------------------------------------------------------------------------------------------*/
	/* 		FftAna->var.freq_max[0] と FftAna->var.freq_max[1] 差が100[Hz]未満 						*/
	/*			→ FftAna->var.freq_max[1]をクリア													*/
	/*----------------------------------------------------------------------------------------------*/
	if( MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[1]) < 100 )
	{
		FftAna->var.swork_max[1]= 0;
		FftAna->var.freq_max[1]= 0;
	}
	
	/************************************************************************************************/
	/*	FftAna->var.freq_max[2]をチェック															*/
	/************************************************************************************************/
	/*----------------------------------------------------------------------------------------------*/
	/* 		FftAna->var.freq_max[1]がまとめられていない												*/
	/*----------------------------------------------------------------------------------------------*/
	if( FftAna->var.freq_max[1] != 0 )
	 {
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[2]とFftAna->var.freq_max[0]およびFftAna->var.freq_max[1]			*/
		/*		のいずれかの差が100[Hz]未満	→ FftAna->var.freq_max[2]をクリア						*/
		/*------------------------------------------------------------------------------------------*/
		if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[2]) < 100) 
			|| (MlibAbs32(FftAna->var.freq_max[1] - FftAna->var.freq_max[2]) < 100) )
		{
			FftAna->var.swork_max[2]= 0;
			FftAna->var.freq_max[2]= 0;
		}
	}
	/*----------------------------------------------------------------------------------------------*/
	/* 		FftAna->var.freq_max[1]がまとめられた													*/
	/*----------------------------------------------------------------------------------------------*/
	else
	{
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[2] とFftAna->var.freq_max[0]の差が100[Hz]未満 						*/
		/*		→ FftAna->var.freq_max[2]をクリア													*/
		/*------------------------------------------------------------------------------------------*/
		if( MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[2]) < 100 )
		{
			FftAna->var.swork_max[2]= 0;
			FftAna->var.freq_max[2]= 0;
		}
	}

	/************************************************************************************************/
	/*	FftAna->var.freq_max[3]、[4]をチェック														*/
	/************************************************************************************************/
	/*----------------------------------------------------------------------------------------------*/
	/* 		FftAna->var.freq_max[1]がまとめられていない												*/
	/*----------------------------------------------------------------------------------------------*/
	if( FftAna->var.freq_max[1] != 0 )
	{
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[2]がまとめられていない												*/
		/*		→ FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[3],[4]をクリア	*/
		/*------------------------------------------------------------------------------------------*/
		if( FftAna->var.freq_max[2] != 0 )
		{
			FftAna->var.swork_max[3]= 0;
			FftAna->var.swork_max[4]= 0;
			FftAna->var.freq_max[3]= 0;
			FftAna->var.freq_max[4]= 0;
		}
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[1] != 0, FftAna->var.freq_max[2]= 0								*/
		/*		→ FftAna->var.freq_max[2]が未確定													*/
		/*------------------------------------------------------------------------------------------*/
		else
		{
			/*--------------------------------------------------------------------------------------*/
			/* 	FftAna->var.freq_max[3]とFftAna->var.freq_max[0]または								*/
			/*											FftAna->var.freq_max[1]の差が100[Hz]未満 	*/
			/*		→ FftAna->var.freq_max[3]をクリア												*/
			/*--------------------------------------------------------------------------------------*/
			if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[3]) < 100) 
				|| (MlibAbs32(FftAna->var.freq_max[1] - FftAna->var.freq_max[3]) < 100) )
			{	
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				/*----------------------------------------------------------------------------------*/
				/* 	FftAna->var.freq_max[4]とFftAna->var.freq_max[0]、FftAna->var.freq_max[1]の差が	*/
				/*		100[Hz]より大きい → FftAna->var.freq_max[4]をFftAna->var.freq_max[2]とする	*/
				/*----------------------------------------------------------------------------------*/
				if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[4]) > 100) 
					&& (MlibAbs32(FftAna->var.freq_max[1] - FftAna->var.freq_max[4]) > 100) )
				{
					FftAna->var.swork_max[2]= FftAna->var.swork_max[4];
					FftAna->var.freq_max[2]= FftAna->var.freq_max[4];
				}
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[4]をクリア		*/
				/*	（FftAna->var.freq_max[3]は既にクリアされている）								*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
			/*--------------------------------------------------------------------------------------*/
			/* FftAna->var.freq_max[3] をFftAna->var.freq_max[2]とする 								*/
			/*--------------------------------------------------------------------------------------*/
			else
			{
				FftAna->var.swork_max[2]= FftAna->var.swork_max[3];
				FftAna->var.freq_max[2]= FftAna->var.freq_max[3];
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[3]、[4]をクリア	*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
		}
	}

	/*----------------------------------------------------------------------------------------------*/
	/* 		FftAna->var.freq_max[1]がまとめられた													*/
	/*----------------------------------------------------------------------------------------------*/
	else
	{
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[2]がまとめられていない												*/
		/*  	→ FftAna->var.freq_max[2]をFftAna->var.freq_max[1]とする							*/
		/*------------------------------------------------------------------------------------------*/
		if( FftAna->var.freq_max[2] != 0 )
		{
			FftAna->var.swork_max[1]= FftAna->var.swork_max[2];
			FftAna->var.freq_max[1]= FftAna->var.freq_max[2];
			/*--------------------------------------------------------------------------------------*/
			/* 	FftAna->var.freq_max[3]とFftAna->var.freq_max[0]または								*/
			/*											FftAna->var.freq_max[2]との差が100[Hz]未満	*/
			/*		→ FftAna->var.freq_max[3]をクリア												*/
			/*--------------------------------------------------------------------------------------*/
			if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[3]) < 100) 
				|| (MlibAbs32(FftAna->var.freq_max[2] - FftAna->var.freq_max[3]) < 100) )
			{
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				/*----------------------------------------------------------------------------------*/
				/* 	FftAna->var.freq_max[4]とFftAna->var.freq_max[0]または							*/
				/*										FftAna->var.freq_max[2]との差が100[Hz]未満	*/
				/*		→ FftAna->var.freq_max[4]をクリア											*/
				/*		   FftAna->var.freq_max[3],[4]ともまとめられたため、FftAna->var.freq_max[2]	*/
				/*		   もクリア																	*/
				/*----------------------------------------------------------------------------------*/
				if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[4]) < 100) 
					|| (MlibAbs32(FftAna->var.freq_max[2] - FftAna->var.freq_max[4]) < 100) )
				{
					FftAna->var.swork_max[2]= 0;
					FftAna->var.freq_max[2]= 0;
				}
				/*----------------------------------------------------------------------------------*/
				/* 	FftAna->var.freq_max[4] をFftAna->var.freq_max[2]とする 						*/
				/*----------------------------------------------------------------------------------*/
				else
				{
					FftAna->var.swork_max[2]= FftAna->var.swork_max[4];
					FftAna->var.freq_max[2]= FftAna->var.freq_max[4];
				}
				/*----------------------------------------------------------------------------------*/
				/* 	FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[4]をクリア		*/
				/*		（FftAna->var.freq_max[3]は既にクリアされている）							*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
			/*--------------------------------------------------------------------------------------*/
			/* 	FftAna->var.freq_max[3] をFftAna->var.freq_max[2]とする 							*/
			/*--------------------------------------------------------------------------------------*/
			else
			{
				FftAna->var.swork_max[2]= FftAna->var.swork_max[3];
				FftAna->var.freq_max[2]= FftAna->var.freq_max[3];
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[3]、[4]クリア	*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
		}
		/*------------------------------------------------------------------------------------------*/
		/* 	FftAna->var.freq_max[1]、[2]がまとめられた場合											*/
		/*------------------------------------------------------------------------------------------*/
		else
		{
			/*--------------------------------------------------------------------------------------*/
			/* 	FftAna->var.freq_max[3]とFftAna->var.freq_max[0]との差が100[Hz]未満					*/
			/*			→ FftAna->var.freq_max[3]をクリア											*/
			/*--------------------------------------------------------------------------------------*/
			if( MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[3]) < 100 )
			{
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				/*----------------------------------------------------------------------------------*/
				/* 	FftAna->var.freq_max[4]とFftAna->var.freq_max[0]との差が100[Hz]より大きい		*/
				/*			→ FftAna->var.freq_max[4]をFftAna->var.freq_max[1]とする				*/
				/*----------------------------------------------------------------------------------*/
				if( MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[4]) > 100 )
				{
					FftAna->var.swork_max[1]= FftAna->var.swork_max[4];
					FftAna->var.freq_max[1]= FftAna->var.freq_max[4];
				}
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[0],[1]まで確定したのでFftAna->var.freq_max[4]をクリア		*/
				/*		（FftAna->var.freq_max[2],[3]は既にクリアされている）						*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
			/*--------------------------------------------------------------------------------------*/
			/* FftAna->var.freq_max[1]、[2]がまとめられているが、FftAna->var.freq_max[3]が			*/
			/*																	まとめられていない	*/
			/*			→ FftAna->var.freq_max[3] をFftAna->var.freq_max[1]とする 					*/
			/*--------------------------------------------------------------------------------------*/
			else
			{
				FftAna->var.swork_max[1]= FftAna->var.swork_max[3];
				FftAna->var.freq_max[1]= FftAna->var.freq_max[3];
				FftAna->var.swork_max[3]= 0;
				FftAna->var.freq_max[3]= 0;
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[4]とFftAna->var.freq_max[0]、FftAna->var.freq_max[1]との	*/
				/*															差が100[Hz]より大きい	*/
				/*			→ FftAna->var.freq_max[4]をFftAna->var.freq_max[2]とする				*/
				/*----------------------------------------------------------------------------------*/
				if( (MlibAbs32(FftAna->var.freq_max[0] - FftAna->var.freq_max[4]) > 100) 
					&& (MlibAbs32(FftAna->var.freq_max[1] - FftAna->var.freq_max[4]) > 100) )
				{
					FftAna->var.swork_max[2]= FftAna->var.swork_max[4];
					FftAna->var.freq_max[2]= FftAna->var.freq_max[4];
				}
				/*----------------------------------------------------------------------------------*/
				/* FftAna->var.freq_max[0]～[2]まで確定したのでFftAna->var.freq_max[4]をクリア		*/
				/*		（FftAna->var.freq_max[3]は既にクリアされている）							*/
				/*----------------------------------------------------------------------------------*/
				FftAna->var.swork_max[4]= 0;
				FftAna->var.freq_max[4]= 0;
			}
		}
	}
	/*----------------------------------------------------------------------------------------------*/
	/*	検出周波数をまとめた後のピーク周波数のスペクトラムを減算									*/
	/* 	 	→	検出周波数をまとめる前後でのｽﾍﾟｸﾄﾙﾋﾟｰｸの差											*/
	/*	 	→	まとめられた周波数のｽﾍﾟｸﾄﾙ積算値													*/
	/* 	また、 まとめられたピークの数を検出する														*/
	/*		平均化(Fmax - Fmin)で除算する															*/
	/*----------------------------------------------------------------------------------------------*/
	if( sw == 0 )										/* まとめ前後でのピークスペクトル積算値の差	*/
	{
		for(i = 0; i < 5; i ++)
		{
			if( FftAna->var.swork_max[i] != 0 )
			{ /* スペクトルピーク有り */
				cnt--;
				*swork32 -= FftAna->var.swork_max[i] / (Fmax - Fmin);
			}
		}
	}
	return( cnt );
}



/****************************************************************************************************/
/*																									*/
/*		位相計算用関数	 																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	FFT計算に使用する位相増分値の計算を行う。												*/
/*			thta1[deg]	= thta_a＋thta_b															*/
/*			thta2[deg]	= thta1[deg] + 90[deg]	(1024 = 2π)										*/
/*																									*/
/*		arg			: thta_a	元位相	  ：thta(0～2π -> 0～262144に正規化)						*/
/*					: thta_b	位相増分値：thta(0～2π -> 0～262144に正規化)						*/
/*					: *sin_thta	(元位相＋位相増分値＋π/4)：thta(0～2π -> 0～1024に正規化)			*/
/*					: *cos_thta	(元位相＋位相増分値＋π/4＋π/2)：thta(0～2π -> 0～1024に正規化)	*/
/*		out			: thta_c	元位相＋位相増分値：thta(0～2π -> 0～262144に正規化)				*/
/* 		g-out		: なし																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/****************************************************************************************************/
static	LONG	fftAddThta( LONG thta_a, LONG thta_b, USHORT *sin_thta_c, USHORT *cos_thta_c )
{
	LONG	thta1, thta2;
	LONG	thta_c;

	/*----------------------------------------------------------------------------------------------*/
	/*	元位相＋位相増分値	thta(0～2π -> 0～262144正規化)											*/
	/*----------------------------------------------------------------------------------------------*/
	thta_c = thta_a + thta_b;

	thta1 = (thta_c +128) >> 8;								/* >>8により、thta->1024=2πの正規化	*/
	*sin_thta_c = (USHORT)thta1;

	thta2 = (thta1 + 256);									/* thta1+256 -> 90deg進める				*/
	*cos_thta_c = (USHORT)thta2;

	return( thta_c );
}



/****************************************************************************************************/
/*																									*/
/*		振動周波数解析メイン関数																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*	機能：	FFTアルゴリズム（改良DFT）で周波数スペクトラムを求め、振動周波数解析を行う。			*/
/*																									*/
/*		arg			: *TraceData	トレースデータ													*/
/*					: Sno			データサンプル数												*/
/*					: Fmax_calc		解析最大周波数		[Hz]										*/
/*					: Fmin_calc		解析最小周波数		[Hz]										*/
/*		out			: rc			リターンコード		[OK or NG]									*/
/* 		g-out		: *ResSet		共振周波数解析値	[Hz/-]										*/
/*					: *AntSet		反共振周波数解析値	[Hz/-]										*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		Ver.1.00 : 2004.02.02  K.Inoki	 															*/
/*																									*/
/*																									*/
/****************************************************************************************************/
SHORT	FftAnalyzeExecute( FFTANALYZE *FftAna, SHORT *TraceData )
{
	LONG	fpeak[3];
	LONG	Fmax_calc;
	LONG	Fmin_calc;
	FRQANA	*ResSet;
	FRQANA	*AntSet;
	SHORT	rc;

	Fmax_calc = FftAna->FftAnaPrm.AnaMaxFreq;
	Fmin_calc = FftAna->FftAnaPrm.AnaMinFreq;
	ResSet = &(FftAna->FftAnaRslt.VibmRf[0]);
	AntSet = &(FftAna->FftAnaRslt.VibmAf);

	/* 振動周波数解析処理 */
	rc = fftAnalyzeCalc( FftAna, TraceData, fpeak );

	if( ((USHORT)FftAna->var.freq_max[0] <= Fmin_calc) || ((USHORT)FftAna->var.freq_max[0] > Fmax_calc) )
	{
		ResSet->Freq = 0;
		ResSet->Amp  = 0;
	}
	else
	{
		ResSet->Freq = (USHORT)FftAna->var.freq_max[0];
		ResSet->Amp  = (USHORT)FftAna->var.swork_max[0];
	}

	if( ((USHORT)FftAna->var.freq_max[1] <= Fmin_calc) || ((USHORT)FftAna->var.freq_max[1] > Fmax_calc) )
	{
		(ResSet+1)->Freq = 0;
		(ResSet+1)->Amp  = 0;
	}
	else
	{
		(ResSet+1)->Freq = (USHORT)FftAna->var.freq_max[1];
		(ResSet+1)->Amp  = (USHORT)FftAna->var.swork_max[1];
	}

	if( ((USHORT)FftAna->var.freq_max[2] <= Fmin_calc) || ((USHORT)FftAna->var.freq_max[2] > Fmax_calc) )
	{
		(ResSet+2)->Freq = 0;
		(ResSet+2)->Amp  = 0;
	}
	else
	{
		(ResSet+2)->Freq = (USHORT)FftAna->var.freq_max[2];
		(ResSet+2)->Amp  = (USHORT)FftAna->var.swork_max[2];
	}

	if( ((USHORT)FftAna->var.swork_min <= Fmin_calc) || ((USHORT)FftAna->var.swork_min > Fmax_calc) )
	{
		AntSet->Freq = 0;
		AntSet->Amp  = 0;
	}
	else
	{
		AntSet->Freq = (USHORT)FftAna->var.freq_min;
		AntSet->Amp  = (USHORT)FftAna->var.swork_min;
	}

	return rc;
}



/****************************************************************************************************/
/*																									*/
/*		振動周波数解析用データ設定API																*/
/*																									*/
/****************************************************************************************************/
void	FftSetAnaCondition( FFTANALYZE *FftAna, LONG SumpleNum, LONG AnaMaxFreq, 
										LONG AnaMinFreq, BOOL TuneLessSts )
{
	/* 各実行条件の設定 */
	FftAna->FftAnaPrm.SumpleNum = SumpleNum;
	FftAna->FftAnaPrm.AnaMaxFreq = AnaMaxFreq;
	FftAna->FftAnaPrm.AnaMinFreq = AnaMinFreq;
	FftAna->FftAnaPrm.TuneLessSts = TuneLessSts;
}



/****************************************************************************************************/
/*																									*/
/*		オンライン振動モニタ共振周波数1取得API														*/
/*																									*/
/****************************************************************************************************/
USHORT	FftGetAnaRsltVibmRf( FFTANALYZE *FftAna )
{
	return	FftAna->FftAnaRslt.VibmRf[0].Freq;
}



/****************************************************************************************************/
/*																									*/
/*		強制周波数解析処理要求設定API																*/
/*																									*/
/****************************************************************************************************/
void	FftSetForceAnaReq( FFTANALYZE *FftAna, BOOL Setting )
{
	FftAna->FftAnaPrm.ActiveFFtOn = Setting;
	return;
}



/****************************************************************************************************/
/*																									*/
/*		強制周波数解析処理要求取得API																*/
/*																									*/
/****************************************************************************************************/
BOOL	FftGetForceAnaReq( FFTANALYZE *FftAna )
{
	return	FftAna->FftAnaPrm.ActiveFFtOn;
}



/***************************************** end of file **********************************************/
