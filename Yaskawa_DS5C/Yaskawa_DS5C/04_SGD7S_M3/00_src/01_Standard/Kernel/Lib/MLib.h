#ifndef		 MLIB_H_
/****************************************************************************************************/
/*																									*/
/*																									*/
/*		mlib_c_float.h : floatî≈MLIBä÷êîíËã`														*/
/*																									*/
/*																									*/
/*																									*/
/************** Copyright (C) Yaskawa Electric Corporation ******************************************/
/*																									*/
/*		èâî≈   : 2000.01.14  T.Taniguchi	Mlib85E.c												*/
/*																									*/
/*	Log		:	Ver1.00																				*/
/*																									*/
/****************************************************************************************************/
#include "Basedef.h"

/****************************************************************************************************/
/*																									*/
/*		ÉGÉìÉfÉBÉAÉìïœä∑É}ÉNÉç																		*/
/*																									*/
/****************************************************************************************************/
#if		defined( __CA850__ )
/*--------------------------------------------------------------------------------------------------*/
#define MlibByteSwap16( x, y )		{(y) = (USHORT)__bsh( (x) );}
/*--------------------------------------------------------------------------------------------------*/
	#if		defined( CCSW_LITTLE_ENDIAN ) 
	#define MlibCnvLittle16( x, y )	{ ; }
	#define MlibCnvBig16( x, y )	{ MlibByteSwap16( (x), (y) );}
	#endif
	/*----------------------------------------------------------------------------------------------*/
	#if		defined( CCSW_BIG_ENDIAN ) 
	#define MlibCnvBig16( x, y )		( x )
	#define MlibCnvLittle16( x, y )		{ MlibByteSwap16( (x), (y) );}
	#endif
/*--------------------------------------------------------------------------------------------------*/
#elif	defined( __RENESAS__ )
#define MlibByteSwap16( x, y )		{(y) = (USHORT)swapb( (x) );}
/*--------------------------------------------------------------------------------------------------*/
	#if		defined( CCSW_LITTLE_ENDIAN ) 
	#define MlibCnvLittle16( x, y )	{ ; }
	#define MlibCnvBig16( x, y )	{ MlibByteSwap16( (x), (y) );}
	#endif
	/*----------------------------------------------------------------------------------------------*/
	#if		defined( CCSW_BIG_ENDIAN ) 
	#define MlibCnvBig16( x, y )		{ ; }
	#define MlibCnvLittle16( x, y )		{ MlibByteSwap16( (x), (y) );}
	#endif
/*--------------------------------------------------------------------------------------------------*/
#elif	defined( __CC_ARM )
//#define MlibByteSwap16( x, y )   	__asm {  REV16  y, x  }
#define MlibByteSwap16( x, y )   	{ y = __rev( x ); }
/*--------------------------------------------------------------------------------------------------*/
	#if		(! defined( __BIG_ENDIAN ))
	#define MlibCnvLittle16( x, y )	{ ; }
	#define MlibCnvBig16( x, y )	{ MlibByteSwap16( (x), (y) );}
	#define MlibCnvBig32( x )	__rev( x )
	/*----------------------------------------------------------------------------------------------*/
	#else
	#define MlibCnvBig16( x, y )		( x )
	#define MlibCnvLittle16( x, y )		{ MlibByteSwap16( (x), (y) );}
	#endif
/*--------------------------------------------------------------------------------------------------*/
#elif	defined( _VC_DEBUG_ )
#define MlibByteSwap16( x, y )		(y) = (USHORT)( (((x) & 0xFF) << 8) + (((x) >> 8) & 0xFF) )
#define MlibByteSwap32( x, y )		(y) = (ULONG)( (((x) & 0xFF) << 24) + ((((x) >> 8) & 0xFF)<<16) + ((((x) >> 16) & 0xFF)<<8) + (((x) >> 24) & 0xFF) )
	#if		defined( CCSW_LITTLE_ENDIAN ) 
	#define MlibCnvLittle16( x, y )	{ ; }
	#define MlibCnvBig16( x, y )	( MlibByteSwap16( (x), (y) ) )
	#define MlibCnvBig32( x )		( MlibByteSwap32( (x), (x) ) )
	#endif
	/*----------------------------------------------------------------------------------------------*/
	#if		defined( CCSW_BIG_ENDIAN ) 
	#define MlibCnvBig16( x, y )		{ ; }
	#define MlibCnvLittle16( x, y )		( MlibByteSwap16( (x), (y) ) )
	#endif
/*--------------------------------------------------------------------------------------------------*/
#else
#define MlibByteSwap16( x, y )		{(y) = (USHORT)( (((x) & 0xFF) << 8) + (((x) >> 8) & 0xFF) );}
#endif
/*--------------------------------------------------------------------------------------------------*/


/****************************************************************************************************/
/*																									*/
/*		Basic Constant Definition																	*/
/*																									*/
/****************************************************************************************************/
#define	SRH_FROM_LSB			0
#define	SRH_FROM_MSB			1
#define	KSPAI					0x156487ED				/* {k,s} Type   PAI							*/
#define	KS2PAI					0x146487ED				/* {k,s} Type 2*PAI							*/
#define	KS3PAI					0x134B65F2				/* {k,s} Type 3*PAI							*/
#define	KS4PAI					0x136487ED				/* {k,s} Type 4*PAI							*/
/*--------------------------------------------------------------------------------------------------*/
#define	NORMAXVALUE				0x01000000				/* Normalized Maximum Value					*/
#define	NORMINVALUE				-0x01000000				/* Normalized Minimum Value					*/
/*--------------------------------------------------------------------------------------------------*/
#define	CCSW_HsMulgain			1					/* for MlibHsMulgain() Parameter Cal.			*/
#define	FLOAT2KF1GAIN			0x800000			/* FloatÇ©ÇÁKF1GAINÇ÷ÇÃïœä∑íËêî					*/

#define	PI						3.1415926535		/* ÉŒ											*/
#define	DEG2RAD					0.0174532925194		/* ÉŒ / 180										*/
#define	FOURTEENBIT2RAD			0.0003834951969604	/* (ÉŒ / 180) * (360 / 16384)					*/

#define	C10POW9					1000000000			/* 10^9											*/
#define	C10POW7					10000000			/* 10^7											*/
#define	C2PAIE7					62831853			/* (2*PAI) * 10^7								*/

/****************************************************************************************************/
/*																									*/
/*		äÓñ{êîílââéZÉ}ÉNÉç																			*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		Basic Macro																					*/
/*--------------------------------------------------------------------------------------------------*/
#define MlibABS( u )	(((u)>=0) ? (u) : -(u))
#define MlibMAX( a, b )	(((a)>(b)) ? (a) : (b))
#define MlibMIN( a, b )	(((a)<(b)) ? (a) : (b))
#define	MlibLIMITUL( u, ulim, llim )	(((u)>=(ulim))? (ulim) : (((u)<=(llim))? (llim) : (u)))
/*--------------------------------------------------------------------------------------------------*/
/*		64bit Compare Macro : GT(a>b),LT(a<b),GTE(a>=b),LTE(a<=b)									*/
/*--------------------------------------------------------------------------------------------------*/
#define	MlibEQ64( a, b )	( (a[1] == b[1]) && (a[0] == b[0]) )
#define	MlibGT64( a, b )	( (a[1] >  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] >  (ULONG)b[0])) )
#define	MlibLT64( a, b )	( (a[1] <  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] <  (ULONG)b[0])) )
#define	MlibGTE64( a, b )	( (a[1] >  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] >= (ULONG)b[0])) )
#define	MlibLTE64( a, b )	( (a[1] <  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] <= (ULONG)b[0])) )
/*--------------------------------------------------------------------------------------------------*/
/*		64bit Upper/Lower Limit Macro																*/
/*--------------------------------------------------------------------------------------------------*/
#define	MlibUPPERLMT64( x, ulim )	if( MlibGT64( x, ulim ) ){ x[0] = ulim[0]; x[1] = ulim[1];}
#define	MlibLOWERLMT64( x, llim )	if( MlibLT64( x, llim ) ){ x[0] = llim[0]; x[1] = llim[1];}
/*--------------------------------------------------------------------------------------------------*/
/*		Integer Data <--> Floating Data Macro							<S00A>				*/
/*--------------------------------------------------------------------------------------------------*/
#define	NORMALIZEINT( x )		((LONG)(x*(double)167772.16))		/* 167772.16 = 16777216/100		*/
#define	NORMALIZEINTX( x )		((LONG)(x*(float)150.00))		/* 150.00 = 15000/100			*/
#define	NORMALIZEFLOAT( x )		((float)(x/(double)167772.16))	/* 167772.16 = 100/16777216		*/
#define	NORMALIZEFLOATX( x )	((float)(x/(float)150.00))	/* 150.00 = 100/15000			*/
/*--------------------------------------------------------------------------------------------------*/

/****************************************************************************************************/
/*																									*/
/*		äÓñ{êîílââéZÉ}ÉNÉç																			*/
/*																									*/
/****************************************************************************************************/
extern	const	SHORT	MlibFastSinTbl[1024];				/* çÇë¨ÇrÇâÇéââéZ : ì¸óÕ:[360deg/1024]	*/
#define	MlibFASTSINS16( a )	(MlibFastSinTbl[(a)&0x3FF])		/* çÇë¨ÇrÇâÇéââéZ : èoóÕ:[1.000/16384]	*/
#define MlibFASTCOSS16( a ) (MlibFastSinTbl[(a+256)&0x3FF])	/* çÇë¨ÇbÇèÇìââéZ : èoóÕ:[1.000/16384]	*/
/*--------------------------------------------------------------------------------------------------*/
__inline LONG MlibLABS(LONG u)
{
	return 	(((u)>=0) ? (u) : -(u));
}
__inline LONG MlibAbs32(LONG u)
{
	return 	(((u)>=0) ? (u) : -(u));
}

/****************************************************************************************************/
/*																									*/
/*		64bitêîílââéZÉ}ÉNÉç																			*/
/*																									*/
/****************************************************************************************************/
#if defined( __PowerPC )
/****************************************************************************************************/
/*																									*/
/*		ÇbÇoÇtã@éÌàÀë∂ÅFINGRAM(PPC)óp																*/
/*																									*/
/****************************************************************************************************/
__inline void	MUL3232(LONG a, LONG b, LONG *xx)
{
	xx[0] = (a)*(b);	
	xx[1] = __MULSH(a, b);		
}

__inline void	MULU32U32(ULONG a, ULONG b, ULONG *xx)
{
	xx[0] = (ULONG)((a)*(b));
	xx[1] = __MULUH(a, b);		
}

/*--------------------------------------------------------------------------------------------------*/
/*		äÑÇËçûÇ›ã÷é~Å^ãñâ¬																			*/
/*--------------------------------------------------------------------------------------------------*/
#undef	KPI_DI
#define	KPI_DI( )				{ ;}				/* äÑçûÇ›ã÷é~									*/
#undef	KPI_EI
#define	KPI_EI( )				{ ;}				/* äÑçûÇ›ãñâ¬									*/
/*--------------------------------------------------------------------------------------------------*/

#elif	defined( WIN32 )

/***** ïÇìÆè¨êîì_ÉfÅ[É^ÇàµÇ§ç\ë¢ëÃ *****//*<S00A>*/
typedef union F2L
{
	long				l;
	unsigned long		u;
	float				f;
	//struct
	//{
	//	long			l;
	//	long			h;
	//} sl;
	//struct
	//{
	//	unsigned long	l;
	//	unsigned long	h;
	//} ul;
	//double			df;
} F2L;
/****************************************************************************************************/
/*																									*/
/*		ÇbÇoÇtã@éÌàÀë∂ÅFÉpÉ\ÉRÉìóp																	*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
#define	MUL3232( a, b, xx )		*(INT64*)xx = ((INT64)(a))*((INT64)(b))
#define	MULU32U32( a, b, xx )	*(INT64*)xx = ((INT64)(ULONG)(a))*((INT64)(ULONG)(b))
/*--------------------------------------------------------------------------------------------------*/
/*		äÑÇËçûÇ›ã÷é~Å^ãñâ¬																			*/
/*--------------------------------------------------------------------------------------------------*/
#undef	KPI_DI
#define	KPI_DI( )				{ ;}				/* äÑçûÇ›ã÷é~									*/
#undef	KPI_EI
#define	KPI_EI( )				{ ;}				/* äÑçûÇ›ãñâ¬									*/
/*--------------------------------------------------------------------------------------------------*/

#else
/****************************************************************************************************/
/*																									*/
/*		ÇbÇoÇtã@éÌàÀë∂ÅFSGDZ-SVN(SH-4A)óp															*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
#define	MUL3232( a, b, xx )		*(INT64*)xx = ((INT64)(a))*((INT64)(b))
#define	MULU32U32( a, b, xx )	*(INT64*)xx = ((INT64)(ULONG)(a))*((INT64)(ULONG)(b))
/*--------------------------------------------------------------------------------------------------*/

#endif

typedef struct ull 
  { unsigned long lower, upper; }
ull;

typedef struct longlong
  { unsigned long lower; long upper; }
longlong;

#define Sub64_2(dest, a1, a2)	/* Subtract a2 from a1 result in dest  */  \
     (((dest).upper = (a1).upper - (a2).upper - ((a1).lower < (a2).lower)), \
     ((dest).lower = (a1).lower - (a2).lower))
#define Add64_2(dest, a1, a2)	/* Add a2 to a1.   */	   \
	((dest).lower = (a1).lower + (a2).lower, \
	(dest).upper = (a1).upper + (a2).upper + \
	((dest).lower < (a2).lower))
#define Add64_64_32_2(dest, a1, a2)	/* Like Add64_2, but a2 is UINT4 */ \
	((dest).lower = (a1).lower + (a2), \
	(dest).upper = (a1).upper + ((dest).lower < (a2)))

__inline void	ADD6464(LONG *a, LONG *b, LONG *xx)
{
#if 0
	xx[0] = a[0] + b[0];
//	xx[1] = a[1] + b[1] + (xx[0] < b[0]);
	xx[1] = a[1] + b[1] + ((ULONG)(xx[0]) < (ULONG)(b[0]));    /* <S053> */
#else/* <S07E> *///<S0C7>
LONG lworka0,lworka1;
LONG lworkb0,lworkb1;

lworka0 = a[0];
lworkb0 = b[0];
lworka1 = a[1];
lworkb1 = b[1];

	xx[0] = lworka0 + lworkb0;
	xx[1] = lworka1 + lworkb1 + ((ULONG)xx[0] < (ULONG)lworkb0);

#endif
}
__inline void	SUB6464(LONG *a, LONG *b, LONG *xx)
{
//	xx[1] = a[1] - b[1] - (a[0] < b[0]);
	xx[1] = a[1] - b[1] - ((ULONG)(a[0]) < (ULONG)(b[0]));   /* <S053> */
	xx[0] = a[0] - b[0];
}
__inline LONG	MlibMulhigh32( LONG a, LONG b )
{
	LONG xx[2];
	MUL3232(a,b,xx);
	return( xx[1] + ((ULONG)xx[0]>>31) );
}
__inline LONG	MlibMulhighu32( LONG a, LONG b )
{
	ULONG xx[2];
	MULU32U32(a,b,xx);
	return( xx[1] + ((ULONG)xx[0]>>31) );
}


/*--------------------------------------------------------------------------------------------------*/
/*		äÑÇËçûÇ›ã÷é~Å^ãñâ¬																			*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef _TEST_BOARD_
#undef	KPI_DI
#define	KPI_DI( )		{  /*  TODO:  äÑÇËçûÇ›ã÷é~ */                                \
							long st;                                                 \
							__asm {                                                  \
								MRS st, CPSR;      /* st <- CPSR */                  \
								ORR st, st, 0x80; /* set interrupt disable bit */   \
								MSR CPSR_c, st;    /* CPSR <- st */                  \
							} \
						} \

#undef	KPI_EI
#define	KPI_EI( )		{ /* TODO: äÑçûÇ›ãñâ¬	*/\
							long st;                                                 \
							__asm {                                                  \
								MRS st, CPSR;      /* st <- CPSR */                  \
								BIC st, 0x80;     /* clear interrupt disable bit */ \
								MSR CPSR_c, st;    /* CPSR <- st */                  \
							} \
						}
/*--------------------------------------------------------------------------------------------------*/
#elif defined( WIN32 )
/* äÑã÷Ç»Çµ */
#elif defined( _MERCURY_PLATFORM_ )			/*<S190>*/
#define	KPI_DI( )		;
#define	KPI_EI( )		;
#else /* ébíËìIÇ…äÑã÷Ç»Çµ */
#define	KPI_DI( )		__DI();
#define	KPI_EI( )		__EI();
#endif
/*--------------------------------------------------------------------------------------------------*/


/****************************************************************************************************/
/*																									*/
/*		äÓñ{êßå‰ââéZä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibLimitul()       : è„â∫å¿ÉäÉ~ÉbÉg				rv=ÉäÉ~ÉbÉgíl;							*/
/*   1-2) FlibLimitul()     : è„â∫å¿ÉäÉ~ÉbÉg				rv=ÉäÉ~ÉbÉgíl;							*//*<S00A>*/
/*   2) MlibMulgain()       : ÉQÉCÉìèÊéZ(LimitïWèÄ:2^24)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*   3) MlibMulgain27()     : ÉQÉCÉìèÊéZ(Limitägí£:2^26)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*   4) MlibMulgain29()     : ÉQÉCÉìèÊéZ(Limitägí£:2^28)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*   5) MlibMulgain30()     : ÉQÉCÉìèÊéZ(Limitägí£:2^29)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*   6) MlibMulgain32()     : ÉQÉCÉìèÊéZ(Limitägí£:2^31)	rv=(kx*u)>>sx; 0<=sx<=24  				*/
/*   7) MlibMulgainSx48()   : ÉQÉCÉìèÊéZ(smaxägëÂ) 			rv=(kx*u)>>sx; 0<=sx<=48				*/
/*   8) MlibMulgainNolim()  : ÉQÉCÉìèÊéZ(Limitñ≥Çµ)			rv=(kx*u)>>sx; 0<=sx<=24				*/
/*   9) MlibIntegral()      : êœï™ââéZ(LimitïtÇ´)			rv=(iu[1]>>1);iu[]=iu[]+kx*u;			*/
/*   9-2) FlibIntegral()      : êœï™ââéZ(LimitïtÇ´)			rv=iu; iu+=kx*u							*//*<S00A>*/
/*--------------------------------------------------------------------------------------------------*/
/*  10) MlibPfbkxremLim()   : ó]ÇËïtÇ´à íuÇeÇaåvéZ			rv=(kx*u+pfbrem)>>sx;					*/
/*  11) MlibPfbkxremNolim() : ó]ÇËïtÇ´à íuÇeÇaåvéZ			rv=(kx*u+pfbrem)>>sx;					*/
/*  12) MlibMulkprem()      : ó]ÇËïtÇ´à íuÉQÉCÉìèÊéZ		rv=(kx*u-((kx*pfbrem)>>24))>>sx;		*/
/*  13) MlibMulkxBiasrem()  : ÉoÉCÉAÉXó]ÇËïtÇ´ÉQÉCÉìèÊéZ	rv=(kx*u+rem+(sign(u)*bias>>s))>>sx;	*/
/*--------------------------------------------------------------------------------------------------*/
/*	14) MlibKrMulgain()     : ÉQÉCÉìèÊéZ(ÉQÉCÉìî‰ó¶ïtÇ´)    rv=(kr*u)>>sx; kr=(kx*r)/(10000<<16)	*/
/*	15) MlibKrMulgain27()   : ÉQÉCÉìèÊéZ(ÉQÉCÉìî‰ó¶ïtÇ´)    rv=(kr*u)>>sx; kr=(kx*r)/(10000<<16)	*/
/*	16) MlibKrIntegral()    : êœï™ââéZ(ÉQÉCÉìî‰ó¶ïtÇ´)      iu=iu+(kr*u); rv=((iu[1]+x)>>1);		*/
/*--------------------------------------------------------------------------------------------------*/
/*  17) MlibSymMulgain()    : ÉQÉCÉìèÊéZ(ê≥ïâëŒèÃéléÃå‹ì¸)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*  18) MlibSymMulgainNolim : ÉQÉCÉìèÊéZ(ê≥ïâëŒèÃéléÃå‹ì¸)	rv=(kx*u)>>sx; 0<=sx<=24				*/
/*  19) MlibSymIntegral()   : êœï™ââéZ(ê≥ïâëŒèÃéléÃå‹ì¸)	rv=(iu[1]>>1);iu[]=iu[]+kx*u;			*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLimitul( LONG u, LONG ulim, LONG llim );
#if (FLOAT_USE==TRUE)
float	FlibLimitul( float u, float ulim, float llim );
#endif /* FLOAT_USE */
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibMulgain( LONG u, LONG k );
LONG	MlibMulgain27( LONG u, LONG k );
LONG	MlibMulgain29( LONG u, LONG k );
LONG	MlibMulgain30( LONG u, LONG k );
LONG	MlibMulgain32( LONG u, LONG k );
ULONG	MlibMulgain30U( ULONG u, LONG k );
ULONG	MlibMulgain31U( ULONG u, LONG k );
ULONG	MlibMulgain32U( ULONG u, LONG k );
LONG	MlibMulgainSx48( LONG u, LONG k );
LONG	MlibMulgain32Sx48( LONG u, LONG k );
LONG	MlibMulgainNolim( LONG u, LONG k );
LONG	MlibIntegral( LONG u, LONG k, LONG iu[2] );

#if (FLOAT_USE==TRUE)
float	FlibIntegral( float u, float k, float *iu );
#endif /* FLOAT_USE */
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPfbkxremLim( LONG u, LONG k, LONG *pfbrem );
LONG	MlibPfbkxremNolim( LONG u, LONG k, LONG *pfbrem );
LONG	MlibMulkprem( LONG u, LONG k, LONG  pfbrem );
LONG	MlibMulkxBiasrem( LONG u, LONG k, LONG *rem, LONG bias );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibKrMulgain( LONG u, LONG k, LONG r );
LONG	MlibKrMulgain27( LONG u, LONG k, LONG r );
LONG	MlibKrIntegral( LONG u, LONG k, LONG r, LONG iu[2] );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibSymMulgain( LONG u, LONG k );
LONG	MlibSymMulgainNolim( LONG u, LONG k );
LONG	MlibSymIntegral( LONG u, LONG k, LONG iu[2] );
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		ÉtÉBÉãÉ^ââéZä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibLpfilter1()     : ÇPéüÉçÅ[ÉpÉXÉtÉBÉãÉ^			rv=x+((kx*(u-x))>>24);					*/
/*   1-2) FlibLpfilter1()     : ÇPéüÉçÅ[ÉpÉXÉtÉBÉãÉ^			rv=x+((kx*(u-x))>>24);					*//*<S00A>*/
/*   2) MlibHpfilter1()     : ÇPéüÉnÉCÉpÉXÉtÉBÉãÉ^			rv=u-z; z=z+((kx*(u-z))>>24);			*/
/*   3) MlibLpfilter2()     : ÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^			rv=(z[2]>>1);							*/
/*   4) MlibNxfilter2()     : ÇQéüÉmÉbÉ`ÉtÉBÉãÉ^			rv=k[2]*(u-(z[2]>>1)-z[0])+(z[2]>>1);	*/
/*   5) MlibLaufilter()     : íºê¸â¡ë¨äÌ(LAU)ÉtÉBÉãÉ^		rv= z + dz or rv= z - dz;				*/
/*   6) MlibBITFILTER1()    : ÇPâÒíxÇÍÉrÉbÉgÉtÉBÉãÉ^		out = f( out, oldin, newin )			*/
/*   7) MlibKrLpfilter1()   : ÇPéüÉçÅ[ÉpÉXÉtÉBÉãÉ^(î‰ó¶ït)	rv=x+((kr*(u-x))>>24);					*/
/*   8) MlibLowPassfilter2(): ÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^ââéZ(ëoàÍéüïœä∑)									*/
/*   8-2) FlibLowPassfilter2(): ÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^ââéZ(ëoàÍéüïœä∑)									*//*<S00A>*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLpfilter1( LONG u, LONG k, LONG x  );
#if (FLOAT_USE==TRUE)
float	FlibLpfilter1( float u, float k, float x  );
float	FlibHpfilter1( float u, float k, float *z );
#endif /* FLOAT_USE */
LONG	MlibHpfilter1( LONG u, LONG k, LONG *z );
LONG	MlibLpfilter2( LONG u, LONG k[2], LONG z[3] );
LONG	MlibNxfilter2( LONG u, LONG k[3], LONG z[3] );
LONG	MlibLaufilter( LONG u, LONG z, LONG dz );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibKrLpfilter1( LONG u, LONG k, LONG r, LONG x );
LONG	MlibLowPassfilter2( LONG u, LONG k[4], LONG z[4] );
#if (FLOAT_USE==TRUE)
float	FlibLowPassfilter2( float u, float k[4], float z[4] );	/* ÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^ââéZ(ëoàÍéüïœä∑)	*/
#endif /* FLOAT_USE */
/*--------------------------------------------------------------------------------------------------*/
/*		ÇPâÒíxÇÍÉrÉbÉgÉtÉBÉãÉ^É}ÉNÉç																*/
/*--------------------------------------------------------------------------------------------------*/
#define	MlibBITFILTER1( out, oldin, newin )\
		{ out = (((oldin | newin) & out ) | (oldin & newin)); oldin = newin;}
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		à íuä÷òAââéZä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibPcmdIpfil()     : à íuéwóﬂï‚ä‘ÉtÉBÉãÉ^			rv=(pcmdin+rem)/n						*/
/*   2) MlibPcmdMafil()     : à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^		rv=sum/n, sum=sum+pcmdin-pmafbuf[idx]	*/
/*   3) MlibPcmdMafilSec()  : à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^2		rv=sum/n, sum=sum+pcmdin-pmafbuf[idx]	*//*<S0C3>*/
/*   4) MlibPcmdImafil()    : à íuï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^		rv=sum/n, sum=sum+newpcmd/n-oldpcmd/n	*/
/*   5) MlibPcmdImafilSec() : à íuï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^2		rv=sum/n, sum=sum+newpcmd/n-oldpcmd/n	*//*<S0C3>*/
/*   6) MlibPcmdExpfil()    : à íuéwóﬂéwêîâ¡å∏ë¨ÉtÉBÉãÉ^	rv=sum*kexp, sum=sum+pcmdin-rv			*/
/*   7) MlibPcmdLpfil1()    : à íuéwóﬂÇPéüÉçÅ[ÉpÉXÉtÉBÉãÉ^	rv=z*kf, z=z+pcmdin-rv					*/
/*   8) MlibPcmdLpfil2()    : à íuéwóﬂÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^	rv=z[1]*kf1, z[0]=z[0]+pcmdin-rv		*/
/*   8-2) FlibPcmdLpfil2()  : à íuéwóﬂÇQéüÉçÅ[ÉpÉXÉtÉBÉãÉ^	rv=z[1]*kf1, z[0]=z[0]+pcmdin-rv		*//*<S00A>*/
/*   9) MlibPcmdNxfil2()    : à íuéwóﬂÇQéüÉmÉbÉ`ÉtÉBÉãÉ^	rv=pcmdin - Delta(kf2*z[1])				*/
/*  10) MlibPcmdEgear()     : à íuéwóﬂìdéqÉMÉÑåvéZ			rv=(B/A)*pcmda							*/
/*  10-2) FlibPcmdEgear()   : à íuéwóﬂìdéqÉMÉÑåvéZ			rv=(B/A)*pcmda							*//*<S00A>*/
/*  11) MlibEgearRvscnv()   : ìdéqÉMÉÑãtïœä∑åvéZ			rv=(A/B)*inpls							*/
/*  12) MlibPcalKegear()    : ìdéqÉMÉÑÉpÉâÉÅÅ[É^åvéZ 		OUT: egear.k1, egear.k2, etc			*/
/*  13) MlibPerrcala()      : à íuïŒç∑åvéZÇ`(éwóﬂíPà )		OUT: perra.per32s, perra.per32a, etc	*/
/*  13-2) FlibPerrcala()    : à íuïŒç∑åvéZÇ`(éwóﬂíPà )		OUT: perra.per32s, perra.per32a, etc	*//*<S00A>*/
/*  14) MlibPerrcalx()      : à íuïŒç∑åvéZÇw(ÇeÇaíPà )		rv=per64[0]; per64[]=per64[]+pcmd-pfbk;	*/
/*  14-2) FlibPerrcalx()    : à íuïŒç∑åvéZÇw(ÇeÇaíPà )		rv=per64[0]; per64[]=per64[]+pcmd-pfbk;	*//*<S00A>*/
/*  15) MlibAposRg64iv()    : èâä˙ê‚ëŒà íuåvéZ(ãtìdéqÉMÉÑ)	OUT: aposrg.apos[],aposrem,etc			*/
/*	16) MlibAposRg64dp()    : ê‚ëŒà íuçXêVåvéZ(ãtìdéqÉMÉÑ)	OUT: aposrg.apos[],aposrem,etc			*/
/*																									*/
/****************************************************************************************************/
/*START <S0CD>*/
typedef	struct	{	
		LONG	GrvTrq;							/* Gravity Torque          */
		LONG	PosCTrq;						/* Positive Coulomb Torque */
		LONG	NegCTrq;						/* Negative Coulomb Torque */
		LONG	VisTrq;					        /* Viscous Torque          */
		LONG	MotFricEnable;	                /* Motor Friction Enable*/
		LONG    TrqCLast;						/* Torque Coulomb Last      */
		LONG    TrqGrvLast;						/* Torque Gravity Last      */
		LONG    SpdHys;				          	/* offset speed            */
		LONG    RatSpeed;				    	/* rate speed            */
		BOOL    InitEnable; 					/* Motor Friction Parameters Initialization Enable */
}FRICTION;
/*END <S0CD>*/
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂï‚ä‘ÉtÉBÉãÉ^																		*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* à íuéwóﬂï‚ä‘ÉtÉBÉãÉ^ç\ë¢ëÃíËã`									*/
		LONG	cmdx;			/* à íuéwóﬂì¸óÕ														*/
		LONG	remx;			/* à íuéwóﬂèoóÕó]ÇË													*/
} PIPFV;
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdIpfil( LONG pcmdin, LONG shift, LONG index, PIPFV *pipfvar );
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^																	*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^ç\ë¢ëÃíËã`								*/
		SHORT	idx;			/* ÉoÉbÉtÉ@ÉCÉìÉfÉNÉX												*/
		SHORT	ksub;			/* å∏éZó ââéZÉQÉCÉì(0/1)											*/
		LONG	sumx;			/* à íuéwóﬂçáåv														*/
		LONG	remx;			/* à íuéwóﬂó]ÇË														*/
		USHORT	zcntx;			/* ï•èoÇµäÆóπÉ`ÉFÉbÉN(0:äÆóπ)										*/
		USHORT	spare;			/* ó\îı																*/
} PMAFV;
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^2																	        */
/*--------------------------------------------------------------------------------------------------*//*<S0C3>*/
typedef	struct	{				/* à íuéwóﬂà⁄ìÆïΩãœÉtÉBÉãÉ^ç\ë¢ëÃíËã`*/
		SHORT	idxSec;			/* ÉoÉbÉtÉ@ÉCÉìÉfÉNÉX												*/
		SHORT	ksubSec;		/* å∏éZó ââéZÉQÉCÉì(0/1)											*/
		LONG	sumxSec;		/* à íuéwóﬂçáåv														*/
		LONG	remxSec;		/* à íuéwóﬂó]ÇË														*/
		USHORT	zcntxSec;		/* ï•èoÇµäÆóπÉ`ÉFÉbÉN(0:äÆóπ)										*/
		USHORT	spareSec;		/* ó\îı		                                                        */
} HIGHFV;
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdMafil( LONG pcmdin, LONG pmafnum, PMAFV *pmafvar, LONG *pmafbuf );
LONG	MlibPcmdMafilSec( LONG pcmdin, LONG pmafnum, HIGHFV *pmafvarSec, LONG *pmafbufSec );   /*<S0C3>*/
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^																*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* à íuéwóﬂï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^ç\ë¢ëÃíËã`							*/
		LONG	sumx;			/* à íuéwóﬂçáåv														*/
		LONG	remx;			/* à íuéwóﬂó]ÇË														*/
		LONG	newpcmd;		/* à íuéwóﬂì¸óÕ														*/
		LONG	oldpcmd;		/* à íuéwóﬂì¸óÕëOâÒíl												*/
		USHORT	zcntx;			/* ï•èoÇµäÆóπÉ`ÉFÉbÉN(0:äÆóπ)										*/
		USHORT	spare;			/* ó\îı																*/
} PIMFV;
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^2																*/
/*--------------------------------------------------------------------------------------------------*/ /*<S0C3>*/
typedef	struct	{				/* High filterï‚ä‘à⁄ìÆïΩãœÉtÉBÉãÉ^ç\ë¢ëÃíËã`	                    */
		LONG	sumxSec;		/* à íuéwóﬂçáåv														*/
		LONG	remxSec;		/* à íuéwóﬂó]ÇË														*/
		LONG	newpcmdSec;		/* à íuéwóﬂì¸óÕ														*/
		LONG	oldpcmdSec;		/* à íuéwóﬂì¸óÕëOâÒíl												*/
		USHORT	zcntxSec;		/* ï•èoÇµäÆóπÉ`ÉFÉbÉN(0:äÆóπ)										*/
		USHORT	spareSec;		/* ó\îı		                                                        */
} HIMFV;
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdImafil( LONG pcmdin, LONG shift, LONG index, PIMFV *pimfvar );
LONG	MlibPcmdImafilSec( LONG pcmdin, LONG shift, LONG indexSec, HIMFV *pimfvarSec );   /*<S0C3>*/
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂéwêîâ¡å∏ë¨ÉtÉBÉãÉ^																	*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* à íuéwóﬂéwêîâ¡å∏ë¨ÉtÉBÉãÉ^ç\ë¢ëÃíËã`								*/
		LONG	sumx;			/* à íuéwóﬂçáåv														*/
		LONG	remx;			/* à íuéwóﬂó]ÇË(ñ¢égóp)												*/
} PEXFV;
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdExpfil( LONG pcmdin, LONG kexp, LONG pbias, PEXFV *pexfvar );
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂÉçÅ[ÉpÉXÉtÉBÉãÉ^																	*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdLpfil1( LONG pcmdin, LONG kf, LONG *z );
LONG	MlibPcmdLpfil2( LONG pcmdin, LONG kf[2], LONG z[2] );
#if (FLOAT_USE==TRUE)
float	FlibPcmdLpfil2( float pcmdin, float kf[2], float z[2] );
#endif /* FLOAT_USE */
LONG	MlibPcmdNxfil2( LONG pcmdin, LONG kf[3], LONG z[3] );
/*--------------------------------------------------------------------------------------------------*/
/*		ìdéqÉMÉÑÅïà íuïŒç∑ç\ë¢ëÃ																	*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* ìdéqÉMÉÑç\ë¢ëÃíËã`												*/
		LONG	a;				/* ìdéqÉMÉÑÇ`														*/
		LONG	b;				/* ìdéqÉMÉÑÇa														*/
		LONG	k1;				/* ìdéqÉMÉÑÉQÉCÉìÅFb/aÇÃè„à bit										*/
		LONG	k2;				/* ìdéqÉMÉÑÉQÉCÉìÅFb/aÇÃâ∫à bit										*/
		LONG	g1;				/* ìdéqÉMÉÑÉQÉCÉìÅFa/bÇÃè„à bit										*/
		LONG	g2;				/* ìdéqÉMÉÑÉQÉCÉìÅFa/bÇÃâ∫à bit										*/
#if (FLOAT_USE==TRUE)
		float		f_a;		/* ìdéqÉMÉÑÇ`														*/
		float		f_b;		/* ìdéqÉMÉÑÇa														*/
		float		f_k1;		/* ìdéqÉMÉÑÉQÉCÉì(ê≥ïœä∑)ÅFb/a										*/
		float		f_k2;		/* ìdéqÉMÉÑÉQÉCÉì(ê≥ïœä∑)ÅFb/aó]ÇË									*/
		float		f_g1;		/* ìdéqÉMÉÑÉQÉCÉì(ãtïœä∑)ÅFa/b										*/
		float		f_g2;		/* ìdéqÉMÉÑÉQÉCÉì(ãtïœä∑)ÅFa/bó]ÇË									*/
#endif /* FLOAT_USE */
} EGEAR;
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{				/* à íuïŒç∑Ç`ç\ë¢ëÃíËã`												*/
		LONG	pfbkb;			/* à íuÇeÇa(éwóﬂíPà )ââéZåãâ 										*/
		LONG	pfbkrem;		/* à íuÇeÇa(éwóﬂíPà )ââéZåãâ ó]ÇË									*/
		LONG	per64[2];		/* à íuïŒç∑64bitââéZóp												*/
		LONG	per32s;			/* à íuïŒç∑èoóÕ(éléÃå‹ì¸)											*/
		LONG	per32a;			/* ìØè„ê‚ëŒíl(éléÃå‹ì¸)												*/
		LONG	per32sx;		/* à íuïŒç∑èoóÕ(êÿÇËè„Ç∞)											*/
		LONG	per32ax;		/* ìØè„ê‚ëŒíl(êÿÇËè„Ç∞)												*/
		LONG	per32mx;		/* à íuïŒç∑ÉÇÉjÉ^óp(êÿÇËè„Ç∞Å^0.5à»â∫Ç≈É[Éç)						*/
} PERRA;
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdEgear( LONG pcmda, EGEAR *egear, LONG *pcmdrem );
#if (FLOAT_USE==TRUE)
float	FlibPcmdEgear( float pcmda, EGEAR *egear, float *pcmdrem );
#endif /* FLOAT_USE */
void	MlibPcalKegear( LONG a, LONG b, EGEAR *egear );
LONG	MlibEgearRvscnv( LONG inpls, EGEAR *egear, LONG *plsrem );
void	MlibPerrcala( LONG pcmda, LONG pfbka, EGEAR *egear, PERRA *perra );
LONG	MlibPerrcalx( LONG pcmdx, LONG pfbkx, LONG per64[2] );
#if (FLOAT_USE==TRUE)
void	FlibPerrcala( LONG pcmda, LONG pfbka, EGEAR *egear, PERRA *perra );	/* âºèàíu	*/
LONG	FlibPerrcalx( LONG pcmdx, LONG pfbkx, LONG per64[2] );	/* âºèàíu	*/
#endif /* FLOAT_USE */

/*--------------------------------------------------------------------------------------------------*/
/*		ê‚ëŒà íuââéZ(ãtìdéqÉMÉÑÅFÇeÇaíPà -->éwóﬂíPà )												*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{
		LONG	dposix;				/* à íuç∑ï™				[éwóﬂíPà ]								*/
		LONG	aposrem;			/* à íuó]ÇË				[éwóﬂíPà ]								*/
		LONG	apos[2];			/* ê‚ëŒà íu(64bit)		[éwóﬂíPà ]								*/
} APOSRG;
/*--------------------------------------------------------------------------------------------------*/
void	MlibAposRg64iv( LONG inipos0, LONG inipos1, EGEAR *egear, APOSRG *aposrg );
void	MlibAposRg64dp( LONG dposin, EGEAR *egear, APOSRG *aposrg, LONG *latchpos );
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		à íuéwóﬂçÏê¨äÌä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibPcmdMaker()     : à íuéwóﬂçÏê¨äÌ(64bit)			rv=vp, vp=vp+vpacc/vp=vp-vpdec			*/
/*   2) MlibIpTposLimit()   : ìØè„ï‚ä‘à íuéwóﬂÉäÉ~ÉbÉg		rv=TRUE(Limit)/FALSE(NotLimit)			*/
/*   3) MlibRstPcmdMaker()  : ìØè„ÉäÉZÉbÉgèàóù				pcmdout[]=pcmdset0,pcmdset1,etc			*/
/*   4) MlibIpcalPcmdMaker  : ìØè„èâä˙ÉpÉâÉÅÅ[É^åvéZ		OUT: pcmkprm.osvpm, maxvpm, pshlx, etc	*/
/*   5) MlibPcalaPcmdMaker  : ìØè„à íuåàÇﬂÉpÉâÉÅÅ[É^åvéZÇ`	OUT: pcmkprm.vpacc, vpdec,  vpamx, etc	*/
/*   6) MlibPcalaPcmdMkrIP  : ìØè„ï‚ä‘ââéZÉpÉâÉÅÅ[É^åvéZÇ`	OUT: pcmkprm.ipmaxspd, ipmaxacc,   etc	*/
/*   7) MlibPcalbPcmdMaker  : ìØè„à íuåàÇﬂÉpÉâÉÅÅ[É^åvéZÇa	OUT: pcmkprm.vpacc, vpdec,  vpamx, etc	*/
/*   8) MlibPcalbPcmdMkrIP  : ìØè„ï‚ä‘ââéZÉpÉâÉÅÅ[É^åvéZÇa	OUT: pcmkprm.ipmaxspd, ipmaxacc,   etc	*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂçÏê¨äÌ																				*/
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{					/* à íuçÏê¨äÌÉpÉâÉÅÅ[É^ç\ë¢ëÃíËã`								*/
		LONG	osvpm;				/* ÇnÇrÉÇÅ[É^à íuéwóﬂë¨ìx				[xpulse/scan]			*/
		LONG	maxvpm;				/* ç≈ëÂÉÇÅ[É^à íuéwóﬂë¨ìx				[xpulse/scan]			*/
		LONG	maxipv;				/* ï‚ä‘ÉÇÅ[Éhç≈ëÂà íuéwóﬂë¨ìx			[xpulse/scan]			*/
		UCHAR	pshlx;				/* à íuéwóﬂââéZî{ó¶(ÉVÉtÉg)				[-]						*/
		UCHAR	pcmd64f;			/* à íuéwóﬂÇUÇSÉrÉbÉgÉtÉâÉO				[TRUE/FALSE]			*/
		USHORT	iptimes;			/* Interpolateï‚ä‘âÒêî					[-]						*/
	/*----------------------------------------------------------------------------------------------*/
		LONG	vpacc;				/* à íuéwóﬂâ¡ë¨ìx						[xpulse/scan/scan]		*/
		LONG	vpdec;				/* à íuéwóﬂå∏ë¨ìx						[xpulse/scan/scan]		*/
		LONG	vpamx;				/* è§(vpacc/vpdec)						[-]						*/
		LONG	vparx;				/* ó]ÇË(vpacc%vpdec)					[-]						*/
		LONG	vpapx;				/* â¡ë¨ï™å∏ë¨í‚é~ÉpÉãÉXó 				[xpulse]				*/
		LONG	maxspd;				/* ç≈ëÂà íuéwóﬂë¨ìx						[2^24/OvrSpd]			*/
	/*----------------------------------------------------------------------------------------------*/
		LONG	ipmaxspd;			/* ï‚ä‘ÉÇÅ[Éhç≈ëÂë¨ìx					[ipulse/IPcycle]		*/
		LONG	ipmaxacc;			/* ï‚ä‘ÉÇÅ[Éhç≈ëÂâ¡ë¨ìx(ñ¢égóp)			[ipulse/IPcycle^2]		*/
		LONG	ipstpdec;			/* ï‚ä‘ÉÇÅ[ÉhîÒèÌí‚é~å∏ë¨ìx				[ipulse/IPcycle^2]		*/
} PCMKP;
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{					/* à íuçÏê¨äÌââéZópïœêîç\ë¢ëÃíËã`								*/
		UCHAR	calendf;			/* ââéZèIóπÉtÉâÉO (ââéZíÜ:0, ââéZèIóπ:1)						*/
		UCHAR	cmderrf;			/* éwóﬂàŸèÌÉtÉâÉO (ï‚ä‘ÉÇÅ[Éhà íuéwóﬂàŸèÌ,etc)					*/
		UCHAR	pcmkmode;			/* à íuéwóﬂçÏê¨ÉÇÅ[Éh											*/
		UCHAR	modechgf;			/* à íuéwóﬂçÏê¨ÉÇÅ[ÉhïœâªÉtÉâÉO									*/
	/*----------------------------------------------------------------------------------------------*/
		LONG	vpx;				/* à íuéwóﬂë¨ìx							[xpulse/scan]			*/
		LONG	vpxrem;				/* à íuéwóﬂë¨ìxèoóÕó]ÇË					[xpulse/scan]			*/
		LONG	pcmdout[2];			/* à íuéwóﬂèoóÕê‚ëŒíl					[ipulse]				*/
		LONG	avp;				/* Work:à íuéwóﬂë¨ìxê‚ëŒíl				[xpulse/scan]			*/
		LONG	n;					/* Work:è§(avp/vpdec)					[-]						*/
		LONG	rem;				/* Work:ó]ÇË(avp%vpdec)					[-]						*/
		LONG	maxvp;				/* Work:ç≈ëÂà íuéwóﬂë¨ìx				[xpulse/scan]			*/
	/*----------------------------------------------------------------------------------------------*/
		LONG	ipvpi;				/* Interpolateà íuéwóﬂë¨ìx				[ipulse/IPcycle]		*/
		LONG	ipvpx;				/* Interpolateà íuéwóﬂë¨ìx				[ipulse/scan]			*/
		LONG	ipremi;				/* Interpolateà íuéwóﬂë¨ìxó]ÇË			[ipulse/scan]			*/
		LONG	ipremx;				/* Interpolateà íuéwóﬂë¨ìxó]ÇË			[ipulse/scan]			*/
		LONG	ipstopx[2];			/* IpWork:å∏ë¨í‚é~à íuåvéZíl			[ipulse]				*/
} PCMKV;
/*--------------------------------------------------------------------------------------------------*/
typedef	struct	{					/* à íuçÏê¨äÌââéZópïœêî(P&V)ç\ë¢ëÃíËã`							*/
		PCMKP	P;					/* ÉpÉâÉÅÅ[É^													*/
		PCMKV	V;					/* ââéZópïœêî													*/
} PCMKPV;
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂçÏê¨äÌââéZé¿çsä÷êî																	*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcmdMaker(				/* à íuéwóﬂçÏê¨äÌââéZé¿çsä÷êî									*/
		LONG	pcmdin0,			/* à íuéwóﬂì¸óÕ(â∫à 32bit)				[pulse]					*/
		LONG	pcmdin1,			/* à íuéwóﬂì¸óÕ(è„à 32bit)				[pulse]					*/
		LONG	pcmdspd,			/* à íuéwóﬂë¨ìx(ç≈ëÂÅ^ëóÇË)				[2^24/OvrSpd]			*/
		PCMKPV	*pcmdmkr,			/* à íuéwóﬂçÏê¨äÌââéZópïœêî(P&V)		[-]						*/
		ULONG	pcmkmode	);		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh					[-]						*/
/*--------------------------------------------------------------------------------------------------*/
/*		à íuéwóﬂçÏê¨ÉÇÅ[ÉhíËã`ÅFäÓñ{ÉÇÅ[ÉhÇÕÅAâ∫à ÉoÉCÉgÇ≈íËã`Ç∑ÇÈÇ±Ç∆								*/
/*--------------------------------------------------------------------------------------------------*/
#define	PCMKMODE_NONE   0x0000		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : ñ≥Çµ									*/
#define	PCMKMODE_IPA	0x0001		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : ï‚ä‘(ì¸óÕçXêVóLÇË)						*/
#define	PCMKMODE_IPB	0x0101		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : ï‚ä‘(ì¸óÕçXêVñ≥Çµ)						*/
#define	PCMKMODE_POS	0x0002		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : à íuåàÇﬂ								*/
#define	PCMKMODE_FEED	0x0003		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : íËë¨ëóÇË								*/
#define	PCMKMODE_STOP	0x0004		/* à íuéwóﬂçÏê¨ÉÇÅ[Éh : å∏ë¨í‚é~								*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibIpTposLimit(			/* ï‚ä‘à íuéwóﬂÉäÉ~ÉbÉgââéZ										*/
		LONG	*tpos,				/* ñ⁄ïWà íu(64bit)						[pulse]					*/
		LONG	*lmtpos,			/* ÉäÉ~ÉbÉgà íu(64bit)					[pulse]					*/
		LONG	lmtdir,				/* ÉäÉ~ÉbÉgï˚å¸(ê≥ë§Å^ïâë§)				[-]						*/
		PCMKPV	*pcmdmkr	);		/* à íuéwóﬂçÏê¨äÌââéZópïœêî(P&V)		[-]						*/
/*--------------------------------------------------------------------------------------------------*/
#define	IPTPOSLMT_PSIDE		1		/* ÉäÉ~ÉbÉgï˚å¸ÅFê≥ë§											*/
#define	IPTPOSLMT_NSIDE		0		/* ÉäÉ~ÉbÉgï˚å¸ÅFïâë§											*/
/*--------------------------------------------------------------------------------------------------*/
void	MlibRstPcmdMaker(			/* à íuéwóﬂçÏê¨äÌÉäÉZÉbÉgèàóù									*/
		LONG	pcmdset0,			/* à íuéwóﬂèâä˙íl(â∫à 32bit)			[pulse]					*/
		LONG	pcmdset1,			/* à íuéwóﬂèâä˙íl(è„à 32bit)			[pulse]					*/
		PCMKPV	*pcmdmkr	);		/* à íuéwóﬂçÏê¨äÌââéZópïœêî(P&V)		[-]						*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibIpcalPcmdMaker(			/* à íuéwóﬂçÏê¨äÌèâä˙ÉpÉâÉÅÅ[É^åvéZ								*/
		KSGAIN	ksosvp,				/* ÇnÇrÉpÉãÉXë¨ìx						[xpulse/scan]			*/
		LONG	maxspdm,			/* ç≈ëÂÉÇÅ[É^ë¨ìx						[2^24/OvrSpd]			*/
		LONG	maxspdi,			/* ï‚ä‘ÉÇÅ[Éhç≈ëÂë¨ìx					[2^24/OvrSpd]			*/
		LONG	pcmd64f,			/* à íuéwóﬂÇUÇSÉrÉbÉgÉtÉâÉO				[TRUE/FALSE]			*/
		PCMKP	*pcmkprm	);		/* åvéZåãâ èoóÕç\ë¢ëÃÉ|ÉCÉìÉ^			[-]						*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalaPcmdMaker(			/* à íuéwóﬂçÏê¨äÌà íuåàÇﬂÉpÉâÉÅÅ[É^åvéZÇ`						*/
		LONG	maxspd,				/* ç≈ëÂë¨ìx								[2^24/OvrSpd]			*/
		LONG	acctime,			/* â¡ë¨éûä‘								[xs]					*/
		LONG	dectime,			/* å∏ë¨éûä‘								[xs]					*/
		LONG	scantime,			/* ÉXÉLÉÉÉìÉ^ÉCÉÄ						[xs]					*/
		PCMKP	*pcmkprm	);		/* åvéZåãâ èoóÕç\ë¢ëÃÉ|ÉCÉìÉ^			[-]						*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalaPcmdMkrIP(			/* à íuéwóﬂçÏê¨äÌï‚ä‘ââéZÉpÉâÉÅÅ[É^åvéZÇ`						*/
		LONG	iptimes,			/* ï‚ä‘âÒêî								[-]						*/
		LONG	maxspd,				/* ç≈ëÂë¨ìx								[2^24/OvrSpd]			*/
		LONG	ipacctm,			/* ç≈è¨â¡å∏ë¨éûä‘(ñ¢égóp)				[xs]					*/
		LONG	ipdectm,			/* îÒèÌí‚é~å∏ë¨éûä‘						[xs]					*/
		LONG	scantime,			/* ÉXÉLÉÉÉìÉ^ÉCÉÄ						[xs]					*/
		PCMKP	*pcmkprm	);		/* åvéZåãâ èoóÕç\ë¢ëÃÉ|ÉCÉìÉ^			[-]						*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalbPcmdMaker(			/* à íuéwóﬂçÏê¨äÌà íuåàÇﬂÉpÉâÉÅÅ[É^åvéZÇa						*/
		LONG	accrate,			/* â¡ë¨ÉåÅ[Ég							[10000pulse/s/s]		*/
		LONG	decrate,			/* å∏ë¨ÉåÅ[Ég							[10000pulse/s/s]		*/
		LONG	scantime,			/* ÉXÉLÉÉÉìÉ^ÉCÉÄ(stm)					[us(Y=0)/ns(Y=1)]		*/
		PCMKP	*pcmkprm,			/* åvéZåãâ èoóÕç\ë¢ëÃÉ|ÉCÉìÉ^			[-]						*/
		LONG	insel		);		/* ì¸óÕëIë(0xYX)						[X:ïségóp, Y:us/nsëIë]	*/
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalbPcmdMkrIP(			/* à íuéwóﬂçÏê¨äÌï‚ä‘ââéZÉpÉâÉÅÅ[É^åvéZÇa						*/
		LONG	iptimes,			/* ï‚ä‘âÒêî								[-]						*/
		LONG	ipaccrt,			/* ç≈ëÂâ¡å∏ë¨ÉåÅ[Ég(ñ¢égóp)				[10000pulse/s/s]		*/
		LONG	ipdecrt,			/* îÒèÌí‚é~å∏ë¨ÉåÅ[Ég					[10000pulse/s/s]		*/
		LONG	scantime,			/* ÉXÉLÉÉÉìÉ^ÉCÉÄ(stm)					[us(Y=0)/ns(Y=1)]		*/
		PCMKP	*pcmkprm,			/* åvéZåãâ èoóÕç\ë¢ëÃÉ|ÉCÉìÉ^			[-]						*/
		LONG	insel		);		/* ì¸óÕëIë(0xYX)						[X:ïségóp, Y:us/nsëIë]	*/
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		ÉpÉâÉÅÅ[É^åvéZópä÷êî																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibPcalKxgain()    : î‰ó·ÉQÉCÉìåvéZ				{kx,sx} = (a*b/c)<<sx;					*/
/*   2) MlibPcalKskxkx()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = {ka,sa}*b/c<<sx;				*/
/*   3) MlibPcalKxkskx()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = a*{kb,sb}/c<<sx;				*/
/*   4) MlibPcalKxkxks()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = a*b/{kc,sc}<<sx;				*/
/*   5) MlibPcalKskskx()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = {ka,sa}*{kb,sb}/c<<sx;		*/
/*   6) MlibPcalKxksks()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = a*{kb,sb}/{kc,sc}<<sx;		*/
/*   7) MlibPcalKsksks()    : ägí£ÉQÉCÉìåvéZ				{kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;	*/
/*--------------------------------------------------------------------------------------------------*/
/*   8) MlibScalKxgain()    : î‰ó·ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = (a*b/c)<<sx; (éwêîèâä˙âªïsóv)	*/
/*   9) MlibScalKskxkx()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = {ka,sa}*b/c<<sx;				*/
/*  10) MlibScalKxkskx()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = a*{kb,sb}/c<<sx;				*/
/*  11) MlibScalKxkxks()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = a*b/{kc,sc}<<sx;				*/
/*  12) MlibScalKskskx()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = {ka,sa}*{kb,sb}/c<<sx;		*/
/*  13) MlibScalKxksks()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = a*{kb,sb}/{kc,sc}<<sx;		*/
/*  14) MlibScalKsksks()    : ägí£ÉQÉCÉìåvéZ(åvéZäJénóp)	{kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;	*/
/*--------------------------------------------------------------------------------------------------*/
/*  15) MlibPcalKxaddx()    : î‰ó·ÉQÉCÉìâ¡éZ				{kx,sx} = {ka,sa}+{kb,sb};				*/
/*  16) MlibPcalKxsubx()    : î‰ó·ÉQÉCÉìå∏éZ				{kx,sx} = {ka,sa}-{kb,sb};				*/
/*  17) MlibPcalKxmulx()    : î‰ó·ÉQÉCÉìèÊéZ				{kx,sx} = (a*b*c)<<sx;					*/
/*  18) MlibPcalKxdivx()    : î‰ó·ÉQÉCÉìèúéZ				{kx,sx} = {ka,sa}/{kb,sb};				*/
/*--------------------------------------------------------------------------------------------------*/
/*  19) MlibPcalKf1gain()   : ÇPéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ		{kf,24} = (ts/(tx+ts))<<24;				*/
/*  19-2) FlibPcalKf1gain()   : ÇPéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ		{kf} = (ts/(tx+ts));					*//*<S00A>*/
/*  20) MlibPcalKf2gain()   : ÇQéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ		OUT: kf[0], kf[1]						*/
/*  20-2) FlibPcalKf2gain()   : ÇQéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ		OUT: kf[0], kf[1]						*//*<S00A>*/
/*  21) MlibPcalKnf2gain()  : ÇQéüÉmÉbÉ`ÉtÉBÉãÉ^ÉQÉCÉìåvéZ	OUT: kf[0], kf[1], kf[2]				*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxgain( LONG a,   LONG b,   LONG c,   LONG *psx, LONG smax );
LONG	MlibPcalKskxkx( LONG ksa, LONG b,   LONG c,   LONG *psx, LONG smax );
LONG	MlibPcalKxkskx( LONG a,   LONG ksb, LONG c,   LONG *psx, LONG smax );
LONG	MlibPcalKxkxks( LONG a,   LONG b,   LONG ksc, LONG *psx, LONG smax );
LONG	MlibPcalKskskx( LONG ksa, LONG ksb, LONG c,   LONG *psx, LONG smax );
LONG	MlibPcalKxksks( LONG a,   LONG ksb, LONG ksc, LONG *psx, LONG smax );
LONG	MlibPcalKsksks( LONG ksa, LONG ksb, LONG ksc, LONG *psx, LONG smax );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibScalKxgain( LONG a,   LONG b,   LONG c,   LONG *psx, LONG smax );
LONG	MlibScalKskxkx( LONG ksa, LONG b,   LONG c,   LONG *psx, LONG smax );
LONG	MlibScalKxkskx( LONG a,   LONG ksb, LONG c,   LONG *psx, LONG smax );
LONG	MlibScalKxkxks( LONG a,   LONG b,   LONG ksc, LONG *psx, LONG smax );
LONG	MlibScalKskskx( LONG ksa, LONG ksb, LONG c,   LONG *psx, LONG smax );
LONG	MlibScalKxksks( LONG a,   LONG ksb, LONG ksc, LONG *psx, LONG smax );
LONG	MlibScalKsksks( LONG ksa, LONG ksb, LONG ksc, LONG *psx, LONG smax );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalKxaddx( LONG ka,  LONG sa,  LONG kb,  LONG sb,   LONG *psx );
LONG	MlibPcalKxsubx( LONG ka,  LONG sa,  LONG kb,  LONG sb,   LONG *psx );
LONG	MlibPcalKxmulx( LONG a,   LONG b,   LONG c,   LONG *psx            );
LONG	MlibPcalKxdivx( LONG ka,  LONG sa,  LONG kb,  LONG sb,   LONG smax );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibPcalKf1gain(			/* ÇPéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ										*/
		LONG	tx,					/* éûíËêî(Tx)/é¸îgêî(Fx)	[xs],[0.1Hz] (X=0:Tx, X=1:Fx)		*/
		LONG	ts,					/* ÉXÉLÉÉÉìÉ^ÉCÉÄ			[xs],[us/ns] (Y=0:us, Y=1:ns)		*/
		LONG	insel	);			/* ì¸óÕëIë(0xYX)			[X:Tx/FxëIë, Y:us/nsëIë]			*/

#if (FLOAT_USE==TRUE)
float	FlibPcalKf1gain(		/* ÇPéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ										*/
		LONG	tx,				/* éûíËêî(Tx)/é¸îgêî(Fx)	[sec],[Hz] (X=0:Tx, X=1:Fx)			*/
		LONG	ts,				/* ââéZé¸ä˙					[sec] 								*/
		LONG	insel	);			/* ì¸óÕéwíË(0x0X)			[X:Tx/FxëIë]						*/
#endif /* FLOAT_USE */

/*--------------------------------------------------------------------------------------------------*/
void	MlibPcalKf2gain(			/* ÇQéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ										*/
		LONG	hz,					/* ÉtÉBÉãÉ^é¸îgêî			[0.1Hz]								*/
		LONG	dx,					/* ÉtÉBÉãÉ^å∏êäåWêî			[0.001]								*/
		LONG	ts,					/* ÉXÉLÉÉÉìÉ^ÉCÉÄ			[us/ns]	(Y=0:us, Y=1:ns)			*/
		LONG	kf[2],				/* åvéZåãâ äiî[É|ÉCÉìÉ^		[--]								*/
		LONG	insel	);			/* ì¸óÕëIë(0xYX) 			[X:ïségóp, Y:us/nsëIë]				*/
#if (FLOAT_USE==TRUE)
void	FlibPcalKf2gain(			/* ÇQéüÉtÉBÉãÉ^ÉQÉCÉìåvéZ										*/
		float	hz,				/* ÉtÉBÉãÉ^é¸îgêî			[Hz]								*/
		float	dx,				/* ÉtÉBÉãÉ^å∏êäåWêî(Éƒ)		[-]									*/
		float	ts,				/* ÉXÉLÉÉÉìÉ^ÉCÉÄ			[sec]								*/
		float	kf[2]);			/* åvéZåãâ äiî[É|ÉCÉìÉ^		[--]								*/
#endif /* FLOAT_USE */
/*--------------------------------------------------------------------------------------------------*/
void	MlibPcalKnf2gain(			/* ÇQéüÉmÉbÉ`ÉtÉBÉãÉ^ÉQÉCÉìåvéZ									*/
		LONG	hz,					/* ÉtÉBÉãÉ^é¸îgêî			[0.1Hz]								*/
		LONG	qx,					/* ÇpíËêî(Qx)/å∏êäåWêî(Dx)	[0.001]	(X=0:Qx, X=1:Dx)			*/
		LONG	kn,					/* ÉmÉbÉ`ê[Ç≥ÉQÉCÉì			[0.001]								*/
		LONG	ts,					/* ÉXÉLÉÉÉìÉ^ÉCÉÄ			[us/ns] (Y=0:us, Y=1:ns)			*/
		LONG	kf[3],				/* åvéZåãâ äiî[É|ÉCÉìÉ^		[--]								*/
		LONG	insel	);			/* ì¸óÕëIë(0xYX)			[X:Qx/DxëIë, Y:us/nsëIë]			*/
// <V069> Change Start
/*--------------------------------------------------------------------------------------------------*/
/*		ÉQÉCÉìëÄçÏÉ}ÉNÉç																				*/
/*--------------------------------------------------------------------------------------------------*/
/*			Little Endian óp																			*/
#define	MlibGAINKX( k )		((LONG)((k)<<8)>>8)
#define	MlibGAINSX( k )		(((CHAR*)&(k))[3])
/*--------------------------------------------------------------------------------------------------*/
/*			êÿÇËéÃÇƒ óp																				*/
#define	MlibGAINRD( k )		(MlibGAINKX( k ) >> ((LONG) ((ULONG) (k)>>24)))
/*--------------------------------------------------------------------------------------------------*/
// <V069> Change End



/****************************************************************************************************/
/*																									*/
/*		äÓñ{êîílââéZä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibAbs32()         : ê‚ëŒíl(32bit)															*/
/*   2) MlibAdd6432()       : â¡éZ(ïÑçÜït,64bit+32bit)												*/
/*   3) MlibAdd6464()       : â¡éZ(ïÑçÜït,64bit+64bit)												*/
/*   4)	MlibSub6432()       : å∏éZ(ïÑçÜït,64bit-32bit)												*/
/*   5)	MlibSub6464()       : å∏éZ(ïÑçÜït,64bit-64bit)												*/
/*   6) MlibErr6464()       : ïŒç∑(ïÑçÜït,64bit-64bit,ñﬂÇËílñOòaã@î\ïtÇ´)							*/
/*   7) MlibSatAdd24()      : ñOòaâ¡éZ(ïÑçÜït,32bit+32bit,Limit:0x01000000,0xFF000000)				*/
/*   8) MlibSatAdd28()      : ñOòaâ¡éZ(ïÑçÜït,32bit+32bit,Limit:0x10000000,0xF0000000)				*/
/*   9) MlibSatAdd32()      : ñOòaâ¡éZ(ïÑçÜït,32bit+32bit,Limit:0x7FFFFFFF,0x80000000)				*/
/*  10) MlibSatAddu32()     : ñOòaâ¡éZ(ïÑçÜñ≥,32bit+32bit,Limit:0xFFFFFFFF)							*/
/*  11) MlibMul3232()       : èÊéZ(ïÑçÜït,32bit*32bit)												*/
/*  12) MlibMulu32u32()     : èÊéZ(ïÑçÜñ≥,32bit*32bit)												*/
/*  13) MlibMulhigh32()     : èÊéZ(ïÑçÜït,32bit*32bit,ñﬂÇËíl:è„à 32bit,éléÃå‹ì¸)					*/
/*  14) MlibMulhighu32()    : èÊéZ(ïÑçÜñ≥,32bit*32bit,ñﬂÇËíl:è„à 32bit,éléÃå‹ì¸)					*/
/*  15) MlibDivhrem()       : èúéZ(ïÑçÜït,32bit/16bit,èoóÕ:è§Åïó]ÇË)								*/
/*  16) MlibDiv6432()       : èúéZ(ïÑçÜït,32bit*32bit/32bit,Limit:0x7FFFFFFF,éléÃå‹ì¸)				*/
/*  17) MlibDivx3232()      : ägí£èúéZ((32bit<<sx)/32bit,Limit:(qmax<<sx))							*/
/*  18) MlibSqrtu32()       : ÉãÅ[ÉgââéZ(ì¸óÕ:32bit, èoóÕ:16bit(Max.0xFFFF),éléÃå‹ì¸)				*/
/*  19) MlibSqrtu64()       : ÉãÅ[ÉgââéZ(ì¸óÕ:64bit, èoóÕ:32bit(Max.0xFFFFFFFF),éléÃå‹ì¸)			*/
/*  20) MlibSqrtu32u32()    : ÉãÅ[ÉgââéZ(ì¸óÕ:32bit*32bit, èoóÕ:32bit(Max.0xFFFFFFFF),éléÃå‹ì¸)		*/
/*  21) MlibSins16()        : ÇrÇâÇéââéZ(ì¸óÕ:[0.1deg],[360/16384deg],èoóÕ:[1.0/10000],[1.0/16384])	*/
/*	22) MlibAbsErrchk32()   : ê‚ëŒílïŒç∑É`ÉFÉbÉN(rv=(|a32-b32|<=chk32))								*/
/*	23) MlibAbsErrchk64()   : ê‚ëŒílïŒç∑É`ÉFÉbÉN(rv=(|a64-b64|<=chk32))								*/
/*																									*/
/****************************************************************************************************/
//LONG	MlibAbs32( LONG u );
//void	MlibAdd6432( LONG *a, LONG  b, LONG *x );
//void	MlibAdd6464( LONG *a, LONG *b, LONG *x );
/*--------------------------------------------------------------------------------------------------*/
//void	MlibSub6432( LONG *a, LONG  b, LONG *x );
//void	MlibSub6464( LONG *a, LONG *b, LONG *x );
LONG	MlibErr6464( LONG *a, LONG *b );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibSatAdd24( LONG a, LONG b );
LONG	MlibSatAdd28( LONG a, LONG b );
KSGAIN	MlibSatAdd32( KSGAIN a, KSGAIN b );		/*<S00A>*/
ULONG	MlibSatAddu32( ULONG a, ULONG b );
/*--------------------------------------------------------------------------------------------------*/
//void	MlibMul3232( LONG a, LONG b, LONG *x );
//void	MlibMulu32u32( ULONG a, ULONG b, ULONG *x );
//LONG	MlibMulhigh32( LONG a, LONG b );
//ULONG	MlibMulhighu32( ULONG a, ULONG b );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibDivhrem( LONG u, SHORT k, SHORT *rem );
LONG	MlibDiv6432( LONG a, LONG b, LONG c );
LONG	MlibDivx3232( LONG a, LONG b, LONG qmax, LONG sx );
/*--------------------------------------------------------------------------------------------------*/
USHORT	MlibSqrtu32( ULONG a );
ULONG	MlibSqrtu64( ULONG a0, ULONG a1 );
ULONG	MlibSqrtu32u32( ULONG a, ULONG b );
LONG	MlibSins16( LONG a, LONG unit );
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibAbsErrchk32( LONG  a32, LONG  b32, LONG chk32 );
LONG	MlibAbsErrchk64( LONG *a64, LONG *b64, LONG chk32 );
/*--------------------------------------------------------------------------------------------------*/
#define	MlibAdd6464( a, b, xx )		ADD6464( a, b, xx )
#define	MlibSub6464( a, b, xx )		SUB6464( a, b, xx )
#define	MlibMul3232( a, b, xx )		MUL3232( a, b, xx )
#define	MlibMulu32u32( a, b, xx )	MULU32U32( a, b, xx )



/****************************************************************************************************/
/*																									*/
/*		ì¡éÍââéZèàóùä÷êî																			*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*   1) MlibSrhbiton()      : ÉTÅ[É`ÉrÉbÉgÇnÇm(LSB/MSBÇ©ÇÁÉTÅ[É`, ñﬂÇËíl:BitNo/NG(-1))				*/
/*	 2) MlibSetCRC16()		: ÇbÇqÇbÇPÇUÇÃê›íË(MEMOBUSóp),		ñﬂÇËíl:ñ≥Çµ							*/
/*	 3) MlibChkCRC16()		: ÇbÇqÇbÇPÇUÇÃÉ`ÉFÉbÉN(MEMOBUSóp),	ñﬂÇËíl:TRUE(ê≥èÌ)/FALSE(àŸèÌ)		*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSrhbiton( ULONG data, ULONG dir );
#define	SRH_FROM_LSB	0
#define	SRH_FROM_MSB	1
/*--------------------------------------------------------------------------------------------------*/
#define MlibSetCRC16( Dbuf, Length) MlibSetCRC16MB( Dbuf, Length )
#define MlibChkCRC16( Dbuf, Length) MlibChkCRC16MB( Dbuf, Length )
/*--------------------------------------------------------------------------------------------------*/
void	MlibSetCRC16MB( UCHAR *MsgBuf, LONG MsgLen );
LONG	MlibChkCRC16MB( UCHAR *MsgBuf, LONG MsgLen );
/*--------------------------------------------------------------------------------------------------*/
void	MlibSetSum16SM( UCHAR *MsgBuf, LONG MsgLen );		/* for Sigma Message */
LONG	MlibChkSum16SM( UCHAR *MsgBuf, LONG MsgLen );		/* for Sigma Message */
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibCheckPowerOf2(							/* ÇQÇÃó›èÊÉ`ÉFÉbÉN : rv = BitNo/NG(-1)			*/
			ULONG	x 			);					/* É`ÉFÉbÉNÉfÅ[É^								*/
/*--------------------------------------------------------------------------------------------------*/


/****************************************************************************************************/
/*																									*/
/*		ÉÅÉÇÉäÉäÉZÉbÉgä÷êî																			*/
/*																									*/
/****************************************************************************************************/
void	MlibResetByteMemory(						/* ÉoÉCÉgÉÅÉÇÉäÉäÉZÉbÉg							*/
			void	*pRstMem,						/* ÉäÉZÉbÉgÉÅÉÇÉäêÊì™É|ÉCÉìÉ^					*/
			LONG	ByteNum		);					/* ÉäÉZÉbÉgÉÅÉÇÉäÉoÉCÉgêî						*/
/*--------------------------------------------------------------------------------------------------*/
void	MlibResetLongMemory(						/* ÉçÉìÉOÉÅÉÇÉäÉäÉZÉbÉg							*/
			void	*pRstMem,						/* ÉäÉZÉbÉgÉÅÉÇÉäêÊì™É|ÉCÉìÉ^					*/
			LONG	LwdNum		);					/* ÉäÉZÉbÉgÉÅÉÇÉäÉçÉìÉOÉèÅ[Éhêî					*/
/*--------------------------------------------------------------------------------------------------*/
void	MlibCopyByteMemory(							/* ÉoÉCÉgÉÅÉÇÉäÉRÉsÅ[							*/
			void		*pDesMem,					/* ÉRÉsÅ[êÊ										*/
			const void	*pSrcMem,					/* ÉRÉsÅ[å≥										*/
			INT			ByteNum	);					/* ÉRÉsÅ[ÉoÉCÉgêî								*/
/*--------------------------------------------------------------------------------------------------*/
void	MlibCopyLongMemory(							/* ÉçÉìÉOÉÅÉÇÉäÉRÉsÅ[							*/
			void	*dstMem,						/* ÉRÉsÅ[êÊ										*/
			void	*srcMem,						/* ÉRÉsÅ[å≥										*/
			INT		nbyte );						/* ÉRÉsÅ[ÉoÉCÉgêî								*/
/*--------------------------------------------------------------------------------------------------*/
void	memcpy( void*, void*, UINT );				/* ÉoÉCÉgÉÅÉÇÉäÉRÉsÅ[							*/

/****************************************************************************************************/
/*																									*/
/*		ÇªÇÃëº																			*/
/*																									*/
/****************************************************************************************************/
/*		éwêîílÇÃåvéZ : 10^exp																		*/
LONG	MlibExpCal( CHAR exp );
#if (FLOAT_USE==TRUE)
void	FlibExpCal( CHAR exp, float *output );
#endif /* FLOAT_USE */
/*		KSGAIN Å® LONG Data ïœä∑																	*/
LONG	MlibKsgain2Long( KSGAIN Input );

extern const	UCHAR	MlibAsciiTbl[ ];
extern const	UCHAR	MlibEvenAsciiTbl[ ]; 					/*<S02D>*/

/*--------------------------------------------------------------------------------------------------*/
/*		ÇPÇOêió›èÊÉeÅ[ÉuÉã(Decimal Power Table)														*/
/*--------------------------------------------------------------------------------------------------*/
extern const ULONG MlibDecPowerTbl[];




#define MLIB_H_
#endif /* MLIB_H_ */
/***************************************** end of file **********************************************/


