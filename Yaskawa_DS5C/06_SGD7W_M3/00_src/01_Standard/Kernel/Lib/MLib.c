/****************************************************************************************************/
/*																									*/
/*																									*/
/*		Mlib85E.c : 制御演算ライブラリ (Ｃ言語版)													*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*   1. 基本制御演算関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibLimitul()       : 上下限リミット				rv=リミット値;							*/
/*   2) MlibMulgain()       : ゲイン乗算					rv=(kx*u)>>sx; smax=24					*/
/*   3) MlibMulgain29()     : ゲイン乗算(Limit拡張)			rv=(kx*u)>>sx; smax=24					*/
/*   4) MlibMulgain30()     : ゲイン乗算(Limit拡張)			rv=(kx*u)>>sx; smax=24					*/
/*   5) MlibMulgain32()     : ゲイン乗算(Limit拡張)			rv=(kx*u)>>sx; smax=24  				*/
/*   6) MlibMulgainSx48()   : ゲイン乗算(smax拡大) 			rv=(kx*u)>>sx; smax=48					*/
/*   7) MlibMulgainNolim()  : ゲイン乗算(Limit無し)			rv=(kx*u)>>sx; smax=24					*/
/*   8) MlibIntegral()      : 積分演算						rv=(iu[1]>>1);iu[]=iu[]+kx*u;			*/
/*   8-2) FlibIntegral()    : 積分演算						rv=iu; iu+=kx*u;						*//*<S00A>*/
/*   9) MlibPfbkxremLim()   : 余り付き位置ＦＢ計算			rv=(kx*u+pfbrem)>>sx;					*/
/*  10) MlibPfbkxremNolim() : 余り付き位置ＦＢ計算			rv=(kx*u+pfbrem)>>sx;					*/
/*  11) MlibMulkprem()      : 余り付き位置ゲイン乗算		rv=(kx*u-((kx*pfbrem)>>24))>>sx;		*/
/*  12) MlibMulkxBiasrem()  : バイアス余り付きゲイン乗算	rv=(kx*u+rem+(sign(u)*bias>>s))>>sx;	*/
/*  13) MlibSymMulgain()    : ゲイン乗算(正負対称四捨五入)	rv=(kx*u)>>sx; smax=24					*/
/*  14) MlibSymMulgainNolim : ゲイン乗算(正負対称四捨五入)	rv=(kx*u)>>sx; smax=24					*/
/*  15) MlibSymIntegral()   : 積分演算(正負対称四捨五入)	rv=(iu[1]>>1);iu[]=iu[]+kx*u;			*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   2. フィルタ演算関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibLpfilter1()     : １次ローパスフィルタ			rv=x+((kx*(u-x))>>24);					*/
/*   1-2) FlibLpfilter1()     : １次ローパスフィルタ			rv=x+((kx*(u-x))>>24);					*//*<S00A>*/
/*   2) MlibHpfilter1()     : １次ハイパスフィルタ			rv=u-z; z=z+((kx*(u-z))>>24);			*/
/*   2-2) FlibHpfilter1()   : １次ハイパスフィルタ			rv=u-z; z=z+(kx*(u-z));					*//*<S00A>*/
/*   3) MlibLpfilter2()     : ２次ローパスフィルタ			rv=(z[2]>>1);							*/
/*   4) MlibNxfilter2()     : ２次ノッチフィルタ			rv=k[2]*(u-(z[2]>>1)-z[0])+(z[2]>>1);	*/
/*   5) MlibLaufilter()     : 直線加速器(LAU)フィルタ		rv= z + dz or rv= z - dz;				*/
/*   6) MlibBITFILTER1()    : １回遅れビットフィルタ		out = f( out, oldin, newin )			*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   3. 制御パラメータ計算用関数																	*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibPcalKxgain()    : 比例ゲイン計算				{kx,sx} = (a*b/c)<<sx;					*/
/*   2) MlibPcalKskxkx()    : 拡張ゲイン計算				{kx,sx} = {ka,sa}*b/c<<sx;				*/
/*   3) MlibPcalKxkskx()    : 拡張ゲイン計算				{kx,sx} = a*{kb,sb}/c<<sx;				*/
/*   4) MlibPcalKxkxks()    : 拡張ゲイン計算				{kx,sx} = a*b/{kc,sc}<<sx;				*/
/*   5) MlibPcalKskskx()    : 拡張ゲイン計算				{kx,sx} = {ka,sa}*{kb,sb}/c<<sx;		*/
/*   6) MlibPcalKxksks()    : 拡張ゲイン計算				{kx,sx} = a*{kb,sb}/{kc,sc}<<sx;		*/
/*   7) MlibPcalKsksks()    : 拡張ゲイン計算				{kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;	*/
/*--------------------------------------------------------------------------------------------------*/
/*   8) MlibScalKxgain()    : 比例ゲイン計算(計算開始用)	{kx,sx} = (a*b/c)<<sx; (指数初期化不要)	*/
/*   9) MlibScalKskxkx()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = {ka,sa}*b/c<<sx;				*/
/*  10) MlibScalKxkskx()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = a*{kb,sb}/c<<sx;				*/
/*  11) MlibScalKxkxks()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = a*b/{kc,sc}<<sx;				*/
/*  12) MlibScalKskskx()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = {ka,sa}*{kb,sb}/c<<sx;		*/
/*  13) MlibScalKxksks()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = a*{kb,sb}/{kc,sc}<<sx;		*/
/*  14) MlibScalKsksks()    : 拡張ゲイン計算(計算開始用)	{kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;	*/
/*--------------------------------------------------------------------------------------------------*/
/*  15) MlibPcalKxaddx()    : 比例ゲイン加算				{kx,sx} = {ka,sa}+{kb,sb};				*/
/*  16) MlibPcalKxsubx()    : 比例ゲイン減算				{kx,sx} = {ka,sa}-{kb,sb};				*/
/*  17) MlibPcalKxmulx()    : 比例ゲイン乗算				{kx,sx} = (a*b*c)<<sx;					*/
/*  18) MlibPcalKxdivx()    : 比例ゲイン除算				{kx,sx} = {ka,sa}/{kb,sb};				*/
/*--------------------------------------------------------------------------------------------------*/
/*  19) MlibPcalKf1gain()   : １次フィルタゲイン計算		{kf,24} = (ts/(tx+ts))<<24;				*/
/*  19-2) FlibPcalKf1gain()   : １次フィルタゲイン計算		{kf} = (ts/(tx+ts));					*//*<S00A>*/
/*  20) MlibPcalKf2gain()   : ２次フィルタゲイン計算		OUT: kf[0], kf[1]						*/
/*  20-2) FlibPcalKf2gain()   : ２次フィルタゲイン計算		OUT: kf[0], kf[1]						*//*<S00A>*/
/*  21) MlibPcalKnf2gain()  : ２次ノッチフィルタゲイン計算	OUT: kf[0], kf[1], kf[2]				*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   4. 位置関連演算関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibPcmdIpfil()     : 位置指令補間フィルタ			rv=(pcmdin+rem)/n						*/
/*   2) MlibPcmdMafil()     : 位置指令移動平均フィルタ		rv=sum/n, sum=sum+pcmdin-pmafbuf[idx]	*/
/*   3) MlibPcmdMafilSec()  : 位置指令移動平均フィルタ2		rv=sum/n, sum=sum+pcmdin-pmafbuf[idx]	*//*<S0C3>*/
/*   4) MlibPcmdImafil()    : 位置補間移動平均フィルタ		rv=sum/n, sum=sum+newpcmd/n-oldpcmd/n	*/
/*   5) MlibPcmdImafilSec() : 位置補間移動平均フィルタ2		rv=sum/n, sum=sum+newpcmd/n-oldpcmd/n	*//*<S0C3>*/
/*   6) MlibPcmdExpfil()    : 位置指令指数加減速フィルタ	rv=sum*kexp, sum=sum+pcmdin-rv			*/
/*   7) MlibPcmdLpfil1()    : 位置指令１次ローパスフィルタ	rv=z*kf, z=z+pcmdin-rv					*/
/*   8) MlibPcmdLpfil2()    : 位置指令２次ローパスフィルタ	rv=z[1]*kf1, z[0]=z[0]+pcmdin-rv		*/
/*   8-2) FlibPcmdLpfil2()  : 位置指令２次ローパスフィルタ	rv=z[1]*kf1, z[0]=z[0]+pcmdin-rv		*//*<S00A>*/
/*   9) MlibPcmdNxfil2()    : 位置指令２次ノッチフィルタ	rv=pcmdin - Delta(kf2*z[1])				*/
/*  10) MlibPcmdEgear()     : 位置指令電子ギヤ計算			rv=(B/A)*pcmda							*/
/*  10-2) FlibPcmdEgear()   : 位置指令電子ギヤ計算			rv=(B/A)*pcmda							*//*<S00A>*/
/*  11) MlibEgearRvscnv()   : 電子ギヤ逆変換計算			rv=(A/B)*inpls							*/
/*  12) MlibPcalKegear()    : 電子ギヤパラメータ計算 		OUT: egear.k1, egear.k2, etc			*/
/*  13) MlibPerrcala()      : 位置偏差計算Ａ(指令単位)		OUT: perra.per32s, perra.per32a, etc	*/
/*  13-2) FlibPerrcala()    : 位置偏差計算Ａ(指令単位)		OUT: perra.per32s, perra.per32a, etc	*//*<S00A>*/
/*  14) MlibPerrcalx()      : 位置偏差計算Ｘ(ＦＢ単位)		rv=per64[0]; per64[]=per64[]+pcmd-pfbk;	*/
/*  14-2) FlibPerrcalx()    : 位置偏差計算Ｘ(ＦＢ単位)		rv=per64[0]; per64[]=per64[]+pcmd-pfbk;	*//*<S00A>*/
/*  15) MlibAposRg64iv()    : 初期絶対位置計算(逆電子ギヤ)	OUT: aposrg.apos[],aposrem,etc			*/
/*	16) MlibAposRg64dp()    : 絶対位置更新計算(逆電子ギヤ)	OUT: aposrg.apos[],aposrem,etc			*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   5. 位置指令作成器関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibPcmdMaker()     : 位置指令作成器(64bit)			rv=vp, vp=vp+vpacc/vp=vp-vpdec			*/
/*   2) MlibIpTposLimit()   : 同上補間位置指令リミット		rv=TRUE(Limit)/FALSE(NotLimit)			*/
/*   3) MlibRstPcmdMaker()  : 同上リセット処理				pcmdout[]=pcmdset0,pcmdset1,etc			*/
/*   4) MlibIpcalPcmdMaker  : 同上初期パラメータ計算		OUT: pcmkprm.osvpm, maxvpm, pshlx, etc	*/
/*   5) MlibPcalaPcmdMaker  : 同上位置決めパラメータ計算Ａ	OUT: pcmkprm.vpacc, vpdec,  vpamx, etc	*/
/*   6) MlibPcalaPcmdMkrIP  : 同上補間演算パラメータ計算Ａ	OUT: pcmkprm.ipmaxspd, ipmaxacc,   etc	*/
/*   7) MlibPcalbPcmdMaker  : 同上位置決めパラメータ計算Ｂ	OUT: pcmkprm.vpacc, vpdec,  vpamx, etc	*/
/*   8) MlibPcalbPcmdMkrIP  : 同上補間演算パラメータ計算Ｂ	OUT: pcmkprm.ipmaxspd, ipmaxacc,   etc	*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   6. 基本数値演算関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibAbs32()         : 絶対値(32bit)															*/
/*   2) MlibAdd6432()       : 加算(符号付,64bit+32bit)												*/
/*   3) MlibAdd6464()       : 加算(符号付,64bit+64bit)												*/
/*   4)	MlibSub6432()       : 減算(符号付,64bit-32bit)												*/
/*   5)	MlibSub6464()       : 減算(符号付,64bit-64bit)												*/
/*   6) MlibErr6464()       : 偏差(符号付,64bit-64bit,戻り値飽和機能付き)							*/
/*   7) MlibSatAdd24()      : 飽和加算(符号付,32bit+32bit,Limit:0x01000000,0xFF000000)				*/
/*   8) MlibSatAdd28()      : 飽和加算(符号付,32bit+32bit,Limit:0x10000000,0xF0000000)				*/
/*   9) MlibSatAdd32()      : 飽和加算(符号付,32bit+32bit,Limit:0x7FFFFFFF,0x80000000)				*/
/*  10) MlibSatAddu32()     : 飽和加算(符号無,32bit+32bit,Limit:0xFFFFFFFF)							*/
/*  11) MlibMul3232()       : 乗算(符号付,32bit*32bit)												*/
/*  12) MlibMulu32u32()     : 乗算(符号無,32bit*32bit)												*/
/*  13) MlibMulhigh32()     : 乗算(符号付,32bit*32bit,戻り値:上位32bit)								*/
/*  14) MlibMulhighu32()    : 乗算(符号無,32bit*32bit,戻り値:上位32bit)								*/
/*  15) MlibDivhrem()       : 除算(符号付,32bit/16bit,出力:商＆余り)								*/
/*  16) MlibDiv6432()       : 除算(符号付,32bit*32bit/32bit,Limit:0x7FFFFFFF)						*/
/*  17) MlibDivx3232()      : 拡張除算((32bit<<sx)/32bit,Limit:(qmax<<sx))							*/
/*  18) MlibSqrtu32()       : ルート演算(入力:32bit, 出力:16bit(Max.0xFFFF), 四捨五入)				*/
/*  19) MlibSqrtu64()       : ルート演算(入力:64bit, 出力:32bit(Max.0xFFFFFFFF), 四捨五入)			*/
/*  20) MlibSqrtu32u32()    : ルート演算(入力:32bit*32bit, 出力:32bit(Max.0xFFFFFFFF), 四捨五入)	*/
/*  21) MlibSins16()        : Ｓｉｎ演算(入力:[0.1deg],[360/16384deg],出力:[1.0/10000],[1.0/16384])	*/
/*	22) MlibAbsErrchk32()   : 絶対値偏差チェック(rv=(|a32-b32|<=chk32))								*/
/*	23) MlibAbsErrchk64()   : 絶対値偏差チェック(rv=(|a64-b64|<=chk32))								*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   7. 特殊演算処理関数																			*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibSrhbiton()      : サーチビットＯＮ(LSB/MSBからサーチ, 戻り値:BitNo/NG(-1))				*/
/*	 2) MlibSetCRC16MB()	: ＣＲＣ１６の設定(MEMOBUS用),		戻り値:無し							*/
/*	 3) MlibChkCRC16MB()	: ＣＲＣ１６のチェック(MEMOBUS用),	戻り値:TRUE(正常)/FALSE(異常)		*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   8. メモリ操作関数																				*/
/*--------------------------------------------------------------------------------------------------*/
/*	 1) MlibResetByteMemory() : バイトメモリリセット関数											*/
/*	 2) MlibResetLongMemory() : ロングメモリリセット関数											*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*   9. 基本制御演算関数(固定小数点ゲイン版,SH2用)													*/
/*--------------------------------------------------------------------------------------------------*/
/*   1) MlibHsMulgain()       : ゲイン乗算					rv=(kx*u)>>16; sx=16					*/
/*   2) MlibHsMulgainNolim()  : ゲイン乗算(Limit無し)		rv=(kx*u)>>16; sx=16					*/
/*   3) MlibHsIntegral()      : 積分演算					rv=(iu[1]>>1);iu[]=iu[]+kx*u;			*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*  10. Ｃ言語版関数(ＡＳＭ版関数無し)																*/
/*--------------------------------------------------------------------------------------------------*/
/*	 1) MlibCheckPowerOf2()   : ２の累乗チェック			rv = BitNo/NG(-1)						*/
/*   2) MlibCopyByteMemory()  : バイトメモリコピー			戻り値:無し								*/
/*   3) MlibCopyLongMemory()  : ロングメモリコピー			戻り値:無し								*/
/*	 4) Other																						*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*  11. その他(旧仕様ライブラリ関数等)																*/
/*--------------------------------------------------------------------------------------------------*/
/*	 1)	MlibSgdsPcmdLau()     : 位置指令作成器(SGDS版)		rv=vp, vp=vp+vpacc/vp=vp-vpdec			*/
/*   2) MlibSgdsXxxxxxx()     : 同上関連処理関数(SGDS版)											*/
/*	 3) Other Functions		  : その他関数															*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
/*  Note: ライブラリ関数名補足																		*/
/*--------------------------------------------------------------------------------------------------*/
/*	 1) ＡＳＭ版関数名 : MlibLimitul(), MlibMulgain(), MlibXxxxxYyyyy(), etc						*/
/*	 2) Ｃ言語版関数名 : MlibLimitul(), MlibMulgain(), MlibXxxxxYyyyy(), etc						*/
/*																									*/
/*																									*/
/************** Copyright (C) Yaskawa Electric Corporation ******************************************/
/*																									*/
/*		初版   : 2000.01.14  T.Taniguchi	Mlib85E.c												*/
/*		統合版 : 2005.05.27  T.Taniguchi	Mlib85E.c/MlibSH2.cをベースに統合版作成					*/
/*		改版01 : 2005.08.04	 T.Taniguchi	ソース整理												*/
/*																									*/
/*																									*/
/*																									*/
/****************************************************************************************************/
#include	"Basedef.h"
#include	"MLib.h"
#include	<math.h>



/****************************************************************************************************/
/*																									*/
/*		符号無し３２bitスケーリングアップ／ダウンマクロ												*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		SCUP31_SXINC( ) : x = (x<<sx), s = (s+sx),  0x40000000 <= x < 0x80000000					*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCUP31_SXINC( x, s, wk )\
		wk=0x00008000; if( (ULONG)x <  (ULONG)wk ){ x=(x<<16); s=s+16;}\
		wk=(wk<<8)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 8); s=s+ 8;}\
		wk=(wk<<4)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 4); s=s+ 4;}\
		wk=(wk<<2)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 2); s=s+ 2;}\
		wk=(wk<<1)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 1); s=s+ 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCUP31_SXDEC( ) : x = (x<<sx), s = (s-sx),  0x40000000 <= x < 0x80000000					*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCUP31_SXDEC( x, s, wk )\
		wk=0x00008000; if( (ULONG)x <  (ULONG)wk ){ x=(x<<16); s=s-16;}\
		wk=(wk<<8)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 8); s=s- 8;}\
		wk=(wk<<4)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 4); s=s- 4;}\
		wk=(wk<<2)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 2); s=s- 2;}\
		wk=(wk<<1)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 1); s=s- 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCUP23_SXINC( ) : x = (x<<sx), s = (s+sx),  0x00400000 <= x < 0x00800000					*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCUP23_SXINC( x, s, wk )\
		wk=0x00000080; if( (ULONG)x <  (ULONG)wk ){ x=(x<<16); s=s+16;}\
		wk=(wk<<8)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 8); s=s+ 8;}\
		wk=(wk<<4)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 4); s=s+ 4;}\
		wk=(wk<<2)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 2); s=s+ 2;}\
		wk=(wk<<1)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 1); s=s+ 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCUP23_SXDEC( ) : x = (x<<sx), s = (s-sx),  0x00400000 <= x < 0x00800000					*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCUP23_SXDEC( x, s, wk )\
		wk=0x00000080; if( (ULONG)x <  (ULONG)wk ){ x=(x<<16); s=s-16;}\
		wk=(wk<<8)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 8); s=s- 8;}\
		wk=(wk<<4)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 4); s=s- 4;}\
		wk=(wk<<2)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 2); s=s- 2;}\
		wk=(wk<<1)   ; if( (ULONG)x <  (ULONG)wk ){ x=(x<< 1); s=s- 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCDN15_SXINC( ) : x = (x>>sx), s = (s+sx),  0x00008000 > x > 0x00000000						*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCDN15_SXINC( x, s, wk )\
		wk=0x40000000; if( (ULONG)x >= (ULONG)wk ){ x=(x>>16); s=s+16;}\
		wk=(wk>>8)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 8); s=s+ 8;}\
		wk=(wk>>4)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 4); s=s+ 4;}\
		wk=(wk>>2)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 2); s=s+ 2;}\
		wk=(wk>>1)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 1); s=s+ 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCDN15_SXDEC( ) : x = (x>>sx), s = (s-sx),  0x00008000 > x > 0x00000000						*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCDN15_SXDEC( x, s, wk )\
		wk=0x40000000; if( (ULONG)x >= (ULONG)wk ){ x=(x>>16); s=s-16;}\
		wk=(wk>>8)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 8); s=s- 8;}\
		wk=(wk>>4)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 4); s=s- 4;}\
		wk=(wk>>2)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 2); s=s- 2;}\
		wk=(wk>>1)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 1); s=s- 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCDN23_SXINC( ) : x = (x>>sx), s = (s+sx),  0x00800000 > x > 0x00000000						*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCDN23_SXINC( x, s, wk )\
		wk=0x40000000; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 8); s=s+ 8;}\
		wk=(wk>>4)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 4); s=s+ 4;}\
		wk=(wk>>2)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 2); s=s+ 2;}\
		wk=(wk>>1)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 1); s=s+ 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		SCDN23_SXDEC( ) : x = (x>>sx), s = (s-sx),  0x00800000 > x > 0x00000000						*/
/*--------------------------------------------------------------------------------------------------*/
#define	SCDN23_SXDEC( x, s, wk )\
		wk=0x40000000; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 8); s=s- 8;}\
		wk=(wk>>4)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 4); s=s- 4;}\
		wk=(wk>>2)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 2); s=s- 2;}\
		wk=(wk>>1)   ; if( (ULONG)x >= (ULONG)wk ){ x=(x>> 1); s=s- 1;}


/*--------------------------------------------------------------------------------------------------*/
/*		ＡＳＣＩＩコードテーブル : ０ 〜 ＦまでのＡＳＣＩＩコードテーブル							*/
/*--------------------------------------------------------------------------------------------------*/
const	UCHAR	MlibAsciiTbl[ ] =
		{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
/*--------------------------------------------------------------------------------------------------*/
/*		ＡＳＣＩＩコードテーブル : ０ 〜 Ｆまでの偶数パリティ付きＡＳＣＩＩコードテーブル			*/
/*--------------------------------------------------------------------------------------------------*/
const	UCHAR	MlibEvenAsciiTbl[ ] =
		{ '0', '1'+0x80, '2'+0x80, '3', '4'+0x80, '5', '6', '7'+0x80,
		  '8'+0x80, '9', 'A', 'B', 'C'+0x80, 'D', 'E'+0x80, 'F'+0x80 };
/*--------------------------------------------------------------------------------------------------*/
/*		１０進累乗テーブル(Decimal Power Table)														*/
/*--------------------------------------------------------------------------------------------------*/
const	ULONG	MlibDecPowerTbl[10] =
		{ 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000	};
/*--------------------------------------------------------------------------------------------------*/


/****************************************************************************************************/
/*																									*/
/*		符号無し３２bit除算関数(ＡＳＭ除算マクロ代替え)												*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		XasmDIVUA() : 符号無し３２bit除算関数(切り捨て)												*/
/*--------------------------------------------------------------------------------------------------*/
/*		1) 演算結果 : kx = (ax/bx)<<rep;															*/
/*		2) 演算条件 : 0 < ax < bx <= 0x7FFFFFFF														*/
/*--------------------------------------------------------------------------------------------------*/
LONG	XasmDIVUA( LONG ax, LONG bx, LONG rep )
{
LONG	i,kx;
		ax = (ax<<1);
		for( kx=0,i=0; i<(rep-1); i++ )
		{
			if( (ULONG)ax >= (ULONG)bx )
			{
				kx = kx + 1;
				ax = (ULONG)ax - (ULONG)bx;
			}
			kx = (kx<<1); ax = (ax<<1);
		}
		if( (ULONG)ax >= (ULONG)bx ){ kx = kx + 1;}
		return( kx );
}
/*--------------------------------------------------------------------------------------------------*/
/*		XasmDIVUB() : 符号無し３２bit除算関数(四捨五入)												*/
/*--------------------------------------------------------------------------------------------------*/
/*		1) 演算結果 : kx = (ax/bx)<<rep;															*/
/*		2) 演算条件 : 0 < ax < bx <= 0x7FFFFFFF														*/
/*--------------------------------------------------------------------------------------------------*/
LONG	XasmDIVUB( LONG ax, LONG bx, LONG rep )
{
LONG	i,kx;
		ax = (ax<<1);
		for( kx=0,i=0; i<rep; i++ )
		{
			kx = (kx<<1);
			if( (ULONG)ax >= (ULONG)bx )
			{
				kx = kx + 1;
				ax = (ULONG)ax - (ULONG)bx;
			}
			ax = (ax<<1);
		}
		if( (ULONG)ax >= (ULONG)bx ){ kx = kx + 1;}
		return( kx );
}
/*--------------------------------------------------------------------------------------------------*/
/*		XasmDIVUXA() : 符号無し３２bit除算関数(切り捨て)											*/
/*--------------------------------------------------------------------------------------------------*/
/*		1) 演算結果  : {kx,sx} = {(ax/bx)<<(rep-0/1), sx=sx+(rep-0/1)]};							*/
/*		2) 演算条件  : 0 < ax <= 0x7FFFFFFF, 0 < bx <= 0x7FFFFFFF, (ax/2) < bx < (2*ax)				*/
/*--------------------------------------------------------------------------------------------------*/
LONG	XasmDIVUXA( LONG ax, LONG bx, LONG *sx, LONG rep )
{
LONG	i,kx;

		if( (ULONG)ax < (ULONG)bx )
		{
			ax = (ax<<1); *sx = *sx + 1;
		}
		for( kx=0,i=0; i<(rep-1); i++ )
		{
			if( (ULONG)ax >= (ULONG)bx )
			{
				kx = kx + 1;
				ax = (ULONG)ax - (ULONG)bx;
			}
			kx = (kx<<1); ax = (ax<<1);
		}
		if( (ULONG)ax >= (ULONG)bx ){ kx = kx + 1;}
		*sx = *sx + rep - 1;

		return( kx );
}
/*--------------------------------------------------------------------------------------------------*/
/*		XasmDIVUXB() : 符号無し３２bit除算関数(四捨五入)											*/
/*--------------------------------------------------------------------------------------------------*/
/*		1) 演算結果  : {kx,sx} = {(ax/bx)<<(rep-0/1), sx=sx+(rep-0/1)]};							*/
/*		2) 演算条件  : 0 < ax <= 0x7FFFFFFF, 0 < bx <= 0x7FFFFFFF, (ax/2) < bx < (2*ax)				*/
/*--------------------------------------------------------------------------------------------------*/
LONG	XasmDIVUXB( LONG ax, LONG bx, LONG *sx, LONG rep )
{
LONG	i,kx;
		if( (ULONG)ax < (ULONG)bx )
		{
			ax = (ax<<1); *sx = *sx + 1;
		}
		for( kx=0,i=0; i<rep; i++ )
		{
			kx = (kx<<1);
			if( (ULONG)ax >= (ULONG)bx )
			{
				kx = kx + 1;
				ax = (ULONG)ax - (ULONG)bx;
			}
			ax = (ax<<1);
		}
		if( (ULONG)ax >= (ULONG)bx ){ kx = kx + 1;}
		*sx = *sx + rep - 1;
		return( kx );
}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 基本制御演算関数 >>>>>																*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		上下限リミット : rv = リミット値															*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLimitul( LONG u, LONG ulim, LONG llim )
{

		if( u > ulim )
		{
			return( ulim );
		}
		if( u < llim )
		{
			return( llim );
		}
		return( u );

}
#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		上下限リミット : rv = リミット値（浮動小数点）												*/
/*																									*/
/****************************************************************************************************/
float	FlibLimitul( float u, float ulim, float llim )
{

		if( u > ulim )
		{
			return( ulim );
		}
		if( u < llim )
		{
			return( llim );
		}
		return( u );

}
#endif /* FLOAT_USE */


/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit標準:2^24) : rv = (kx*u)>>sx;												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgain( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = (xx[1] >> sx);
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			return(  0x01000000 );
		}
		else if( x < -1 )
		{
			return( -0x01000000 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算結果編集																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			return( (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1) );
		}

}



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Signed29bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgain29( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = ((xx[1]>>sx)>>4);
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			return(  0x0FFFFFFF );
		}
		else if( x < -1 )
		{
			return( -0x10000000 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算結果編集																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( x > 0x0FFFFFFF ){ x = 0x0FFFFFFF;}
			return( x );
		}

}



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Signed30bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgain30( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = ((xx[1]>>sx)>>5);
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			return(  0x1FFFFFFF );
		}
		else if( x < -1 )
		{
			return( -0x20000000 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算結果編集																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( x > 0x1FFFFFFF ){ x = 0x1FFFFFFF;}
			return( x );
		}

}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Signed32bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgain32( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = ((xx[1]>>sx)>>7);
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			return(  0x7FFFFFFF );
		}
		else if( x < -1 )
		{
			return(  0x80000000 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算結果編集																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( (xx[1]>=0)&&(x<0) ) return( 0x7fffffff );
			return( x );
		}

}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Unsigned30bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibMulgain30U( ULONG u, LONG k )
{
ULONG	x;
ULONG	xx[2];
ULONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

		MULU32U32( u, kx, xx );
		x = ((xx[1]>>sx)>>5);

		if( x > 0 )
		{
			return(  0x1FFFFFFF );
		}
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( x > 0x1FFFFFFF ){ x = 0x1FFFFFFF;}
			return( x );
		}
}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Unsigned31bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibMulgain31U( ULONG u, LONG k )
{
ULONG	x;
ULONG	xx[2];
ULONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

		MULU32U32( u, kx, xx );
		x = ((xx[1]>>sx)>>6);

		if( x > 0 )
		{
			return(  0x3FFFFFFF );
		}
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( x > 0x3FFFFFFF ){ x = 0x3FFFFFFF;}
			return( x );
		}
}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit:Unsigned32bit) : rv = (kx*u)>>sx;											*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibMulgain32U( ULONG u, LONG k )
{
ULONG	x;
ULONG	xx[2];
ULONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

		MULU32U32( u, kx, xx );
		x = ((xx[1]>>sx)>>7);

		if( x > 0 )
		{
			return(  0x7FFFFFFF );
		}
		else
		{
			x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
			if( x > 0x7FFFFFFF ){ x = 0x7FFFFFFF;}
			return( x );
		}
}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(smax拡大:smax=48) : rv = (kx*u)>>sx;												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgainSx48( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
/*--------------------------------------------------------------------------------------------------*/
/*		指数：sx <= 24																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( sx <= 24 )
		{
			if( (xx[1]>>sx) > 0 )
			{
				return(  0x01000000 );
			}
			else if( (xx[1]>>sx) < -1 )
			{
				return( -0x01000000 );
			}
			else
			{
				return( (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1) );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		指数：sx > 24																				*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = (((xx[1]>>(sx-25))+1)>>1);
			if( x >= 0x01000000 )
			{
				return(  0x01000000 );
			}
			else if( x <= -0x01000000 )
			{
				return( -0x01000000 );
			}
			else
			{
				return( x );
			}
		}

}

/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(smax拡大:smax=48) : rv = (kx*u)>>sx;												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgain32Sx48( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
/*--------------------------------------------------------------------------------------------------*/
/*		指数：sx <= 24																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( sx <= 24 )
		{
			x = ((xx[1]>>sx)>>7);
			if( x > 0 )
			{
				return(  0x7fffffff );
			}
			else if( x < -1 )
			{
				return( 0x80000000 );
			}
			else
			{
				x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
				if( (xx[1]>=0)&&(x<0) ) return( 0x7fffffff );
				return( x );
			}
		}
		else
		{
			return( ((xx[1]>>(sx-25))+1)>>1 );
		}

}



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit無し) : rv = (kx*u)>>sx;													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulgainNolim( LONG u, LONG k )
{
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

		MUL3232( u, kx, xx );
		return( (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1) );

}



/****************************************************************************************************/
/*																									*/
/*		積分演算 : iu=iu+(kx*u); rv=((iu[1]+1)>>1);													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibIntegral( LONG u, LONG k, LONG iu[2] )
{
LONG	x;
LONG	xx[2];
LONG	carry;
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		入力演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = (xx[1] >> sx);
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			iu[1] = iu[1] + (LONG)0x02000000;
		}
		else if( x < -1 )
		{
			iu[1] = iu[1] - (LONG)0x02000000;
		}
		else
		{
			carry = ( (ULONG)(iu[0]+(xx[0]<<(25-sx))) < (ULONG)iu[0] );
			iu[0] = iu[0] + (xx[0]<<(25-sx));
			iu[1] = iu[1] + (xx[1]<<(25-sx)) + (((ULONG)xx[0]>>sx)>>7) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( iu[1] >= (LONG)0x02000000 )
		{
			iu[0] = 0;
			iu[1] = 0x02000000;
		}
		else if( iu[1] < (LONG)-0x02000000 )
		{
			iu[0] =  0;
			iu[1] = -0x02000000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		戻り値計算(四捨五入処理)																	*/
/*--------------------------------------------------------------------------------------------------*/
		return( ((iu[1]+1)>>1) );

}



#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		積分演算 : rv=iu; iu+=kx*u																	*/
/*																									*/
/****************************************************************************************************/
float	FlibIntegral( float u, float k, float *iu )
{
float ax;
float fwk1;											/*強制収束処理用work*/

//forDebug四捨五入による誤差調査	---->
#if 1//(案2)
LONG	lwk_ax = 0;
float	fwk_iu;
#endif
//<----	forDebug四捨五入による誤差調査

//k = k / 16777216.0f; //todo

/*--------------------------------------------------------------------------------------------------*/
/*		乗算(u*k)																					*/
/*--------------------------------------------------------------------------------------------------*/
		ax = (u * k);
//forDebug四捨五入による誤差調査	---->
#if 0	//(案2)
		lwk_ax = (LONG)( ( ax * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		ax = (float)(lwk_ax) * ( 100.0 / 16777216.0 );	/* Float換算							*/
#endif
//<----	forDebug四捨五入による誤差調査

#if (FLOAT_USE==TRUE)
/*--------------------------------------------------------------------------------------------------*/
/*		強制収束処理(0近辺微少演算処理)(案1)														*/
/*--------------------------------------------------------------------------------------------------*/
//-----(案1)の場合----->
//下記処理は不要??? ----> Double演算にする????【仮処置】
//Float時でも、u=0,or,k=0でない時にax=0になることはない????
/*--------------------------------------------------------------------------------------------------*/
#if 0	// ---->
		if((u != (float)0.0) && ( k != (float)0.0) && (ax == (float)0.0))
		{
			if( u >= (float)0.0 )
			{
				if(k>(float)0.0)	ax = FLOAT_PULUS_MIN;
				if(k<(float)0.0)	ax = FLOAT_MINUS_MIN;
			}
			else
			{
				if(k>(float)0.0)	ax = FLOAT_MINUS_MIN;
				if(k<(float)0.0)	ax = FLOAT_PULUS_MIN;
			}
		}
#endif	/* #if 0	*/	// <----
//<-----(案1)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案2)の場合----->
//下記処理は不要??? ----> Double演算にする????【仮処置】
//Float時でも、u=0,or,k=0でない時にax=0になることはない????
/*--------------------------------------------------------------------------------------------------*/
#if 0	// ---->
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		fwk1 = *iu;
		*iu = *iu + ax;
		if( ( fwk1 == *iu ) && ( ax != 0 ) )				/*　加算しても値に変化がない場合		*/
		{
			*iu = *iu + u;									/*　積分ゲイン乗算前の積分値を加算		*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( *iu >= (float)INTGRAL_NORMAXVAL )
		{
			*iu = INTGRAL_NORMAXVAL;
		}
		else if( *iu < -((float)INTGRAL_NORMAXVAL) )
		{
			*iu =  - (INTGRAL_NORMAXVAL);
		}
/*--------------------------------------------------------------------------------------------------*/
		return( *iu );
#endif	/* #if 0	*/	// <----
//<-----(案2)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案3)の場合----->
/*--------------------------------------------------------------------------------------------------*/
#if 0	// ---->
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		fwk1 = *iu;
		*iu = *iu + ax;
		if( ( fwk1 == *iu ) && ( ax != 0 ) )				/*　加算しても値に変化がない場合		*/
		{
			*iu = *iu + u * k * 1.2;						/*　積分ゲイン乗算前の積分値*1.2を加算	*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( *iu >= (float)INTGRAL_NORMAXVAL )
		{
			*iu = INTGRAL_NORMAXVAL;
		}
		else if( *iu < -((float)INTGRAL_NORMAXVAL) )
		{
			*iu =  - (INTGRAL_NORMAXVAL);
		}
/*--------------------------------------------------------------------------------------------------*/
		return( *iu );
#endif	/* #if 0	*/	// <----
//<-----(案3)の場合-----
/*--------------------------------------------------------------------------------------------------*/
#endif /* FLOAT_USE */
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		*iu = *iu + ax;
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( *iu >= (float)INTGRAL_NORMAXVAL )
		{
			*iu = INTGRAL_NORMAXVAL;
		}
		else if( *iu < -((float)INTGRAL_NORMAXVAL) )
		{
			*iu =  - (INTGRAL_NORMAXVAL);
		}
/*--------------------------------------------------------------------------------------------------*/
//forDebug四捨五入による誤差調査	---->
#if 0	//(案2)
		if( *iu > 0)
		{
			lwk_ax = (LONG)( ( *iu * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		}
		if( *iu < 0)
		{
			lwk_ax = (LONG)( ( *iu * 167772.16 ) - 0.5 );		/* MLIB換算								*/
		}
		fwk_iu = (float)(lwk_ax) * ( 100.0 / 16777216.0 );	/* Float換算							*/
		return( fwk_iu );
#endif
//<----	forDebug四捨五入による誤差調査
		return( *iu );

}
#endif /* FLOAT_USE */



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(正負対称四捨五入) : rv = (kx*u)>>sx;												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSymMulgain( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算 : 32bit * 32bit --> 64bit														*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = (xx[1] >> sx);
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			return(  0x01000000 );								/* Upper Limit						*/
		}
		else if( x < -1 )
		{
			return( -0x01000000 );								/* Lower Limit						*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		演算結果編集 : rc = (kx*u)>>sx;																*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			xx[1] = (xx[1] << (24-sx));							/* GetHiBits						*/
			xx[0] = (xx[0]==0)? xx[0] : (xx[0] + x);			/* Adjust RoundOff for Negative		*/
			xx[0] = ((((ULONG)xx[0]>>sx) + 0x0080)>>8);			/* GetLoBits and RoundOff			*/
			return( xx[1] + xx[0] );							/* HiBits + LoBits					*/
		}

}



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(Limit無し,正負対称四捨五入) : rv = (kx*u)>>sx;									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSymMulgainNolim( LONG u, LONG k )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

		MUL3232( u, kx, xx );									/* xx[] = kx * u					*/
		x = (xx[1] >> 31);										/* x = 0 or -1						*/
		xx[1] = (xx[1] << (24-sx));								/* GetHiBits						*/
		xx[0] = (xx[0]==0)? xx[0] : (xx[0] + x);				/* Adjust RoundOff for Negative		*/
		xx[0] = ((((ULONG)xx[0]>>sx) + 0x0080)>>8);				/* GetLoBits and RoundOff			*/
		return( xx[1] + xx[0] );								/* HiBits + LoBits					*/

}



/****************************************************************************************************/
/*																									*/
/*		積分演算(正負対称四捨五入) : iu=iu+(kx*u); rv=((iu[1]+x)>>1);								*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSymIntegral( LONG u, LONG k, LONG iu[2] )
{
LONG	x;
LONG	xx[2];
LONG	carry;
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		入力演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = (xx[1] >> sx);
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			iu[1] = iu[1] + (LONG)0x02000000;
		}
		else if( x < -1 )
		{
			iu[1] = iu[1] - (LONG)0x02000000;
		}
		else
		{
			carry = ( (ULONG)(iu[0]+(xx[0]<<(25-sx))) < (ULONG)iu[0] );
			iu[0] = iu[0] + (xx[0]<<(25-sx));
			iu[1] = iu[1] + (xx[1]<<(25-sx)) + (((ULONG)xx[0]>>sx)>>7) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( iu[1] >= (LONG)0x02000000 )
		{
			iu[0] = 0;
			iu[1] = 0x02000000;
		}
		else if( iu[1] < (LONG)-0x02000000 )
		{
			iu[0] =  0;
			iu[1] = -0x02000000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		戻り値計算(正負対称四捨五入処理)															*/
/*--------------------------------------------------------------------------------------------------*/
		x = (iu[1] >= 0)? 1 : ((iu[0] != 0)? 1 : 0);
		return( ((iu[1]+x)>>1) );

}



/****************************************************************************************************/
/*																									*/
/*		余り付き位置ＦＢ計算(ＭＦＣ用) : rv = (kx*u+pfbrem)>>sx;									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPfbkxremLim( LONG u, LONG k, LONG *pfbrem )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = ((ULONG)k)>>24;
LONG	remx = *pfbrem;

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );

/*--------------------------------------------------------------------------------------------------*/
/*		スケーリング処理：sx <= 24																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( sx <= 24 )
		{
			if( (xx[1]>>sx) > 0 )
			{
				*pfbrem = 0;
				return(  0x01000000 );
			}
			else if( (xx[1]>>sx) < -1 )
			{
				*pfbrem = 0;
				return( -0x01000000 );
			}
			else
			{
				x = (xx[1]<<(24-sx)) + ((((ULONG)xx[0])>>sx)>>8);
				remx = remx + (((ULONG)xx[0]<<(24-sx))>>8);
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		スケーリング処理：sx > 24																	*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = xx[1]>>(sx-24);
			if( x >= 0x01000000 )
			{
				*pfbrem = 0;
				return(  0x01000000 );
			}
			else if( x <= -0x01000000 )
			{
				*pfbrem = 0;
				return( -0x01000000 );
			}
			else
			{
				remx = remx + (((ULONG)xx[1]<<(56-sx))>>8) + (((((ULONG)xx[0]>>(sx-24))>>7)+1)>>1);
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		余り処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( remx >= (LONG)0x00800000 )
		{
			x = x + 1;
			remx = remx - (LONG)0x00800000;
			remx = remx - (LONG)0x00800000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		*pfbrem = remx;
		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		余り付き位置ＦＢ計算(ＭＦＣ用) : rv = (kx*u+pfbrem)>>sx;									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPfbkxremNolim( LONG u, LONG k, LONG *pfbrem )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = ((ULONG)k)>>24;
LONG	remx = *pfbrem;

/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン乗算処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );

/*--------------------------------------------------------------------------------------------------*/
/*		スケーリング処理：sx <= 24																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( sx <= 24 )
		{
			x = (xx[1]<<(24-sx)) + ((((ULONG)xx[0])>>sx)>>8);
			remx = remx + (((ULONG)xx[0]<<(24-sx))>>8);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		スケーリング処理：sx > 24																	*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = xx[1]>>(sx-24);
			remx = remx + (((ULONG)xx[1]<<(56-sx))>>8) + (((((ULONG)xx[0]>>(sx-24))>>7)+1)>>1);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		余り処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( remx >= (LONG)0x00800000 )
		{
			x = x + 1;
			remx = remx - (LONG)0x00800000;
			remx = remx - (LONG)0x00800000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		*pfbrem = remx;
		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		余り付き位置ゲイン乗算(ＭＦＣ用) : rv=(kx*u-((kx*pfbrem)>>24))>>sx;							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulkprem( LONG u, LONG k, LONG pfbrem )
{
LONG	x;
LONG	xx1[2];
LONG	xx2[2];
LONG	carry;
LONG	kx = (k<<8);
LONG	sx = ((ULONG)k)>>24;

		MUL3232( u,      kx, xx1 );
		MUL3232( pfbrem, kx, xx2 );

		x = (xx2[1]<<8) + ((ULONG)xx2[0]>>24);
		carry  = ( (ULONG)xx1[0] < (ULONG)x );
		xx1[0] = (ULONG)xx1[0] - (ULONG)x;
		xx1[1] = xx1[1] - (xx2[1]>>24) - carry;

		if( (xx1[1]>>sx) > 0 )
		{
			return(  0x01000000 );
		}
		else if( (xx1[1]>>sx) < -1 )
		{
			return( -0x01000000 );
		}
		else
		{
			return( (xx1[1]<<(24-sx)) + (((((ULONG)xx1[0]>>sx)>>7)+1)>>1) );
		}

}



/****************************************************************************************************/
/*																									*/
/*		バイアス余り付きゲイン乗算																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		2004.04.08 : T.Taniguchi : 余り処理修正														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulkxBiasrem( LONG u, LONG k, LONG *rem, LONG bias )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);
LONG	kb = (bias<<8);
LONG	sb = (((ULONG)bias)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		余り付き乗算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		*rem = *rem + ((ULONG)(xx[0]<<(24-sx))>>8);
		x = (xx[1]<<(24-sx)) + (((ULONG)xx[0]>>sx)>>8);
		if( *rem >= 0x00800000 )
		{
			x = x + 1;
			*rem = *rem - 0x01000000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		バイアス加算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( u >= 0 )
		{
			x = x + (((ULONG)kb>>sb)>>8);
			*rem = *rem + ((ULONG)(kb<<(24-sb))>>8);
			if( *rem >= 0x00800000 )
			{
				x = x + 1;
				*rem = *rem - 0x01000000;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		バイアス減算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = x - (((ULONG)kb>>sb)>>8);
			*rem = *rem - ((ULONG)(kb<<(24-sb))>>8);
			if( *rem < -0x00800000 )
			{
				x = x - 1;
				*rem = *rem + 0x01000000;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		バイアス余り付きゲイン乗算																	*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		余り処理不具合１ : 余り加算が２回あるので、１回の余り処理では不十分							*/
/*		余り処理不具合２ : 余り減算後の余り処理は、負側の余りチェックが必要							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulkxBiasremOld( LONG u, LONG k, LONG *rem, LONG bias )
{
LONG	x;
LONG	xx[2];
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);
LONG	kb = (bias<<8);
LONG	sb = (((ULONG)bias)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		余り付き乗算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		*rem = *rem + ((ULONG)(xx[0]<<(24-sx))>>8);
		x = (xx[1]<<(24-sx)) + (((ULONG)xx[0]>>sx)>>8);
/*--------------------------------------------------------------------------------------------------*/
/*		バイアス加算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( u >= 0 )
		{
			x = x + (((ULONG)kb>>sb)>>8);
			*rem = *rem + ((ULONG)(kb<<(24-sb))>>8);
			if( *rem >= 0x00800000 )
			{
				x = x + 1;
				*rem = *rem - 0x00800000;
				*rem = *rem - 0x00800000;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		バイアス減算処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x = x - (((ULONG)kb>>sb)>>8);
			*rem = *rem - ((ULONG)(kb<<(24-sb))>>8);
			if( *rem >= 0x00800000 )
			{
				x = x + 1;
				*rem = *rem - 0x00800000;
				*rem = *rem - 0x00800000;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		return( x );

}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< フィルタ演算関数 >>>>>																*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		ローパスフィルタ : rv = x + ((kx*(u-x))>>24);												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLpfilter1( LONG u, LONG k, LONG x )
{
LONG	wk1;
LONG	xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == 0 )
		{
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (u-x), k, xx );
		wk1 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( wk1 == 0 )
		{
			return( x + ((u-x)>0) - ((u-x)<0) );
		}
		else
		{
			return( x + wk1 );
		}

}



#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		ローパスフィルタ : rv = x + (kx*(u-x));														*/
/*																									*/
/****************************************************************************************************/
float	FlibLpfilter1( float u, float k, float x )
{

float	ax;
float	wk1;
float	x_wk;

//forDebug四捨五入による誤差調査	---->
#if 0	//(案2,3)
LONG	lwk_wk1 = 0;
float	fwk_u;
#endif
#if 0	//(案4)
LONG	lwk_u;
LONG	lwk_x;
#endif

//<----	forDebug四捨五入による誤差調査

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == (float)0.0 )
		{
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
//forDebug四捨五入による誤差調査	---->
#if 0	//(案4)
		lwk_u = (LONG)( ( u * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		u = (float)(lwk_u) * ( 100.0 / 16777216.0 );	/* Float換算						*/
		lwk_x = (LONG)( ( x * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		x = (float)(lwk_x) * ( 100.0 / 16777216.0 );	/* Float換算						*/
#endif
//<----	forDebug四捨五入による誤差調査
		ax = ( u - x );
		wk1 = ( ax * k );
//forDebug四捨五入による誤差調査	---->
#if 0	//(案3)
		if (wk1 > 0)
		{
			lwk_wk1 = (LONG)( ( wk1 * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		}
		if (wk1 < 0)
		{
			lwk_wk1 = (LONG)( ( wk1 * 167772.16 ) - 0.5 );		/* MLIB換算								*/
		}
		if( ( lwk_wk1 == 0 ) && ( ax != 0 ) )
		{
			if( ax > 0 )
			{
				x = x + ( 100.0 / 16777216.0 );
			}
			else if( ax < 0 )
			{
				x = x - ( 100.0 / 16777216.0 );
			}
			fwk_u = u;							//(案3.1)
			u = ( u - x );
			if( (u * ax) < 0 )		//(案3.1)
			{									//(案3.1)
				x = fwk_u;						//(案3.1)
//				u = ax;
			}									//(案3.1)
			return ( x );
		}
		else
		{
			wk1 = (float)( lwk_wk1 ) * ( 100.0 / 16777216.0 );	/* Float換算						*/
		}
#endif
//<----	forDebug四捨五入による誤差調査

/*--------------------------------------------------------------------------------------------------*/
/*		強制収束処理																				*/
/*--------------------------------------------------------------------------------------------------*/
//強制収束処理は不要??? ----> Double演算にする????【仮処置】
/*--------------------------------------------------------------------------------------------------*/
//-----(案1)の場合----->
//FloatでもDouble時でも、ax=0,or,k=0でない時にwk1=0になることはない????
#if 0	// ---->
		if ( (wk1 == 0) && (ax !=0) )
		{
			if ( (u-x) > 0)
			{
//				wk1 = FLOAT_PULUS_MIN;
				wk1 = 5.9604644e-08;
				x = ( x + wk1 );
				if ( u < x)
				{
					x = u;
				}
			}
			else
			{
				if ( (u-x) < 0)
				{
//					wk1 = FLOAT_MINUS_MIN;
					wk1 = -5.9604644e-08;
					x = ( x + wk1 );
					if ( u > x)
					{
						x = u;
					}
				}
			}
		}
		else
		{
			x = ( x + wk1 );
		}
		return( x );
#endif	/* #if 0	*/	// <----
//<-----(案1)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案2)の場合----->
//下記にしても効果はなさそう??? とりあえず、ｺﾒﾝﾄｱｳﾄ
#if 0	// ---->
//#if 1	// ---->
		x_wk = x;
		x = ( x + wk1 );
		if ( ( x_wk == x) && (ax != 0) )
		{
			if ( ax > 0)	/* ax = (u - x) */
			{
//				wk1 = FLOAT_PULUS_MIN;
//				wk1 = 5.9604644e-08;
				wk1 = 5.9604644e-02;
				x = ( x + wk1 );
				if ( u < x)
				{
					x = u;
				}
			}
			else
			{
				if ( ax < 0)	/* ax = (u - x) */
				{
//					wk1 = FLOAT_MINUS_MIN;
//					wk1 = -5.9604644e-08;
					wk1 = -5.9604644e-02;
					x = ( x + wk1 );
					if ( u > x)
					{
						x = u;
					}
				}
			}
		}
		return( x );
#endif	/* #if 0	*/	// <----
//<-----(案2)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案3)の場合----->
//下記にしても効果はなさそう??? とりあえず、ｺﾒﾝﾄｱｳﾄ
//#if 1	// ---->
#if 0	// ---->
		x_wk = x;
		x = ( x + wk1 );
		if ( x_wk == x)
		{
			x = u;
		}
		return( x );
#endif	/* #if 0	*/	// <----
//<-----(案3)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案4)の場合----->
//x_wk == xになることはないため不要ｺﾒﾝﾄｱｳﾄ
//#if 1	// ---->
#if 0	// ---->
		x_wk = x;
		x = ( x + wk1 );
		if ( ( x_wk == x) && (ax != 0) )
		{
			if ( ax > 0)	/* ax = (u - x) */
			{
//				x = ( x + ( ax / 10 ) );
				x = ( x + ax / 3);
				if ( u < x )
				{
					x = u;
				}
			}
			else			// ax < 0 
			{
//				x = ( x + ( ax / 10 ) );
				x = ( x + ax / 3);
				if ( u > x )
				{
					x = u;
				}
			}
		}
		return( x );
#endif	/* #if 0 or 1	*/	// <----
//<-----(案4)の場合-----
/*--------------------------------------------------------------------------------------------------*/

		x = ( x + wk1 );
//forDebug四捨五入による誤差調査	---->
#if 0	//(案2)
		lwk_wk1 = (LONG)( ( x * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		x = (float)(lwk_wk1) * ( 100.0 / 16777216.0 );	/* Float換算							*/
#endif
//<----	forDebug四捨五入による誤差調査
		return( x );

}
#endif /* FLOAT_USE */




/****************************************************************************************************/
/*																									*/
/*		ハイパスフィルタ : rv=u-z; z=z+((kx*(u-z))>>24);											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibHpfilter1( LONG u, LONG k, LONG *z )
{
LONG	wk1;
LONG	xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == 0 )
		{
			*z = 0;
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (u-*z), k, xx );
		wk1 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( wk1 == 0 )
		{
			*z = *z + ((u-*z)>0) - ((u-*z)<0);
		}
		else
		{
			*z = *z + wk1;
		}
/*--------------------------------------------------------------------------------------------------*/
		return( u - *z );

}


#if (FLOAT_USE==TRUE)
#if 0
/****************************************************************************************************/
/*																									*/
/*		ハイパスフィルタ : rv=u-z; z=z+(kx*(u-z));												*/
/*																									*/
/****************************************************************************************************/
float	FlibHpfilter1( float u, float k, float *z )
{

float ax;
float	wk1;
//強制収束処理用変数
float	z_wk;											

//forDebug四捨五入による誤差調査	---->
#if 0	//(案1)動作せず
LONG	lwk_u = u * 16777216.0 / 100.0;							/* MLIB換算							*/
LONG	lwk_k = k * 16777216.0 / 100.0;							/* MLIB換算							*/
LONG	lwk_z = *z * 16777216.0 / 100.0;						/* MLIB換算							*/
LONG	lwk_wk1;
LONG	xx[2];
#endif
#if 1	//(案2,3)
LONG	lwk_wk1;
float	fwk_u;
float	fwk_z;
#endif
#if 1	//(案4)
LONG	lwk_u;
LONG	lwk_z;
#endif
//<----	forDebug四捨五入による誤差調査

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == (float)0.0 )
		{
			*z = 0;
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
//forDebug四捨五入による誤差調査	---->
#if 0	//(案4)
		lwk_u = (LONG)( ( u * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		u = (float)(lwk_u) * ( 100.0 / 16777216.0 );	/* Float換算						*/
		lwk_z = (LONG)( ( *z * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		*z = (float)(lwk_z) * ( 100.0 / 16777216.0 );	/* Float換算						*/
#endif
//<----	forDebug四捨五入による誤差調査
		ax = (u -*z);
		wk1 = (ax * k);

//forDebug四捨五入による誤差調査	---->
#if 0	//(案1)動作せず
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (lwk_u-lwk_z), lwk_k, xx );
		lwk_wk1 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( wk1 == 0 )
		{
			lwk_z = lwk_z + ((lwk_u-lwk_z)>0) - ((lwk_u-lwk_z)<0);
		}
		else
		{
			lwk_z = lwk_z + lwk_wk1;
		}
/*--------------------------------------------------------------------------------------------------*/
		*z = (float)lwk_z * 100.0 / 16777216.0;			/* Float換算							*/
		u = ( u - *z );
		return( u );
#endif
#if 0	//(案2)
		lwk_wk1 = (LONG)( ( wk1 * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		wk1 = (float)(lwk_wk1) * ( 100.0 / 16777216.0 );	/* Float換算							*/
#endif
#if 0	//(案3)
		lwk_wk1 = (LONG)( ( wk1 * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		if(( lwk_wk1 == 0 ) && ( ax != 0))
		{
			fwk_z = *z;							//(案3.1)
			if( ( u - *z ) > 0)
			{
				*z = *z + ( 100.0 / 16777216.0 );
			}
			else if( ( u - *z ) < 0)
			{
				*z = *z - ( 100.0 / 16777216.0 );
			}
			fwk_u = u;							//(案3.1)
			u = ( u - *z );
			if( u * ( fwk_u - fwk_z ) < 0 )		//(案3.1)
			{									//(案3.1)
				*z = fwk_u;						//(案3.1)
				u = ax;
			}									//(案3.1)
			return( u );
		}
		else
		{
			wk1 = (float)(lwk_wk1) * ( 100.0 / 16777216.0 );	/* Float換算						*/
		}
#endif
//<----	forDebug四捨五入による誤差調査

/*--------------------------------------------------------------------------------------------------*/
/*		強制収束処理																				*/
/*--------------------------------------------------------------------------------------------------*/
//強制収束処理は不要??? ----> Double演算にする????【仮処置】
/*--------------------------------------------------------------------------------------------------*/
//-----(案1)の場合----->
//FloatでもDouble時でも、ax=0,or,k=0でない時にwk1=0になることはない????
#if 0	// ---->
		z_wk = *z;
		if ( (wk1 == 0) && (ax !=0) )
		{
			if ( (u-*z) > 0)
			{
//				wk1 = FLOAT_PULUS_MIN;
				wk1 = 5.9604644e-08;
				*z = *z + wk1;
				if ( u < *z)
				{
					*z = u;
				}
			}
			else
			{
				if ( (u-*z) < 0)
				{
//					wk1 = FLOAT_MINUS_MIN;
					wk1 = -5.9604644e-08;
					*z = ( *z + wk1 );
					if ( u > *z)
					{
						*z = u;
					}
				}
			}
		}
		else
		{
			*z = *z + wk1;
		}
		u = ( u - *z );
		return( u );
#endif	/* #if 0	*/	// <----
//<-----(案1)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案2)の場合----->
//下記にしても効果はなさそう??? とりあえず、ｺﾒﾝﾄｱｳﾄ
#if 0	// ---->
		z_wk = *z;
		*z = *z + wk1;
		if ( ( z_wk == *z) && (ax != 0) )
		{
			if ( ax > 0)	/* ax = (u -*z) */
			{
//				wk1 = FLOAT_PULUS_MIN;
//				wk1 = 5.9604644e-08;
				wk1 = 5.9604644e-02;
				*z = *z + wk1;
				if ( u < *z)
				{
					*z = u;
				}
			}
			else
			{
				if ( ax < 0)	/* ax = (u -*z) */
				{
//					wk1 = FLOAT_MINUS_MIN;
//					wk1 = -5.9604644e-08;
					wk1 = -5.9604644e-02;
					*z = ( *z + wk1 );
					if ( u > *z)
					{
						*z = u;
					}
				}
			}
		}
		u = ( u - *z );
		return( u );
#endif	/* #if 0	*/	// <----
//<-----(案2)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案3)の場合----->
//下記にしても効果はなさそう??? とりあえず、ｺﾒﾝﾄｱｳﾄ
//#if 1	// ---->
#if 0	// ---->
		z_wk = *z;
		*z = *z + wk1;
		if ( z_wk == *z)
		{
			*z = u;
		}
		u = ( u - *z );
		return( u );
#endif	/* #if 0	*/	// <----
//<-----(案3)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案4)の場合----->
//x_wk == xになることはないため不要ｺﾒﾝﾄｱｳﾄ
//#if 1	// ---->
#if 0	// ---->
		z_wk = *z;
		*z = *z + wk1;
		if ( ( z_wk == *z ) && ( ax != 0 ) )
		{
			if ( ax > 0 )	/* ax = (u -*z) */
			{
//				*z = *z + ( ax / 10 ) ;
				*z = *z + ax/3;
				if ( u < *z )
				{
					*z = u;
				}
			}
			else			// ax < 0 
			{
//				*z = *z + ( ax / 10 ) ;
				*z = *z + ax/3;
				if ( u > *z )
				{
					*z = u;
				}
			}
		}
		u = ( u - *z );
		return( u );
#endif	/* #if 0 or 1	*/	// <----
//<-----(案4)の場合-----
/*--------------------------------------------------------------------------------------------------*/
//-----(案5)の場合----->
//x_wk == xになることはないため不要ｺﾒﾝﾄｱｳﾄ
//#if 1	// ---->
#if 0	// ---->
		z_wk = *z;
		*z = *z + wk1;
		if ( ( z_wk == *z ) && ( ax != 0 ) )
		{
			if ( ax > 0 )	/* ax = (u -*z) */
			{
				*z = *z + (ax * k * 1.2);
				if ( u < *z )
				{
					*z = u;
				}
			}
			else			// ax < 0 
			{
				*z = *z + (ax * k * 1.2);
				if ( u > *z )
				{
					*z = u;
				}
			}
		}
		u = ( u - *z );
		return( u );
#endif	/* #if 0 or 1	*/	// <----
//<-----(案5)の場合-----
/*--------------------------------------------------------------------------------------------------*/

		*z = *z + wk1;
		u = ( u - *z );
//forDebug四捨五入による誤差調査	---->
#if 0	//(案2)
		lwk_wk1 = (LONG)( ( u * 167772.16 ) + 0.5 );		/* MLIB換算								*/
		u = (float)(lwk_wk1) * ( 100.0 / 16777216.0 );	/* Float換算							*/
#endif
//<----	forDebug四捨五入による誤差調査
		return( u );

}
#else
/****************************************************************************************************/
/*																									*/
/*		ハイパスフィルタ : rv=u-z; z=z+(kx*(u-z));												*/
/*																									*/
/****************************************************************************************************/
float	FlibHpfilter1( float u, float k, float *z )
{

		*z = FlibLpfilter1( u, k, *z );
		u = u - *z;

		return( u );

}
#endif
#endif /* FLOAT_USE */



/****************************************************************************************************/
/*																									*/
/*		２次ローパスフィルタ : rv=(z[2]>>1); z[]=f(u,k[],z[]);										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLpfilter2( LONG u, LONG k[2], LONG z[3] )
{
LONG	wk1;
LONG	wk2;
LONG	xx[2];
LONG	carry;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k[0] == 0 )
		{
			z[0] = 0;
			z[1] = 0;
			z[2] = 0;
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		wk1 = u - ((z[2]+1)>>1) - z[0];
		MUL3232( wk1, k[0], xx );
		wk2 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
		if( wk2==0 )
		{
			z[0] = z[0] + (wk1>0) - (wk1<0);
		}
		else
		{
			z[0] = z[0] + wk2;
		}
/*--------------------------------------------------------------------------------------------------*/
		kx = (k[1]<<8);
		sx = (((ULONG)k[1])>>24);
		MUL3232( z[0], kx, xx );
		carry = ( (ULONG)(z[1]+(xx[0]<<(25-sx))) < (ULONG)z[1] );
		z[1] = z[1] + (xx[0]<<(25-sx));
		z[2] = z[2] + (xx[1]<<(25-sx)) + (((ULONG)xx[0]>>sx)>>7) + carry;
/*--------------------------------------------------------------------------------------------------*/
		return( ((z[2]+1)>>1) );

}



/****************************************************************************************************/
/*																									*/
/*		２次ノッチフィルタ(k[2]!=0)   :	rv=k[2]*(u-(z[2]>>1)-z[0])+(z[2]>>1); z[]=f(u,k[],z[]);		*/
/*		２次ローパスフィルタ(k[2]==0) : rv=k[2]*(u-(z[2]>>1)-z[0])+(z[2]>>1); z[]=f(u,k[],z[]);		*/
/*																									*/
/****************************************************************************************************/
LONG	MlibNxfilter2( LONG u, LONG k[3], LONG z[3] )
{
LONG	wk1;
LONG	wk2;
LONG	xx[2];
LONG	carry;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k[0] == 0 )
		{
			z[0] = 0;
			z[1] = 0;
			z[2] = 0;
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		wk1 = u - ((z[2]+1)>>1) - z[0];
		MUL3232( wk1, k[0], xx );
		wk2 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
		if( wk2==0 )
		{
			z[0] = z[0] + (wk1>0) - (wk1<0);
		}
		else
		{
			z[0] = z[0] + wk2;
		}
/*--------------------------------------------------------------------------------------------------*/
		kx = (k[1]<<8);
		sx = (((ULONG)k[1])>>24);
		MUL3232( z[0], kx, xx );
		carry = ( (ULONG)(z[1]+(xx[0]<<(25-sx))) < (ULONG)z[1] );
		z[1] = z[1] + (xx[0]<<(25-sx));
		z[2] = z[2] + (xx[1]<<(25-sx)) + (((ULONG)xx[0]>>sx)>>7) + carry;
/*--------------------------------------------------------------------------------------------------*/
		wk1 = ((z[2]+1)>>1);
		MUL3232( u-wk1-z[0], k[2], xx );
		wk2 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1) + wk1;
/*--------------------------------------------------------------------------------------------------*/
		return( wk2 );
//		return( u - z[0] );

}



/****************************************************************************************************/
/*																									*/
/*		２次ローパスフィルタ(双一次変換)															*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLowPassfilter2( LONG u, LONG k[4], LONG z[4] )
{
	
		LONG	x[6];

		x[0] = MlibMulgain29( u,    k[0] );
		x[1] = MlibMulgain29( z[0], k[3] );
		x[2] = MlibMulgain29( z[1], k[0] );
		x[3] = MlibMulgain29( z[2], k[1] );
		x[4] = MlibMulgain29( z[3], k[2] );


		x[5] = x[0] + x[1] + x[2] + x[3] - x[4];
/*--------------------------------------------------------------------------------------------------*/
		z[3] = z[2];
		z[2] = x[5];
		z[1] = z[0];
		z[0] = u;

		return( x[5] );
}


#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		２次ローパスフィルタ(双一次変換)															*/
/*																									*/
/****************************************************************************************************/
float	FlibLowPassfilter2( float u, float k[4], float z[4] )
{
float	x[6];

		x[0] = u * k[0];
		x[1] = z[0] * k[3];
		x[2] = z[1] * k[0];
		x[3] = z[2] * k[1];
		x[4] = z[3] * k[2];
		x[5] = x[0] + x[1] + x[2] + x[3] - x[4];
/*--------------------------------------------------------------------------------------------------*/
		z[3] = z[2];
		z[2] = x[5];
		z[1] = z[0];
		z[0] = u;

		return( x[5] );

}
#endif /* FLOAT_USE */



/****************************************************************************************************/
/*																									*/
/*		直線加速器(LAU)フィルタ : rv = z + dz or rv = z - dz;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibLaufilter(
		LONG	u,						/* 入力														*/
		LONG	z,						/* 出力前回値												*/
		LONG	dz )					/* 出力増減量												*/
{
LONG	x;

		if( dz == 0 )					/* 出力増減量がゼロの場合は、								*/
		{								/* ＬＡＵフィルタ不使用(出力＝入力)とする。					*/
			x = u;
		}
		else if( u > z )				/* 入力 > 出力前回値 の場合									*/
		{
			x = z + dz;
			if( x > u ){ x = u;}
		}
		else							/* 入力 <= 出力前回値 の場合								*/
		{
			x = z - dz;
			if( x < u ){ x = u;}
		}
		return( x );

}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 制御パラメータ計算用関数 >>>>>														*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		比例ゲイン計算 : {kx,sx} = (a*b/c)<<sx;														*/
/*																									*/
/****************************************************************************************************/
#pragma arm section code = "MlibPcal"
LONG	MlibPcalKxgain( LONG a, LONG b, LONG c, LONG *psx, LONG smax )
{
LONG	wk;
LONG	kx;
LONG	sx;
LONG	sy;
LONG	sign;
LONG	x,xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		入力処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		sx = (psx != NULL)? (*psx) : 0;
/*--------------------------------------------------------------------------------------------------*/
/*		ゼロ入力チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (a==0)||(b==0)||(c==0) )
		{
			if( psx != NULL ){ *psx = 0;}
			return( 0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		符号処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		sign = 0;
		if( a < 0 ){ a=-a; sign=sign^0x01;}
		if( b < 0 ){ b=-b; sign=sign^0x01;}
		if( c < 0 ){ c=-c; sign=sign^0x01;}
/*--------------------------------------------------------------------------------------------------*/
/*		乗算処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (ULONG)a, (ULONG)b, (ULONG*)xx );
/*--------------------------------------------------------------------------------------------------*/
/*		乗算結果スケーリング : 0x40000000 <= x < 0x80000000											*/
/*--------------------------------------------------------------------------------------------------*/
		if( xx[1] > 0 )
		{
			sy = 32;
			x  = xx[1];
			SCUP31_SXDEC( x, sy, wk );
			x = x + (((ULONG)xx[0])>>(sy));
			sx = sx - sy;
		}
		else if( xx[0] > 0 )
		{
			x  = xx[0];
			SCUP31_SXINC( x, sx, wk );
		}
		else
		{
			sx = sx - 1;
			x  = (((ULONG)xx[0])>>1);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		除算入力スケーリング : 0x40000000 <= c < 0x80000000											*/
/*--------------------------------------------------------------------------------------------------*/
		SCUP31_SXDEC( c, sx, wk );
/*--------------------------------------------------------------------------------------------------*/
/*		除算 : kx = x/c	(32bit/32bit,分解能:24bit)													*/
/*--------------------------------------------------------------------------------------------------*/
		kx = XasmDIVUXA( x, c, &sx, 24 );
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( smax == 0 )									/* 演算継続									*/
		{
			if( sign ){ kx = -kx;}						/* 符号処理									*/
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( smax > 0 )								/* 最終演算結果保存							*/
		{
			kx = kx>>1; sx = sx - 1;					/* kx : 24bit --> 23bit						*/
			if( (sx-smax)>31 ){ kx = 0;}				/* 非常に小さい値の場合						*/
			if(  sx < 0      ){ kx=0x007FFFFF; sx=0;}	/* 最大値で(2^23-1)でリミット				*/
			if(  sx > smax   ){ kx=(kx>>(sx-smax)); sx=smax;}	/* smaxでリミット					*/
			if(  sign != 0   ){ kx = -kx;}				/* 符号処理									*/
			kx = (sx<<24) + (kx&0x00FFFFFF);			/* 演算結果合成処理							*/
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( smax == -1 )							/* 中間演算結果保存							*/
		{
			kx = kx>>1; sx = sx - 1;					/* kx : 24bit --> 23bit						*/
			if( (sx > 127) || (sx < -128) )				/* sxチェック								*/
			{
				kx = sx = 0;							/* 念のため、異常時はゼロとする				*/
			}
			if( sign != 0 ){ kx = -kx;}					/* 符号処理									*/
			kx = (sx<<24) + (kx&0x00FFFFFF);			/* 演算結果合成処理							*/
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( (smax == -2) && CCSW_HsMulgain )		/* 固定小数点ゲイン(16bit.16bit)			*/
		{												/* for MlibHsMulgain, MlibHsIntegral,etc	*/
			sx = sx - 16;
			if( sx == 0 )      { /*kx = kx*/;        }		/* 指数ゼロの場合							*/
			else if( sx >= 24 ){ kx = 0;         }		/* 非常に小さい値の場合						*/
			else if( sx <= -8 ){ kx = 0x7FFFFFFF;}		/* 最大値(2^31-1)でリミット					*/
			else if( sx >= 0  ){ kx = kx>>sx;    }		/* シフト＆切り捨て							*/
			else               { kx = kx<<(-sx); }		/* シフト＆ゼロ詰め							*/
			sx = 16;									/* 指数固定(sx=16)							*/
			if( sign != 0 ){ kx = -kx;}					/* 符号処理									*/
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( smax == -24 )							/* LONG型演算結果保存(四捨五入)				*/
		{
			if( sx < 0 )      { kx = 0x01000000;}		/* 最大値(2^24)でリミット					*/
			else if( sx > 32 ){	kx = 0;         }		/* 非常に小さい値の場合						*/
			else if( sx == 0 ){	/*kx = kx*/; 		}		/* 指数ゼロの場合							*/
			else   { kx = (((kx>>(sx-1))+1)>>1);}		/* シフト＆四捨五入							*/
			sx = 0;										/* 指数ゼロ(sx=0)							*/
			if( sign != 0  ){ kx = -kx;}				/* 符号処理									*/
		}
/*--------------------------------------------------------------------------------------------------*/
		else											/* LONG型演算結果保存(四捨五入)				*/
		{
			kx = kx << 6; sx = sx + 6;
			if( sx < 0 )      { kx = 0x40000000;}   	/* 最大値(2^30)でリミット					*/
			else if( sx > 32 ){	kx = 0;         }   	/* 非常に小さい値の場合						*/
			else if( sx == 0 ){	/*kx = kx*/; 		}   	/* 指数ゼロの場合							*/
			else   { kx = (((kx>>(sx-1))+1)>>1);}		/* シフト＆四捨五入							*/
			sx = 0;										/* 指数ゼロ(sx=0)							*/
			if( sign != 0  ){ kx = -kx;}				/* 符号処理									*/
		}
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL ){ *psx = sx;}
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = {ka,sa}*b/c<<sx;													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKskxkx( LONG ksa, LONG b, LONG c, LONG *psx, LONG smax )
{
LONG	a;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		sx = (ksa>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = a*{kb,sb}/c<<sx;													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxkskx( LONG a, LONG ksb, LONG c, LONG *psx, LONG smax )
{
LONG	b;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		b  = ((ksb<<8)>>8);
		sx = (ksb>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = a*b/{kc,sc}<<sx;													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxkxks( LONG a, LONG b, LONG ksc, LONG *psx, LONG smax )
{
LONG	c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		c  = ((ksc<<8)>>8);
		sx = -(ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = {ka,sa}*{kb,sb}/c<<sx;											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKskskx( LONG ksa, LONG ksb, LONG c, LONG *psx, LONG smax )
{
LONG	a,b;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		b  = ((ksb<<8)>>8);
		sx = (ksa>>24) + (ksb>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = a*{kb,sb}/{kc,sc}<<sx;											*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxksks( LONG a, LONG ksb, LONG ksc, LONG *psx, LONG smax )
{
LONG	b,c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		b  = ((ksb<<8)>>8);
		c  = ((ksc<<8)>>8);
		sx = (ksb>>24) - (ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算 : {kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKsksks( LONG ksa, LONG ksb, LONG ksc, LONG *psx, LONG smax )
{
LONG	a,b,c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		b  = ((ksb<<8)>>8);
		c  = ((ksc<<8)>>8);
		sx = (ksa>>24) + (ksb>>24) - (ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx += sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		比例ゲイン計算(計算開始用) : {kx,sx} = {ka,sa}*b/c<<sx;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKxgain( LONG a, LONG b, LONG c, LONG *psx, LONG smax )
{
LONG	kx;

/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL ){ *psx = 0;}
		kx = MlibPcalKxgain( a, b, c, psx, smax );
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = {ka,sa}*b/c<<sx;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKskxkx( LONG ksa, LONG b, LONG c, LONG *psx, LONG smax )
{
LONG	a;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		sx = (ksa>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = a*{kb,sb}/c<<sx;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKxkskx( LONG a, LONG ksb, LONG c, LONG *psx, LONG smax )
{
LONG	b;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		b  = ((ksb<<8)>>8);
		sx = (ksb>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = a*b/{kc,sc}<<sx;										*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKxkxks( LONG a, LONG b, LONG ksc, LONG *psx, LONG smax )
{
LONG	c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		c  = ((ksc<<8)>>8);
		sx = -(ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = {ka,sa}*{kb,sb}/c<<sx;								*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKskskx( LONG ksa, LONG ksb, LONG c, LONG *psx, LONG smax )
{
LONG	a,b;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		b  = ((ksb<<8)>>8);
		sx = (ksa>>24) + (ksb>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = a*{kb,sb}/{kc,sc}<<sx;								*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKxksks( LONG a, LONG ksb, LONG ksc, LONG *psx, LONG smax )
{
LONG	b,c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		b  = ((ksb<<8)>>8);
		c  = ((ksc<<8)>>8);
		sx = (ksb>>24) - (ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		拡張ゲイン計算(計算開始用) : {kx,sx} = {ka,sa}*{kb,sb}/{kc,sc}<<sx;							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibScalKsksks( LONG ksa, LONG ksb, LONG ksc, LONG *psx, LONG smax )
{
LONG	a,b,c;
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		入力分解処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		a  = ((ksa<<8)>>8);
		b  = ((ksb<<8)>>8);
		c  = ((ksc<<8)>>8);
		sx = (ksa>>24) + (ksb>>24) - (ksc>>24);
/*--------------------------------------------------------------------------------------------------*/
/*		call MlibPcalKxgain()																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( psx != NULL )
		{
			*psx = sx;
			kx = MlibPcalKxgain( a, b, c, psx, smax );
		}
		else
		{
			kx = MlibPcalKxgain( a, b, c, &sx, smax );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		比例ゲイン加算 : {kx,sx} = {ka,sa} + {kb,sb}												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxaddx( LONG ka, LONG sa, LONG kb, LONG sb, LONG *psx )
{
LONG	kx;
LONG	ds;

/*--------------------------------------------------------------------------------------------------*/
/*		指数部演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		ds = sa - sb;
/*--------------------------------------------------------------------------------------------------*/
		if( ka ==   0 ){ *psx = sb; return( kb );}
		if( kb ==   0 ){ *psx = sa; return( ka );}
		if( ds >=  32 ){ *psx = sb; return( kb );}
		if( ds <= -32 ){ *psx = sa; return( ka );}
/*--------------------------------------------------------------------------------------------------*/
		if( ds < 0 ){ kb = (kb>>(-ds));}
		if( ds > 0 ){ ka = (ka>>ds); sa = sb;}
/*--------------------------------------------------------------------------------------------------*/
/*		仮数部演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		kx = ka + kb;
		if( ((ka>0)&&(kb>0)&&(kx<=0)) || ((ka<0)&&(kb<0)&&(kx>=0)) )
		{
			kx = (ka>>1) + (kb>>1); sa--;
		}
		if( kx == 0 ){ sa = 0;}
/*--------------------------------------------------------------------------------------------------*/
		*psx = sa;
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		比例ゲイン減算 : {kx,sx} = {ka,sa} - {kb,sb}												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxsubx( LONG ka, LONG sa, LONG kb, LONG sb, LONG *psx )
{
LONG	kx;
LONG	ds;

/*--------------------------------------------------------------------------------------------------*/
/*		指数部演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		ds = sa - sb;
/*--------------------------------------------------------------------------------------------------*/
		if( (ka == 0) || (ds >= 32)  )
		{
			if( kb == 0x80000000 )
			{
				kb = kb >> 1; sb--;
			}
			*psx = sb; return( -kb );
		}
/*--------------------------------------------------------------------------------------------------*/
		if( kb ==   0 ){ *psx = sa; return(  ka );}
		if( ds <= -32 ){ *psx = sa; return(  ka );}
/*--------------------------------------------------------------------------------------------------*/
		if( ds < 0 ){ kb = (kb>>(-ds));}
		if( ds > 0 ){ ka = (ka>>ds); sa = sb;}
/*--------------------------------------------------------------------------------------------------*/
/*		仮数部演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		kx = ka - kb;
		if( ((ka>0)&&(kb<0)&&(kx<=0)) || ((ka<0)&&(kb>0)&&(kx>=0)) )
		{
			kx = (ka>>1) - (kb>>1); sa--;
		}
		if( kx == 0 ){ sa = 0;}
/*--------------------------------------------------------------------------------------------------*/
		*psx = sa;
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		比例ゲイン乗算 : {kx,sx} = (a*b*c)<<sx;	0x40000000 <= kx < 0x80000000						*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxmulx( LONG a, LONG b, LONG c, LONG *psx )
{
LONG	kx;
LONG	sx;
LONG	wk;
LONG	sign;
LONG	xx[2];
LONG	yy[2];
LONG	zz[2];
LONG	xxx[3];

/*--------------------------------------------------------------------------------------------------*/
/*		ゼロ入力チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (a==0)||(b==0)||(c==0) )
		{
			*psx = 0;
			return( 0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		符号処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		sign = 0;
		if( a < 0 ) { a = -a; sign =  1;}
		if( b < 0 ) { b = -b; sign += 1;}
		if( c < 0 ) { c = -c; sign += 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		乗算処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (ULONG)a,     (ULONG)b, (ULONG*)xx );
		MULU32U32( (ULONG)xx[0], (ULONG)c, (ULONG*)yy );
		MULU32U32( (ULONG)xx[1], (ULONG)c, (ULONG*)zz );
		xxx[0] = yy[0];
		xxx[1] = zz[0] + yy[1];
		xxx[2] = zz[1];
		if( ((ULONG)xxx[1]<(ULONG)zz[0])||((ULONG)xxx[1]<(ULONG)yy[1]) )
		{
			xxx[2] = xxx[2] + 1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		乗算結果スケーリング処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( xxx[2] != 0 )
		{
			sx = 0;
			kx = xxx[2];
			SCUP31_SXINC( kx, sx, wk );
			kx = kx + (((ULONG)xxx[1])>>(32-sx));
			sx = sx - 64;
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( xxx[1] != 0 )
		{
			if( xxx[1] < 0 )
			{
				sx = -33;
				kx = (((ULONG)xxx[1])>>1);
			}
			else
			{
				sx = 0;
				kx = xxx[1];
				SCUP31_SXINC( kx, sx, wk );
				kx = kx + ((((ULONG)xxx[0])>>(31-sx))>>1);
				sx = sx - 32;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			if( xxx[0] < 0 )
			{
				sx = -1;
				kx = (((ULONG)xxx[0])>>1);
			}
			else
			{
				sx = 0;
				kx = xxx[0];
				SCUP31_SXINC( kx, sx, wk );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		終了処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		*psx = *psx + sx;
		if( sign & 0x01 )
		{
			return( -kx );
		}
		else
		{
			return(  kx );
		}

}



/****************************************************************************************************/
/*																									*/
/*		比例ゲイン除算 : {kx,sx} = {ka,sa}/{kb,sb};													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKxdivx( LONG ka, LONG sa, LONG kb, LONG sb, LONG smax )
{
LONG	kx;
LONG	sx;
LONG	wk;
LONG	sign;

/*--------------------------------------------------------------------------------------------------*/
/*		ゼロ入力チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (ka==0)||(kb==0) )
		{
			return( 0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		符号処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		sign = 0;
		if( ka < 0 ) { ka = -ka; sign =  1;}
		if( kb < 0 ) { kb = -kb; sign += 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		スケーリング処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		sx = sa - sb;
		SCUP31_SXINC( ka, sx, wk );
		SCUP31_SXDEC( kb, sx, wk );
/*--------------------------------------------------------------------------------------------------*/
/*		除算処理 : kx = ka/kb	(32bit/32bit,Resolution:23bit)										*/
/*--------------------------------------------------------------------------------------------------*/
		kx = XasmDIVUXA( ka, kb, &sx, 23 );
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (sx-smax)>31 ){ kx = 0;}
		if( sx > smax    ){ kx=(kx>>(sx-smax)); sx=smax;}
		if( sx < 0       ){ kx=0x007FFFFF;      sx=0;   }
		if( sign & 0x01  ){ kx = -kx;}
		kx = (sx<<24) + (kx&0x00FFFFFF);
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}



/****************************************************************************************************/
/*																									*/
/*		１次フィルタゲイン計算																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		1) 時定数 :  kf =  (ts/(tx+ts))<<24															*/
/*																									*/
/*						      (2*hz*ts)*(2^24)														*/
/*		2) 0.1Hz  :  kf = -------------------------  ,  (10^7/pai) = 3183098.862					*/
/*						   (2*hz*ts) + (10^7/pai)													*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalKf1gain(
		LONG	tx,			/* 時定数(Tx)/周波数(Fx)	[xs],[0.1Hz] (X=0:Tx, X=1:Fx)				*/
		LONG	ts,			/* 演算周期					[xs],[us/ns] (Y=0:us, Y=1:ns)				*/
		LONG	insel	)	/* 入力指定(0xYX)			[X:Tx/Fx選択, Y:us/ns選択]					*/
{
LONG	kx;					/* 演算結果																*/
LONG	ax;					/* 被除数作業用															*/
LONG	bx;					/* 除  数作業用															*/
ULONG	xx[2];				/* 作業用																*/

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (tx == 0) || (ts == 0) )
		{
			return( 0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン演算処理 : 時定数[xs]																	*/
/*--------------------------------------------------------------------------------------------------*/
/*				  ts																				*/
/*		kf =  ---------- * (2^24)																	*/
/*				ts + tx																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (insel & 0x0F) == 0x00 )			/* 時定数[xs]										*/
		{
			ax = ts;							/* Min( ax )= 1us									*/
			bx = ts + tx;						/* Max( bx )= 1us + 16777215us (Max(tx)=16.7 sec)	*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン演算処理 : 周波数[0.1Hz] && 演算周期[us]												*/
/*--------------------------------------------------------------------------------------------------*/
/*																									*/
/*					(hz*ts)*(2^24)																	*/
/*		kf = ---------------------------  ,  (10^7/(2*pai)) = 1591549.431							*/
/*			  (hz*ts) + (10^7/(2*pai))																*/
/*																									*/
/*		Ts= 125us : Max.Frequency = 2^32 /  125 / 10 = 3435973.837 Hz								*/
/*		Ts=1000us : Max.Frequency = 2^32 / 1000 / 10 =  429496.729 Hz								*/
/*		Min( kf ) = ((hz*ts) / 1591549) * 2^24 = 10.5414 * (hz*ts) = 10.5414						*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
		else if( (insel & 0xF0) == 0x00 )		/* 周波数[0.1Hz] && 演算周期[us]					*/
		{
			MULU32U32( ts, tx, xx );			/* xx[] = hz*ts										*/
			if( xx[1] > 0x00 ){ return( 0 );}	/* if( (hz*ts) >= 2^32 ){ kf = 0;}					*/
		/*------------------------------------------------------------------------------------------*/
			if( xx[0] >= 0x10000000 ){ ax = (xx[0]>>2); bx = ax +  397887;}
			else                     { ax = (xx[0]<<2); bx = ax + 6366198;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン演算処理 : 周波数[0.1Hz] && 演算周期[ns]												*/
/*--------------------------------------------------------------------------------------------------*/
/*																									*/
/*					(hz*ts)*(2^24)																	*/
/*		kf = ---------------------------  ,  (10^10/(2*pai)) = 1591549431 = 0x5EDD1DF7				*/
/*			  (hz*ts) + (10^10/(2*pai))																*/
/*																									*/
/*		Ts=125us : Max.Frequency = 2^40 / 125000 / 10 = 879609.302 Hz								*/
/*		Min( kf ) = ((hz*ts) / 1591549431) * 2^24 = 0.0105414 * (hz*ts) --> Min( hz*ts ) >= 95		*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
		else if( ts >= 1000 )					/* 周波数[0.1Hz] && 演算周期[ns]					*/
		{
			MULU32U32( ts, tx, xx );			/* xx[] = hz*ts										*/
			if( xx[1] > 0xFF ){ return( 0 );}	/* if( (hz*ts) >= 2^40 ){ kf = 0;}					*/
			bx = (1591549431 >> 2);				/* bx = (0x5EDD1DF7>>2) = 0x17B7477D				*/
		/*------------------------------------------------------------------------------------------*/
			if(      xx[1] > 0x0F ){ ax = (xx[0]>>10) + (xx[1]<<22); bx = ax + (bx>>8);}
			else if( xx[1] > 0x00 ){ ax = (xx[0]>> 6) + (xx[1]<<26); bx = ax + (bx>>4);}
			else                   { ax = (xx[0]>> 2)              ; bx = ax + (bx>>0);}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		入力異常 : 演算周期[ns] < 1000[ns]															*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			return( 0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		除算 : kx = (ax/bx)<<24  (32bit/32bit,Resolution:24bit)										*/
/*--------------------------------------------------------------------------------------------------*/
		kx = XasmDIVUB( ax, bx, 24 );			/* kx = (ax/bx) * 2^24								*/
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}


#if (FLOAT_USE==TRUE)
#if 0
/****************************************************************************************************/
/*																									*/
/*		１次フィルタゲイン計算																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		1) 時定数 :  kf =  (ts/(tx+ts))																*/
/*																									*/
/*		2) 周波数 :  kf =  (ts/(tx+ts))	,  tx = 1/(2*π*fx)											*/
/*						=  (ts/((1/(2*π*fx))+ts)													*/
/*						=  ((ts*fx)/((1/(2*π))+(ts*fx)))											*/
/*																									*/
/****************************************************************************************************/
float	FlibPcalKf1gain(
		LONG	tx,		/* 時定数(tx)/周波数(fx)	[sec],[Hz] (X=0:tx, X=1:fx)					*/
		LONG	ts,		/* 演算周期					[sec] 										*/
		LONG	insel	)	/* 入力指定(0x0X)			[X:tx/fx選択]								*/
{
/////		return( 1.0 );	/* 仮処置 */

float	kx;				/* 演算結果																*/
float	ax;				/* 被除数作業用															*/
float	bx;				/* 除  数作業用															*/

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (tx == (float)0.0) || (ts == (float)0.0) )
		{
			return( 0.0 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン演算処理 : 時定数[xs]																	*/
/*--------------------------------------------------------------------------------------------------*/
/*				  ts																				*/
/*		kf =  ----------																			*/
/*				ts + tx																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (insel & 0x0F) == 0x00 )			/* 時定数[s]										*/
		{
			ax = ts;							/* 													*/
			bx = ts + tx;						/* 													*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ゲイン演算処理 : 周波数[Hz] && 演算周期[s]													*/
/*--------------------------------------------------------------------------------------------------*/
/*																									*/
/*					(ts*fx)																			*/
/*		kf = ---------------------------  															*/
/*			  (1/(2*π)) + (ts*fx)																	*/
/*																									*/
/*--------------------------------------------------------------------------------------------------*/
		else									/* 周波数[Hz] && 演算周期[s]						*/
		{
			ax = tx * ts;						/* 													*/
			bx = (tx * ts) + (1/(2 * PAI));	/* 													*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		除算 : kx = (ax/bx)																			*/
/*--------------------------------------------------------------------------------------------------*/
		kx = ax / bx;							/* kx = (ax/bx)										*/
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		return( kx );

}
#endif //↓todo
#if 1
/****************************************************************************************************/
/*																									*/
/*		１次フィルタゲイン計算																		*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*		1) 時定数 :  kf =  (ts/(tx+ts))<<24															*/
/*																									*/
/*						      (2*hz*ts)*(2^24)														*/
/*		2) 0.1Hz  :  kf = -------------------------  ,  (10^7/pai) = 3183098.862					*/
/*						   (2*hz*ts) + (10^7/pai)													*/
/*																									*/
/****************************************************************************************************/
float	FlibPcalKf1gain(
		LONG	tx,			/* 時定数(Tx)/周波数(Fx)	[xs],[0.1Hz] (X=0:Tx, X=1:Fx)				*/
		LONG	ts,			/* 演算周期					[xs],[us/ns] (Y=0:us, Y=1:ns)				*/
		LONG	insel	)	/* 入力指定(0xYX)			[X:Tx/Fx選択, Y:us/ns選択]					*/
{
	long	Klpf;
	float	fKlpf;

	Klpf = MlibPcalKf1gain( tx, ts, insel );
	fKlpf = (float)Klpf / (float)( 1 << 24 );
	//fKlpf = (float)Klpf;

	return( fKlpf );
}
#endif
#endif /* FLOAT_USE */



/****************************************************************************************************/
/*																									*/
/*		２次フィルタゲイン計算(0.1Hz入力)															*/
/*																									*/
/****************************************************************************************************/
void	MlibPcalKf2gain(
		LONG	hz,			/* フィルタ周波数			[0.1Hz]										*/
		LONG	dx,			/* フィルタ減衰係数(ζ)		[0.001]										*/
		LONG	ts,			/* スキャンタイム			[us/ns] (Y=0:us, Y=1:ns)					*/
		LONG	kf[2],		/* ゲイン演算結果			[--]										*/
		LONG	insel	)	/* 入力指定(0xYX)			[X:not used, Y=us/ns sel.]					*/
{
LONG	sx;					/* 作業用																*/
LONG	ax,as;				/* 乗除算作業用															*/
LONG	bx,bs;				/* 乗除算作業用															*/
LONG	kx[2];				/* 演算結果作業用														*/
LONG	kunit = ((insel & 0xF0)==0)? 1 : 1000;

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (hz == 0) || (ts == 0) || ((insel & 0xF0)&&(ts < 1000)) )
		{
			kf[0] = kf[1] = 0;
			return;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		入力リミット処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( dx <    50 ){ dx =    50;}
		if( dx > 10000 ){ dx = 10000;}
/*--------------------------------------------------------------------------------------------------*/
/*		１次フィルタゲインの計算 : ts:[us], hz:[0.1Hz]												*/
/*--------------------------------------------------------------------------------------------------*/
/*							ts	                        ts*hz										*/
/*		計算式 : kf[0] = --------- * 2^24 = ---------------------------- * 2^24						*/
/*				 		  ts + tx            ts*hz + (10^10/(4*pai*dx))								*/
/*--------------------------------------------------------------------------------------------------*/
		as = bs = 0;
		ax = MlibPcalKxmulx( ts,    hz,        dx, &as ) >> 1;
		bx = MlibPcalKxmulx( kunit, 795774715, 1,  &bs ) >> 1;
		if( as > bs ){ ax = ax >> (as - bs);}		/* Min(ax) = 1us * 1[0.1Hz] * 50 = 50			*/
		if( bs > as ){ bx = bx >> (bs - as);}		/* Max(bx) = 795774715 + 50 = 795774765			*/
		kx[0] = XasmDIVUB( ax, (ax+bx), 24 );		/* kx[0]=(ax/(ax+bx))*2^24 : Min(kx[0])=1.054	*/
/*--------------------------------------------------------------------------------------------------*/
/*		積分ゲインの計算 : ts:[us], hz:[0.1Hz], 													*/
/*--------------------------------------------------------------------------------------------------*/
/*				 			   2*pai*hz*ts		  2*pai*hz*ts		  hz*ts							*/
/*		計算式 : kf[1] = --------------------- = -------------- = ----------------					*/
/*						  2*(dx/1000)*(10^7)	   2*dx*10^4	   dx*3183.098862					*/
/*--------------------------------------------------------------------------------------------------*/
		as = bs = 0;
		ax = MlibPcalKxmulx( ts,    hz, 100000,    &as );
		bx = MlibPcalKxmulx( kunit, dx, 318309886, &bs );
		sx = as - bs;								/* kx[1] = (ax/bx)*2^sx							*/
		kx[1] = XasmDIVUXB( ax, bx, &sx, 23 );		/* Min(kx[1]) = 1/(10000*3183.1)*2^24 = 0.527 	*/
	/*----------------------------------------------------------------------------------------------*/
		if( (sx-24) > 31 ){ kx[1] = 0; sx = 24;}
		else if( sx > 24 ){ kx[1] = (kx[1]>>(sx-24)); sx = 24;}
		if( kx[1] == 0   ){ kx[1] = 1;}				/* Min(kx)= 0.527 = 0 --> 1 (現状不要:ts>1us)	*/
		kx[1] = kx[1] + (sx<<24);					/* kx[1] = {kx,sx}								*/
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		kf[0] = kx[0];
		kf[1] = kx[1];
		return;

}


#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		２次フィルタゲイン計算																		*/
/*																									*/
/****************************************************************************************************/
void	FlibPcalKf2gain(
		float	hz,			/* フィルタ周波数			[Hz]									*/
		float	dx,			/* フィルタ減衰係数(ζ)		[-]										*/
		float	ts,			/* スキャンタイム			[sec]									*/
		float	kf[2])		/* ゲイン演算結果			[--]									*/
{
float	ax;				/* 被除数作業用															*/
float	bx;				/* 除  数作業用															*/

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (hz == (float)0.0) || (ts == (float)0.0) )
		{
			kf[0] = kf[1] = 0.0;
			return;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		入力リミット処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( dx < (float)0.05   ){ dx =  0.05; }
		if( dx > (float)10.000 ){ dx = 10.000;}
/*--------------------------------------------------------------------------------------------------*/
/*		１次フィルタゲインの計算 : ts:[sec], hz:[Hz]												*/
/*--------------------------------------------------------------------------------------------------*/
/*							ts	              ts*hz				        ts*hz*dx					*/
/*		計算式 : kf[0] = ---------  = ------------------------	= ----------------------			*/
/*				 		  ts + tx       ts*hz + (1/(4π*dx))        ts*hz*dx + (1/4π)				*/
/*--------------------------------------------------------------------------------------------------*/
//		ax = ts * hz * dx;						/* 													*/
//		bx = (ts * hz * dx) + (1/(4 * f_PAI));	/* 													*/
		ax = ts * hz * dx * 4 * PAI;			/* 													*/
		bx = ax + 1.0;							/* 													*/
		kf[0] = ax / bx;						/* kf[0] = (ax/bx)									*/
/*--------------------------------------------------------------------------------------------------*/
/*		積分ゲインの計算 : ts:[us], hz:[0.1Hz], 													*/
/*--------------------------------------------------------------------------------------------------*/
/*				 		   (2π*hz*ts)		 (π*hz*ts)		  										*/
/*		計算式 : kf[1] = --------------- = -------------- 											*/
/*						     (2*dx)	            dx													*/
/*--------------------------------------------------------------------------------------------------*/
		ax = (ts * hz * PAI);					/* 													*/
		bx = dx;								/* 													*/
		kf[1] = ax / bx;						/* kf[1] = (ax/bx)									*/
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		return;

}
#endif /* FLOAT_USE */



/****************************************************************************************************/
/*																									*/
/*		２次ノッチフィルタゲイン計算(0.1Hz入力)														*/
/*																									*/
/****************************************************************************************************/
void	MlibPcalKnf2gain(
		LONG	hz,			/* フィルタ周波数					[0.1Hz]								*/
		LONG	qx,			/* Ｑ定数(Qx)／減衰係数(Dx)			[0.001] (X=0:Qx, X=1:Dx)			*/
		LONG	kn,			/* ノッチ深さゲイン					[0.001]								*/
		LONG	ts,			/* スキャンタイム					[us/ns]	(Y=0:us, Y=1:ns)			*/
		LONG	kf[3],		/* ゲイン演算結果					[--]								*/
		LONG	insel	)	/* 入力指定(0xYX)					[X=Qx/Dx sel, Y:us/ns sel]			*/
{
LONG	sx;					/* 作業用																*/
LONG	ax,as;				/* 乗除算作業用															*/
LONG	bx,bs;				/* 乗除算作業用															*/
LONG	kx[3];				/* 演算結果作業用														*/
LONG	xx[2];				/* 32bit*32bit乗算作業用												*/
LONG	qxshl;				/* qx shift left														*/
LONG	kunit = ((insel & 0xF0)==0)? 1 : 1000;

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (hz == 0) || (ts == 0) || ((insel & 0xF0)&&(ts < 1000)) )
		{
			kf[0] = kf[1] = kf[2] = 0;
			return;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		入力選択＆リミット処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( (insel & 0x0F) == 0x00 )
		{
			if( qx <    50 ){ qx =    50;}			/* Lower Limit									*/
			if( qx > 10000 ){ qx = 10000;}			/* Upper Limit									*/
			qxshl = 0;								/* qx shift left								*/
		}
		else
		{
			if( qx <    50 ){ qx =    50;}			/* Lower Limit									*/
			if( qx > 10000 ){ qx = 10000;}			/* Upper Limit									*/
			qx = (500000<<12)/qx;					/* dx --> qx : (500000<<12) = 0x7A120000		*/
			qxshl = 12;								/* qx shift left								*/
		}
		if( kn > 10000 ){ kn = 10000;}
/*--------------------------------------------------------------------------------------------------*/
/*		１次フィルタゲインの計算 : ts:[us], hz:[0.1Hz]												*/
/*--------------------------------------------------------------------------------------------------*/
/*									ts*hz							 ts*hz							*/
/*		計算式 : kf[0] = -------------------------- * 2^24 = ------------------------ * 2^24		*/
/*				 		  ts*hz + qx*10^4/(2*pai)			  ts*hz + qx*1591.549431				*/
/*--------------------------------------------------------------------------------------------------*/
		as = 0; bs = qxshl;
		ax = MlibPcalKxmulx( ts,    hz, 100000,    &as ) >> 1;
		bx = MlibPcalKxmulx( kunit, qx, 159154943, &bs ) >> 1;
		if( as > bs ){ ax = ax >> (as - bs);}		/* Min(ax) = 1us * 1[0.1Hz] * 100000 = 100000	*/
		if( bs > as ){ bx = bx >> (bs - as);}		/* Max(bx) = 159154943*10000 = 1591549430000	*/
		kx[0] = XasmDIVUB( ax, (ax+bx), 24 );		/* kx[0]=(ax/(ax+bx))*2^24 : Min(kx[0])=1.054	*/
/*--------------------------------------------------------------------------------------------------*/
/*		積分ゲインの計算 : ts[us], hz:[0.1Hz]														*/
/*--------------------------------------------------------------------------------------------------*/
/*				 		  qx*2*pai*ts*hz	  qx*ts*hz												*/
/*		計算式 : kf[1] = ---------------- = ------------											*/
/*						   1000*10^6*10      1591549431												*/
/*--------------------------------------------------------------------------------------------------*/
		as = qxshl; bs = 0;
		ax = MlibPcalKxmulx( ts,    hz,         qx, &as );
		bx = MlibPcalKxmulx( kunit, 1591549431, 1,  &bs );
		sx = as - bs;								/* kx[1] = (ax/bx)*2^sx							*/
		kx[1] = XasmDIVUXB( ax, bx, &sx, 23 );		/* Min(kx[1]) = 50/(1591549431)*2^24 = 0.527 	*/
	/*----------------------------------------------------------------------------------------------*/
		if( (sx-24) > 31 ){ kx[1] = 0; sx = 24;}
		else if( sx > 24 ){ kx[1] = (kx[1]>>(sx-24)); sx = 24;}
		if( kx[1] == 0   ){ kx[1] = 1;}				/* Min(kx)= 0.527 = 0 --> 1 (現状不要:ts>1us)	*/
		kx[1] = kx[1] + (sx<<24);					/* kx[1] = {kx,sx}								*/
/*--------------------------------------------------------------------------------------------------*/
/*		ノッチ深さゲインの計算, ノッチ／ＬＰＦ切替えゲインの計算 (計算式は同じ)						*/
/*--------------------------------------------------------------------------------------------------*/
/*				 		   kn             kn*(2^16)*(2^40)/1000	    kn*(2^16)*1099511628			*/
/*		計算式 : kf[2] = ------ * 2^24 = ----------------------- = ----------------------			*/
/*						  1000					  2^32						2^32					*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (kn<<16), 1099511628, (ULONG*)xx );
		kx[2] = xx[1];
/*--------------------------------------------------------------------------------------------------*/
/*		演算終了処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		kf[0] = kx[0];
		kf[1] = kx[1];
		kf[2] = kx[2];
		return;

}
#pragma arm section code



#if 0 /* 現状未使用 */
/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 位置関連演算関数 >>>>>																*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		位置指令補間フィルタ																		*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdIpfil( LONG pcmdin, LONG shift, LONG index, PIPFV *pipfvar )
{
LONG	x;
LONG	outx;

		if( shift == 0 )
		{
			return( pcmdin );
		}

		if( index == 0 )
		{
			pipfvar->cmdx = pcmdin;
		}

		x = pipfvar->cmdx + pipfvar->remx;
		outx = (x >> shift);
		pipfvar->remx = x - (outx << shift);

		return( outx );

}
#endif



/****************************************************************************************************/
/*																									*/
/*		位置指令移動平均フィルタ																	*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdMafil( LONG pcmdin, LONG pmafnum, PMAFV *pmafvar, LONG *pmafbuf )
{
LONG	subx;
LONG	outx;

/*--------------------------------------------------------------------------------------------------*/
/*		移動平均回数チェック																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( pmafnum <= 1 )
		{
			pmafvar->zcntx = (pcmdin != 0)? 1 : 0;
			return( pcmdin );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均バッファ処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		subx = pmafvar->ksub * pmafbuf[pmafvar->idx];
		pmafbuf[pmafvar->idx] = pcmdin;
		if( ++pmafvar->idx >= pmafnum )
		{
			pmafvar->idx = 0;
			pmafvar->ksub = 1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均出力演算処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		pmafvar->sumx = pmafvar->sumx - subx + pcmdin;
		outx = (pmafvar->sumx + pmafvar->remx)/pmafnum;
		pmafvar->remx = (pmafvar->sumx + pmafvar->remx) - (pmafnum * outx);
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均払出し完了情報処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmdin != 0 )
		{
			pmafvar->zcntx = (USHORT)pmafnum;
		}
		else if( pmafvar->zcntx > 0 )
		{
			--pmafvar->zcntx;
		}

		return( outx );

}


LONG	MlibPcmdMafilSec( LONG pcmdin, LONG pmafnum, HIGHFV *pmafvarSec, LONG *pmafbufSec )   /*<S0C3>*/
{
   LONG	subx;
   LONG	outx;

/*--------------------------------------------------------------------------------------------------*/
/*		移動平均回数チェック2   				          													*/
/*--------------------------------------------------------------------------------------------------*/
		if( pmafnum <= 1 )
		{
			pmafvarSec->zcntxSec = (pcmdin != 0)? 1 : 0;
			return( pcmdin );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均バッファ処理2                																*/
/*--------------------------------------------------------------------------------------------------*/
		subx = pmafvarSec->ksubSec * pmafbufSec[pmafvarSec->idxSec];
		pmafbufSec[pmafvarSec->idxSec] = pcmdin;
		if( ++pmafvarSec->idxSec >= pmafnum )
		{
			pmafvarSec->idxSec = 0;
			pmafvarSec->ksubSec = 1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均出力演算処理2      																	*/
/*--------------------------------------------------------------------------------------------------*/
		pmafvarSec->sumxSec = pmafvarSec->sumxSec - subx + pcmdin;
		outx = (pmafvarSec->sumxSec + pmafvarSec->remxSec)/pmafnum;
		pmafvarSec->remxSec = (pmafvarSec->sumxSec + pmafvarSec->remxSec) - (pmafnum * outx);
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均払出し完了情報処理2          															*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmdin != 0 )
		{
			pmafvarSec->zcntxSec = (USHORT)pmafnum;
		}
		else if( pmafvarSec->zcntxSec > 0 )
		{
			--pmafvarSec->zcntxSec;
		}
		return( outx );
}



/****************************************************************************************************/
/*																									*/
/*		位置指令補間移動平均フィルタ																*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdImafil( LONG pcmdin, LONG shift, LONG index, PIMFV *pimfvar )
{
LONG	x;
LONG	outx;

/*--------------------------------------------------------------------------------------------------*/
/*		移動平均回数チェック																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( shift == 0 )
		{
			pimfvar->zcntx = (pcmdin != 0)? 1 : 0;
			return( pcmdin );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均入力処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( index == 0 )
		{
			pimfvar->oldpcmd = pimfvar->newpcmd;
			pimfvar->newpcmd = pcmdin;
			if( pcmdin != 0 )
			{
				pimfvar->zcntx = (2 << shift);
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均出力処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		pimfvar->sumx = pimfvar->sumx + (pimfvar->newpcmd - pimfvar->oldpcmd);
		x = pimfvar->sumx + pimfvar->remx;
		outx = (x >> (2*shift));
		pimfvar->remx = x - (outx << (2*shift));
		if( pimfvar->zcntx > 0 )
		{
			--pimfvar->zcntx;
		}

		return( outx );

}


LONG	MlibPcmdImafilSec( LONG pcmdin, LONG shift, LONG indexSec, HIMFV *pimfvarSec )   /*<S0C3>*/
{
LONG	x;
LONG	outx;
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均回数チェック2         																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( shift == 0 )
		{
			pimfvarSec->zcntxSec = (pcmdin != 0)? 1 : 0;
			return( pcmdin );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均入力処理2      																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( indexSec == 0 )
		{
			pimfvarSec->oldpcmdSec = pimfvarSec->newpcmdSec;
			pimfvarSec->newpcmdSec = pcmdin;
			if( pcmdin != 0 )
			{
				pimfvarSec->zcntxSec = (2 << shift);
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		移動平均出力処理2      																		*/
/*--------------------------------------------------------------------------------------------------*/
		pimfvarSec->sumxSec = pimfvarSec->sumxSec + (pimfvarSec->newpcmdSec - pimfvarSec->oldpcmdSec);
		x = pimfvarSec->sumxSec + pimfvarSec->remxSec;
		outx = (x >> (2*shift));
		pimfvarSec->remxSec = x - (outx << (2*shift));
		if( pimfvarSec->zcntxSec > 0 )
		{
			--pimfvarSec->zcntxSec;
		}

		return( outx );

}



/****************************************************************************************************/
/*																									*/
/*		位置指令指数加減速フィルタ																	*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdExpfil( LONG pcmdin, LONG kexp, LONG pbias, PEXFV *pexfvar )
{
LONG	outx;
LONG	xx[2];
LONG	kx = (kexp<<8);
LONG	sx = (((ULONG)kexp)>>24);

/*--------------------------------------------------------------------------------------------------*/
/*		入力チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( kexp == 0 )
		{
			pexfvar->sumx = 0;
			return( pcmdin );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令合計演算																			*/
/*--------------------------------------------------------------------------------------------------*/
		pexfvar->sumx = pexfvar->sumx + pcmdin;

/*--------------------------------------------------------------------------------------------------*/
/*		指数加減速フィルタ演算																		*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( pexfvar->sumx, kx, xx );
		outx = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( pexfvar->sumx > pbias )
		{
			outx = outx + pbias;
			if( outx > pexfvar->sumx ){ outx = pexfvar->sumx;}
		}
		else if( pexfvar->sumx < -pbias )
		{
			outx = outx - pbias;
			if( outx < pexfvar->sumx ){ outx = pexfvar->sumx;}
		}
		else
		{
			outx = pexfvar->sumx;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		強制収束処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (outx==0)&&(pexfvar->sumx!=0) )
		{
			outx = (pexfvar->sumx > 0)? 1 : -1;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		終了処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		pexfvar->sumx = pexfvar->sumx - outx;
		return( outx );

}



/****************************************************************************************************/
/*																									*/
/*		位置指令１次ローパスフィルタ																*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdLpfil1( LONG pcmdin, LONG kf, LONG *z )
{
LONG	x;
LONG	xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		フィルタゲインゼロ時処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( kf == 0 )
		{
			*z = 0;
			return( pcmdin );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		入力加算																					*/
/*--------------------------------------------------------------------------------------------------*/
		*z = *z + pcmdin;

/*--------------------------------------------------------------------------------------------------*/
/*		１次遅れフィルタゲイン乗算																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( *z, kf, xx );
		x  = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);

/*--------------------------------------------------------------------------------------------------*/
/*		強制収束処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (x==0) && (*z!=0) )
		{
			x = (*z>0)? 1 : -1;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		出力減算																					*/
/*--------------------------------------------------------------------------------------------------*/
		*z = *z - x;
		return( x );
}



/****************************************************************************************************/
/*																									*/
/*		位置指令２次ローパスフィルタ																*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdLpfil2( LONG pcmdin, LONG kf[2], LONG z[2] )
{
LONG	x;
LONG	xx[2];
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		フィルタゲインゼロ時処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( kf[0] == 0 )
		{
			z[0] = z[1] = 0;
			return( pcmdin );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		積分加算																					*/
/*--------------------------------------------------------------------------------------------------*/
		z[0] = z[0] + pcmdin;

/*--------------------------------------------------------------------------------------------------*/
/*		１次遅れ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (z[0]-z[1]), kf[0], xx );
		x = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
		if( (x==0) && (z[1]!=z[0]) )
		{
			x = (z[0]>z[1]) - (z[0]<z[1]);
		}
		z[1] = z[1] + x;

/*--------------------------------------------------------------------------------------------------*/
/*		積分減算																					*/
/*--------------------------------------------------------------------------------------------------*/
		kx = (kf[1]<<8);
		sx = (((ULONG)kf[1])>>24);
		MUL3232( z[1], kx, xx );
		x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
		if( (x==0) && (z[0]!=0) )
		{
			x = (z[0] > 0)? 1 : -1;
		}
		z[0] = z[0] - x;

		return( x );

}


#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		位置指令２次ローパスフィルタ																*/
/*																									*/
/****************************************************************************************************/
float	FlibPcmdLpfil2( float pcmdin, float kf[2], float z[2] )
{
float	x;

/*--------------------------------------------------------------------------------------------------*/
/*		フィルタゲインゼロ時処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( kf[0] == (float)0.0 )
		{
//			z[0] = z[1] = 0;
			z[0] = z[1] = 0.0;
			return( pcmdin );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		積分加算																					*/
/*--------------------------------------------------------------------------------------------------*/
		z[0] = z[0] + pcmdin;

/*--------------------------------------------------------------------------------------------------*/
/*		１次遅れ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		x = ( (z[0]-z[1]) * kf[0] );
		if( (x==(float)0.0) && (z[1]!=z[0]) )
		{
			x = (z[0]>z[1]) - (z[0]<z[1]);
		}
//		z[1] = z[1] + (LONG)x;
		z[1] = z[1] + x;

/*--------------------------------------------------------------------------------------------------*/
/*		積分減算																					*/
/*--------------------------------------------------------------------------------------------------*/
		x = ( z[1] * kf[1] );
//		if( (x==(float)0.0) && (z[0]!=0) )
		if( (x==(float)0.0) && (z[0]!=(float)0.0) )
		{
//			x = (z[0] > 0)? 1 : -1;
			x = (z[0] > 0)? (float)1.0 : (float)-1.0;
		}
//		z[0] = z[0] - (LONG)x;
		z[0] = z[0] - x;

//		return( (LONG)x );
		return( x );
}
#endif /* FLOAT_USE */




/****************************************************************************************************/
/*																									*/
/*		位置指令２次ノッチフィルタ																	*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcmdNxfil2( LONG pcmdin, LONG kf[3], LONG z[3] )
{
LONG	x,rv;
LONG	xx[2];
LONG	kx,sx;

/*--------------------------------------------------------------------------------------------------*/
/*		フィルタゲインゼロ時処理																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( kf[0] == 0 )
		{
			z[0] = z[1] = z[2] = 0;
			return( pcmdin );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		積分加算																					*/
/*--------------------------------------------------------------------------------------------------*/
		z[0] = z[0] + pcmdin;

/*--------------------------------------------------------------------------------------------------*/
/*		１次遅れ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (z[0]-z[1]), kf[0], xx );
		x = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
		if( (x==0) && (z[1]!=z[0]) )
		{
			x = (z[0]>z[1]) - (z[0]<z[1]);
		}
		z[1] = z[1] + x;

/*--------------------------------------------------------------------------------------------------*/
/*		積分減算																					*/
/*--------------------------------------------------------------------------------------------------*/
		kx = (kf[1]<<8);
		sx = (((ULONG)kf[1])>>24);
		MUL3232( z[1], kx, xx );
		x = (xx[1]<<(24-sx)) + (((((ULONG)xx[0]>>sx)>>7)+1)>>1);
		if( (x==0) && (z[0]!=0) )
		{
			x = (z[0] > 0)? 1 : -1;
		}
		z[0] = z[0] - x;

/*--------------------------------------------------------------------------------------------------*/
/*		出力演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( z[1], kf[2], xx );
		x  = z[1] - ((xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1));
		rv = pcmdin - (x - z[2]);
		z[2] = x;

		return( rv );

}



/****************************************************************************************************/
/*																									*/
/*		パルス指令電子ギヤ計算			rv=(B/A)*pcmda												*/
/*																									*/
/****************************************************************************************************/
#if 0
LONG	MlibPcmdEgear( LONG pcmda, EGEAR_DATA *Egear, LONG *pcmdrem )
{
	LONG  pls;

#if ( CSW_SVCF_EGEAR_USE == TRUE )
 /* 電子ギア使用 */
	INT64 wk;
	wk  = ((INT64)pcmda * (INT64)Egear->egear_motor) + (INT64)*pcmdrem;
	pls = (LONG)(wk / Egear->egear_ref);

	*pcmdrem = (LONG)( wk - ((INT64)pls * (INT64)Egear->egear_ref) );
#else
 /* 電子ギア未使用 */
	pls = pcmda;
	*pcmdrem = 0;
#endif

	return pls;
}
#endif

LONG	MlibPcmdEgear( LONG pcmda, EGEAR *egear, LONG *pcmdrem )
{
LONG		pcmdb;				/* 演算結果(パルス指令Ｂ)												*/
LONG	wk1[2];				/* 作業用																*/
LONG	wk2[2];				/* 作業用																*/

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令計算 : pcmdb = k1*pcmda + ((k2*pcmda)>>31);											*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( pcmda, egear->k1, wk1 );
		MUL3232( pcmda, egear->k2, wk2 );
		pcmdb = wk1[0] + (wk2[1]<<1) + ((ULONG)wk2[0]>>31);

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令余り計算 : pcmdrem = pcmdrem + ( B*pcmda - A*pcmdb )								*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( pcmda, egear->b, wk1 );
		MUL3232( pcmdb, egear->a, wk2 );
		*pcmdrem = *pcmdrem + ((ULONG)wk1[0] - (ULONG)wk2[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令余りチェック : (-A/2) <= pcmdrem < (A/2)											*/
/*--------------------------------------------------------------------------------------------------*/
		if( *pcmdrem <  0                 ){ --pcmdb; *pcmdrem += egear->a;}
		if( *pcmdrem >= egear->a          ){ ++pcmdb; *pcmdrem -= egear->a;}
		if( *pcmdrem >= ((egear->a+1)>>1) ){ ++pcmdb; *pcmdrem -= egear->a;}

		return( pcmdb );

}

#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		パルス指令電子ギヤ計算			rv=(B/A)*pcmda												*/
/*																									*/
/****************************************************************************************************/
float	FlibPcmdEgear( float pcmda, EGEAR *egear, float *pcmdrem )
{
	float	pcmdb;				/* 演算結果(パルス指令Ｂ)												*/
	float	wk1;				/* 作業用																*/
	float	wk2;				/* 作業用																*/
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令計算 : pcmdb = k1*pcmda + ((k2*pcmda)>>31);											*/
/*--------------------------------------------------------------------------------------------------*/
		pcmdb = ((pcmda * egear->f_b) / egear->f_a);

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令余り計算 : pcmdrem = pcmdrem + ( B*pcmda - A*pcmdb )								*/
/*--------------------------------------------------------------------------------------------------*/
		wk1 = (pcmda * egear->b);		/* 下記は、下位32Bitが正常演算されることが条件 				*/
		wk2 = (pcmdb * egear->a);		/* (上位32Bitは無視して良い)								*/
		*pcmdrem = *pcmdrem + (wk1 - wk2);

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令余りチェック : (-A/2) <= pcmdrem < (A/2)											*/
/*--------------------------------------------------------------------------------------------------*/
		if( *pcmdrem <  0                 ){ --pcmdb; *pcmdrem += egear->a;}
		if( *pcmdrem >= egear->a          ){ ++pcmdb; *pcmdrem -= egear->a;}
		if( *pcmdrem >= ((egear->a+1)>>1) ){ ++pcmdb; *pcmdrem -= egear->a;}

		return( pcmdb );

}
#endif /* FLOAT_USE */
/****************************************************************************************************/
/*																									*/
/*		電子ギヤ逆変換計算				rv=(A/B)*inpls												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibEgearRvscnv( LONG inpls, EGEAR *egear, LONG *plsrem )
{
LONG	outgr;				/* 演算結果(指令単位)													*/
LONG	wk1[2];				/* 作業用																*/
LONG	wk2[2];				/* 作業用																*/

/*--------------------------------------------------------------------------------------------------*/
/*		電子ギヤ逆変換計算 : outgr = g1*inpls + ((g2*inpls)>>31);									*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( inpls, egear->g1, wk1 );
		MUL3232( inpls, egear->g2, wk2 );
		outgr = wk1[0] + (wk2[1]<<1) + ((ULONG)wk2[0]>>31);

/*--------------------------------------------------------------------------------------------------*/
/*		電子ギヤ逆変換余り計算 : plsrem = plsrem + ( A*inpls - B*outgr )							*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( inpls, egear->a, wk1 );
		MUL3232( outgr, egear->b, wk2 );
		*plsrem = *plsrem + ((ULONG)wk1[0] - (ULONG)wk2[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		電子ギヤ逆変換余りチェック : (-B/2) <= plsrem < (B/2)										*/
/*--------------------------------------------------------------------------------------------------*/
		if( *plsrem <  0                 ){ --outgr; *plsrem += egear->b;}
		if( *plsrem >= egear->b          ){ ++outgr; *plsrem -= egear->b;}
		if( *plsrem >= ((egear->b+1)>>1) ){ ++outgr; *plsrem -= egear->b;}

		return( outgr );

}



/****************************************************************************************************/
/*																									*/
/*		電子ギヤゲイン計算																			*/
/*																									*/
/****************************************************************************************************/
void	MlibPcalKegear( LONG a, LONG b, EGEAR *egear )
{
ULONG	k1,k2;
ULONG	g1,g2;

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令用電子ギヤ(k1,k2)の計算																*/
/*--------------------------------------------------------------------------------------------------*/
		k1 = b/a;								/* k1の計算(上位32bit)								*/
		k2 = XasmDIVUA( (b%a), a, 31 );			/* k2の計算(下位31bit)								*/

/*--------------------------------------------------------------------------------------------------*/
/*		位置ＦＢ用電子ギヤ(g1,g2)の計算																*/
/*--------------------------------------------------------------------------------------------------*/
		g1 = a/b;								/* g1の計算(上位32bit)								*/
		g2 = XasmDIVUA( (a%b), b, 31 );			/* g2の計算(下位31bit)								*/

/*--------------------------------------------------------------------------------------------------*/
/*		電子ギヤパラメータ設定																		*/
/*--------------------------------------------------------------------------------------------------*/
		egear->a  = a;
		egear->b  = b;
		egear->k1 = k1;
		egear->k2 = k2;
		egear->g1 = g1;
		egear->g2 = g2;

		return;

}


#if 0
/****************************************************************************************************/
/*																									*/
/*		位置偏差計算Ａ(指令単位)																	*/
/*																									*/
/****************************************************************************************************/
void	MlibPerrcala( LONG pcmda, LONG pfbka, EGEAR_DATA *Egear, PERRA *perra )
{
	INT64	wk; 
	LONG	perrx;				/* 位置偏差計算作業用												*/

#if ( CSW_SVCF_EGEAR_USE == TRUE )
 /* 電子ギア使用 */

	wk = ((INT64)pfbka * (INT64)Egear->egear_ref) + (INT64)perra->pfbkrem;
	perra->pfbkb = (LONG)( wk / Egear->egear_motor );
	perra->pfbkrem = (LONG)(wk - (perra->pfbkb * Egear->egear_motor) );

#else
/* 電子ギア不使用 */
	perra->pfbkb = pfbka;
	perra->pfbkrem = 0;

#endif
/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差計算(指令単位)																		*/
/*--------------------------------------------------------------------------------------------------*/
	perrx = pcmda - perra->pfbkb;
	perra->per64.ld64 = perra->per64.ld64 + (INT64)perrx;
	perrx = (perra->per64.ld32.high<<2) + (((ULONG)perra->per64.ld32.low)>>30);
	if( perrx > 0 )
	{
		perra->per32s =  0x3FFFFFFF;
	}
	else if( perrx < -1 )
	{
		perra->per32s = -0x40000000;
	}
	else
	{
		perra->per32s = perra->per64.ld32.low;
	}
	perra->per32a = MlibLABS( perra->per32s );
/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差切り上げ計算(指令単位)																*/
/*--------------------------------------------------------------------------------------------------*/
	perra->per32sx = perra->per32s;
	if( (perra->pfbkrem < 0)&&( perra->per32s >= 0) )
	{
		perra->per32sx += 1;
	}
	if( (perra->pfbkrem > 0)&&( perra->per32s <= 0) )
	{
		perra->per32sx -= 1;
	}
	perra->per32ax = MlibLABS( perra->per32sx );

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差モニタ計算(指令単位,切り上げ／ゼロ)													*/
/*--------------------------------------------------------------------------------------------------*/
	if( perra->per32s == 0 )
	{
		perra->per32mx = 0;
	}
	else
	{
		perra->per32mx = perra->per32sx;
	}
}
#endif



void	MlibPerrcala( LONG pcmda, LONG pfbka, EGEAR *egear, PERRA *perra )
{
LONG	perrx;				/* 位置偏差計算作業用													*/
LONG	carry;				/* Carry of (per64[0]+perrx)											*/
LONG	wk1[2];				/* 作業用																*/
LONG	wk2[2];				/* 作業用																*/

/*--------------------------------------------------------------------------------------------------*/
/*		位置ＦＢ計算(指令単位)																		*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( egear->g1, pfbka, wk1 );
		MUL3232( egear->g2, pfbka, wk2 );
		perra->pfbkb = wk1[0] + (wk2[1]<<1) + ((ULONG)wk2[0]>>31);
		MUL3232( egear->a, pfbka, wk1 );
		MUL3232( egear->b, perra->pfbkb, wk2 );
		perra->pfbkrem = perra->pfbkrem + ((ULONG)wk1[0] - (ULONG)wk2[0]);

		if( perra->pfbkrem <  0                 ){ --(perra->pfbkb); perra->pfbkrem += egear->b;}
		if( perra->pfbkrem >= egear->b          ){ ++(perra->pfbkb); perra->pfbkrem -= egear->b;}
		if( perra->pfbkrem >= ((egear->b+1)>>1) ){ ++(perra->pfbkb); perra->pfbkrem -= egear->b;}

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差計算(指令単位)																		*/
/*--------------------------------------------------------------------------------------------------*/
		perrx = pcmda - perra->pfbkb;
		carry = (((ULONG)(perra->per64[0]+perrx)) < ((ULONG)(perra->per64[0])));
		perra->per64[0] = perra->per64[0] + (perrx);
		perra->per64[1] = perra->per64[1] + (perrx>>31) + carry;
		perrx = (perra->per64[1]<<2) + (((ULONG)perra->per64[0])>>30);
		if( perrx > 0       ) perra->per32s =  0x3FFFFFFF;
		else if( perrx < -1 ) perra->per32s = -0x40000000;
		else                  perra->per32s =  perra->per64[0];
		perra->per32a = (perra->per32s>=0)? perra->per32s : -perra->per32s;

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差切り上げ計算(指令単位)																*/
/*--------------------------------------------------------------------------------------------------*/
		perra->per32sx = perra->per32s;
		if( (perra->pfbkrem < 0)&&( perra->per32s >= 0) ) perra->per32sx += 1;
		if( (perra->pfbkrem > 0)&&( perra->per32s <= 0) ) perra->per32sx -= 1;
		perra->per32ax = (perra->per32sx>=0)? perra->per32sx : -perra->per32sx;

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差モニタ計算(指令単位,切り上げ／ゼロ)													*/
/*--------------------------------------------------------------------------------------------------*/
		perra->per32mx = (perra->per32s==0)? 0 : perra->per32sx;

		return;
}


#if (FLOAT_USE==TRUE)
void	FlibPerrcala( LONG pcmda, LONG pfbka, EGEAR *egear, PERRA *perra )
{
LONG	perrx;				/* 位置偏差計算作業用													*/
LONG	carry;				/* Carry of (per64[0]+perrx)											*/
LONG	wk1;				/* 作業用																*/
LONG	wk2;				/* 作業用															*/

/*--------------------------------------------------------------------------------------------------*/
/*		位置ＦＢ計算(指令単位)																		*/
/*--------------------------------------------------------------------------------------------------*/

		perra->pfbkb = (LONG)((pfbka * egear->f_a) / egear->f_b);

		wk1 = (pfbka * egear->a);		/* 下記は、下位32Bitが正常演算されることが条件 				*/
		wk2 = (perra->pfbkb * egear->b);/* (上位32Bitは無視して良い)								*/
		perra->pfbkrem = perra->pfbkrem + ((ULONG)wk1 - (ULONG)wk2);

		if( perra->pfbkrem <  0                 ){ --(perra->pfbkb); perra->pfbkrem += egear->b;}
		if( perra->pfbkrem >= egear->b          ){ ++(perra->pfbkb); perra->pfbkrem -= egear->b;}
		if( perra->pfbkrem >= ((egear->b+1)>>1) ){ ++(perra->pfbkb); perra->pfbkrem -= egear->b;}

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差計算(指令単位)																		*/
/*--------------------------------------------------------------------------------------------------*/
		perrx = pcmda - perra->pfbkb;
		carry = (((ULONG)(perra->per64[0]+perrx)) < ((ULONG)(perra->per64[0])));
		perra->per64[0] = perra->per64[0] + (perrx);
		perra->per64[1] = perra->per64[1] + (perrx>>31) + carry;
		perrx = (perra->per64[1]<<2) + (((ULONG)perra->per64[0])>>30);
		if( perrx > 0       ) perra->per32s =  0x3FFFFFFF;
		else if( perrx < -1 ) perra->per32s = -0x40000000;
		else                  perra->per32s =  perra->per64[0];
		perra->per32a = (perra->per32s>=0)? perra->per32s : -perra->per32s;

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差切り上げ計算(指令単位)																*/
/*--------------------------------------------------------------------------------------------------*/
		perra->per32sx = perra->per32s;
		if( (perra->pfbkrem < 0)&&( perra->per32s >= 0) ) perra->per32sx += 1;
		if( (perra->pfbkrem > 0)&&( perra->per32s <= 0) ) perra->per32sx -= 1;
		perra->per32ax = (perra->per32sx>=0)? perra->per32sx : -perra->per32sx;

/*--------------------------------------------------------------------------------------------------*/
/*		位置偏差モニタ計算(指令単位,切り上げ／ゼロ)													*/
/*--------------------------------------------------------------------------------------------------*/
		perra->per32mx = (perra->per32s==0)? 0 : perra->per32sx;

		return;
}
#endif /* FLOAT_USE */

/****************************************************************************************************/
/*																									*/
/*		位置偏差計算Ｘ(ＦＢ単位)		per64[]=per64[]+pcmd-pfbk; rv=per64[0];						*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPerrcalx( LONG pcmdx, LONG pfbkx, LONG per64[2] )
{
LONG	perrx;				/* パルス偏差															*/
LONG	carry;				/* Carry of (per64[0]+perrx)											*/
LONG	perrchk;			/* パルス偏差チェック用													*/

		perrx = pcmdx - pfbkx;
		carry = (((ULONG)(per64[0]+perrx)) < ((ULONG)(per64[0])));

		per64[0] = per64[0] + (perrx);
		per64[1] = per64[1] + (perrx>>31) + carry;

		perrchk = (per64[1]<<2) + (((ULONG)per64[0])>>30);
		if( perrchk >  0 ){ return(  0x3FFFFFFF );}
		if( perrchk < -1 ){ return( -0x40000000 );}

		return( per64[0] );

}



#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		位置偏差計算Ｘ(ＦＢ単位)		per64[]=per64[]+pcmd-pfbk; rv=per64[0];						*/
/*																									*/
/****************************************************************************************************/
LONG	FlibPerrcalx( LONG pcmdx, LONG pfbkx, LONG per64[2] )	/* 仮処置	*/
{
LONG	perrx;				/* パルス偏差															*/
LONG	carry;				/* Carry of (per64[0]+perrx)											*/
LONG	perrchk;			/* パルス偏差チェック用													*/

		perrx = pcmdx - pfbkx;
		carry = (((ULONG)(per64[0]+perrx)) < ((ULONG)(per64[0])));

		per64[0] = per64[0] + (perrx);
		per64[1] = per64[1] + (perrx>>31) + carry;

		perrchk = (per64[1]<<2) + (((ULONG)per64[0])>>30);
		if( perrchk >  0 ){ return(  0x3FFFFFFF );}
		if( perrchk < -1 ){ return( -0x40000000 );}

		return( per64[0] );

}
#endif /* FLOAT_USE */


/****************************************************************************************************/
/*																									*/
/*		初期絶対位置計算(逆電子ギヤ：ＦＢ単位-->指令単位)											*/
/*																									*/
/****************************************************************************************************/
void	MlibAposRg64iv( LONG inipos0, LONG inipos1, EGEAR *egear, APOSRG *aposrg )
{
LONG	i;
LONG	sign;				/* Sign of inipos1														*/
LONG	carry;				/* Carry																*/
LONG	xx[4];				/* 作業用																*/
LONG	y0,y1;				/* 作業用																*/
LONG	b = egear->b;		/* 電子ギヤＢ															*/

/*--------------------------------------------------------------------------------------------------*/
/*		符号チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( inipos1 >= 0 )
		{
			sign = 0;
		}
		else
		{
			sign = 1;
			inipos0 = (~inipos0) + 1;
			inipos1 = (~inipos1) + (inipos0 == 0);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		乗算(64bit*32bit)																			*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (ULONG)inipos0, (ULONG)egear->a, (ULONG*)&xx[0] );
		MULU32U32( (ULONG)inipos1, (ULONG)egear->a, (ULONG*)&xx[2] );
		carry = ( (ULONG)xx[2] > ((ULONG)xx[2]+(ULONG)xx[1]) );
		xx[2] = xx[2] + xx[1];
		xx[3] = xx[3] + carry;
/*--------------------------------------------------------------------------------------------------*/
/*		除算(96bit/32bit)																			*/
/*--------------------------------------------------------------------------------------------------*/
		for( y1=0,i=0; i<32; i++ )
		{
			y1 = (y1<<1);
			xx[3] = (xx[3]<<1) + ((ULONG)xx[2]>>31);
			xx[2] = (xx[2]<<1);
			if( (ULONG)xx[3] >= (ULONG)b )
			{
				y1 = y1 + 1;
				xx[3] = (ULONG)xx[3] - (ULONG)b;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		for( y0=0,i=0; i<32; i++ )
		{
			y0 = (y0<<1);
			xx[3] = (xx[3]<<1) + ((ULONG)xx[0]>>31);
			xx[0] = (xx[0]<<1);
			if( (ULONG)xx[3] >= (ULONG)b )
			{
				y0 = y0 + 1;
				xx[3] = (ULONG)xx[3] - (ULONG)b;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		if( xx[3] >= ((b+1)>>1) )
		{
			xx[3] = xx[3] - b;
			y0    = y0 + 1;
			y1    = y1 + (y0==0);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		演算結果格納																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( sign != 0 )
		{
			y0 = (~y0) + 1;
			y1 = (~y1) + (y0 == 0);
			xx[3] = -xx[3];
		}
		aposrg->dposix  = 0;				/* 差分位置						*/
		aposrg->aposrem = xx[3];			/* 位置余り						*/
		aposrg->apos[0] = y0;				/* 絶対位置下位32bit			*/
		aposrg->apos[1] = y1;				/* 絶対位置上位32bit			*/

		return;

}



/****************************************************************************************************/
/*																									*/
/*		絶対位置更新計算(逆電子ギヤ：ＦＢ単位-->指令単位)											*/
/*																									*/
/****************************************************************************************************/
void	MlibAposRg64dp( LONG dposin, EGEAR *egear, APOSRG *aposrg, LONG *latchpos )
{
LONG	carry;							/* Carry													*/
LONG	wk1[2];							/* 作業用													*/
LONG	wk2[2];							/* 作業用													*/
LONG	dposix;							/* 差分位置(指令単位)										*/
LONG	aposrem = aposrg->aposrem;		/* 絶対位置余り												*/

/*--------------------------------------------------------------------------------------------------*/
/*		逆電子ギヤ計算(指令単位)																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( egear->g1, dposin, &wk1[0] );
		MUL3232( egear->g2, dposin, &wk2[0] );
		dposix = wk1[0] + (wk2[1]<<1) + ((ULONG)wk2[0]>>31);
		MUL3232( egear->a, dposin, &wk1[0] );
		MUL3232( egear->b, dposix, &wk2[0] );
		aposrem = aposrem + ((ULONG)wk1[0] - (ULONG)wk2[0]);
/*--------------------------------------------------------------------------------------------------*/
/*		位置余り処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( aposrem <  0                 ){ --dposix; aposrem += egear->b;}
		if( aposrem >= egear->b          ){ ++dposix; aposrem -= egear->b;}
		if( aposrem >= ((egear->b+1)>>1) ){ ++dposix; aposrem -= egear->b;}
/*--------------------------------------------------------------------------------------------------*/
/*		絶対位置更新計算(指令単位)																	*/
/*--------------------------------------------------------------------------------------------------*/
		if( latchpos == NULL )
		{
			aposrg->dposix  = dposix;
			aposrg->aposrem = aposrem;
			aposrg->apos[0] = aposrg->apos[0] + dposix;
			carry = ((ULONG)aposrg->apos[0] < (ULONG)dposix)? 1 : 0;
			aposrg->apos[1] = aposrg->apos[1] + (dposix>>31) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		絶対位置ラッチ計算(指令単位)																*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			latchpos[0] = aposrg->apos[0] + dposix;
			carry = ((ULONG)latchpos[0] < (ULONG)aposrg->apos[0])? 1 : 0;
			latchpos[1] = aposrg->apos[1] + (dposix>>31) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
		return;

}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 位置指令作成器関数 >>>>>																*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		位置指令作成器初期パラメータ計算															*/
/*																									*/
/****************************************************************************************************/
LONG	MlibIpcalPcmdMaker(
		KSGAIN	ksosvp,					/* ＯＳパルス速度					[xpulse/scan]			*/
		LONG	maxspdm,				/* 最大モータ速度					[2^24/OvrSpd]			*/
		LONG	maxspdi,				/* 補間モード最大速度				[2^24/OvrSpd]			*/
		LONG	pcmd64f,				/* 位置指令６４ビットフラグ			[TRUE/FALSE]			*/
		PCMKP	*pcmkprm	)			/* 計算結果出力構造体ポインタ		[-]						*/
{
LONG	kx,sx;
ULONG	xx[2];
ULONG	yy[2];

/*--------------------------------------------------------------------------------------------------*/
/*		ＯＳモータパルス速度[xpulse/scan]															*/
/*--------------------------------------------------------------------------------------------------*/
		//sx = (ksosvp >> 24) + 1;
		//kx = ((ksosvp << 8 ) >> 7);
		sx = ((LONG)ksosvp >> 24) + 1;		
		kx = (((LONG)ksosvp << 8 ) >> 7);
		if( sx > 16 )
		{
			kx = (kx >> (sx - 16));
			sx = 16;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		最大モータパルス速度[xpulse/scan] : maxvpm = osvpm * maxspdm / 2^24							*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (kx << 8), maxspdm, xx );

/*--------------------------------------------------------------------------------------------------*/
/*		補間モード最大パルス速度[xpulse/scan] : maxipv = osvpm * maxspdi / 2^24						*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (kx << 8), maxspdi, yy );

/*--------------------------------------------------------------------------------------------------*/
/*		パラメータ設定																				*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkprm->osvpm   = kx;
		pcmkprm->maxvpm  = xx[1];
		pcmkprm->maxipv  = yy[1];
		pcmkprm->pshlx   = (UCHAR)sx;
		pcmkprm->pcmd64f = (UCHAR)pcmd64f;

		return( TRUE );

}



/****************************************************************************************************/
/*																									*/
/*		位置指令作成器位置決めパラメータ計算Ａ														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalaPcmdMaker(
		LONG	maxspd,					/* 最大速度							[2^24/OvrSpd]			*/
		LONG	acctime,				/* 加速時間							[xs]					*/
		LONG	dectime,				/* 減速時間							[xs]					*/
		LONG	scantime,				/* スキャンタイム					[xs]					*/
		PCMKP	*pcmkprm	)			/* 計算結果出力構造体ポインタ		[-]						*/
{
LONG	maxvp;
ULONG	xx[2];
PCMKP	wkprm;

/*--------------------------------------------------------------------------------------------------*/
/*		最大位置指令速度[xpulse/scan] : maxvp = osvpm * maxspd / 2^24								*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (pcmkprm->osvpm << 8), maxspd, xx );
		maxvp = (xx[1] > 0)? xx[1] : 0;
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令加速度[xpulse/scan/scan] : vpacc = maxvp * scantime / acctime						*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpacc = MlibScalKxgain( maxvp, scantime, acctime, NULL, -24 );
		if( wkprm.vpacc <= 0 ){ wkprm.vpacc = 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令減速度[xpulse/scan/scan] : vpdec = maxvp * scantime / dectime						*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpdec = MlibScalKxgain( maxvp, scantime, dectime, NULL, -24 );
		if( wkprm.vpdec <= 0 ){ wkprm.vpdec = 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		商(vpamx), 余り(vparx), 加速分減速停止パルス量(vpapx)										*/
/*--------------------------------------------------------------------------------------------------*/
/*		vpamx = vpacc / vpdec																		*/
/*		vparx = vpacc % vpdec																		*/
/*		vpapx = (vpamx + 1) * (vpacc + vparx) / 2													*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpamx = wkprm.vpacc / wkprm.vpdec;
		wkprm.vparx = wkprm.vpacc - (wkprm.vpamx*wkprm.vpdec);
		if( wkprm.vpamx & 0x0001 )
		{
			wkprm.vpapx = ((wkprm.vpamx+1)>>1)*(wkprm.vpacc+wkprm.vparx);
		}
		else
		{
			wkprm.vpapx = (wkprm.vpamx+1)*((wkprm.vpacc+wkprm.vparx)>>1);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		パラメータ設定																				*/
/*--------------------------------------------------------------------------------------------------*/
//		KPI_DI( );		/* 20130828版初期化時の割込みを防ぐためコメントアウト　要検討　*/
		pcmkprm->vpacc  = wkprm.vpacc;
		pcmkprm->vpdec  = wkprm.vpdec;
		pcmkprm->vpamx  = wkprm.vpamx;
		pcmkprm->vparx  = wkprm.vparx;
		pcmkprm->vpapx  = wkprm.vpapx;
		pcmkprm->maxspd = maxspd;
//		KPI_EI( );		/* 20130828版初期化時の割込みを防ぐためコメントアウト　要検討　*/
/*--------------------------------------------------------------------------------------------------*/
		return( TRUE );

}



#if 0 /* 現状未使用 */
/****************************************************************************************************/
/*																									*/
/*		位置指令作成器補間演算パラメータ計算Ａ														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalaPcmdMkrIP(				/* 位置指令作成器補間演算パラメータ計算Ａ					*/
		LONG	iptimes,				/* 補間回数							[-]						*/
		LONG	maxspd,					/* 最大速度							[2^24/OvrSpd]			*/
		LONG	ipacctm,				/* 最小加減速時間					[xs]					*/
		LONG	ipdectm,				/* 非常停止減速時間					[xs]					*/
		LONG	scantime,				/* スキャンタイム					[xs]					*/
		PCMKP	*pcmkprm	)			/* 計算結果出力構造体ポインタ		[-]						*/
{
LONG	xx[2];
LONG	kx,sx,sy;
LONG	ipmaxacc;
LONG	ipstpdec;
LONG	IPcycle = scantime * iptimes;

/*--------------------------------------------------------------------------------------------------*/
/*		共通項計算 : 補間モード最大加減速度＆非常停止減速度											*/
/*--------------------------------------------------------------------------------------------------*/
/*					osvpm * maxspd * IPcycle														*/
/*		{kx,sx} = ----------------------------														*/
/*						 2^pshlx * 2^24																*/
/*--------------------------------------------------------------------------------------------------*/
		sx = pcmkprm->pshlx + 24;
		kx = MlibPcalKxmulx( maxspd, pcmkprm->osvpm, IPcycle, &sx );
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード最大速度 [ipulse/IPcycle]															*/
/*--------------------------------------------------------------------------------------------------*/
/*					 maxipv * iptimes																*/
/*		ipmaxspd = --------------------																*/
/*						 2^pshlx																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( pcmkprm->maxipv, iptimes, &xx[0] );
		xx[0] = ((xx[1]<<(31-pcmkprm->pshlx))<<1) + ((ULONG)xx[0]>>pcmkprm->pshlx);
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード最大加減速度 [ipulse/IPcycle^2]													*/
/*--------------------------------------------------------------------------------------------------*/
/*					 osvpm * maxspd * IPcycle * iptimes			  iptimes							*/
/*		ipmaxacc = -------------------------------------- = kx * ---------							*/
/*						  2^pshlx * 2^24 * ipacctm				  ipacctm							*/
/*--------------------------------------------------------------------------------------------------*/
		if( ipacctm <= 0 )
		{
			ipmaxacc = xx[0];
		}
		else
		{
			sy = sx;
			ipmaxacc = MlibPcalKxgain( kx, iptimes, ipacctm, &sy, -24 );
			if( ipmaxacc <= 0 ){ ipmaxacc = 1;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード非常停止減速度 [ipulse/IPcycle^2]													*/
/*--------------------------------------------------------------------------------------------------*/
/*					 osvpm * maxspd * IPcycle * iptimes			  iptimes							*/
/*		ipstpdec = -------------------------------------- = kx * ---------							*/
/*						  2^pshlx * 2^24 * ipdectm				  ipdectm							*/
/*--------------------------------------------------------------------------------------------------*/
		if( ipdectm <= 0 )
		{
			ipstpdec = xx[0];
		}
		else
		{
			sy = sx;
			ipstpdec = MlibPcalKxgain( kx, iptimes, ipdectm, &sy, -24 );
			if( ipstpdec <= 0 ){ ipstpdec = 1;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		パラメータ設定																				*/
/*--------------------------------------------------------------------------------------------------*/
		KPI_DI( );
		pcmkprm->iptimes  = (USHORT)iptimes;
		pcmkprm->ipmaxspd = xx[0];
		pcmkprm->ipmaxacc = ipmaxacc;
		pcmkprm->ipstpdec = ipstpdec;
		KPI_EI( );
/*--------------------------------------------------------------------------------------------------*/
		return( TRUE );

}
#endif



/****************************************************************************************************/
/*																									*/
/*		位置指令作成器位置決めパラメータ計算Ｂ														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalbPcmdMaker(
		LONG	accrate,				/* 加速レート					[10000pulse/s/s]			*/
		LONG	decrate,				/* 減速レート					[10000pulse/s/s]			*/
		LONG	scantime,				/* スキャンタイム				[us(Y=0)/ns(Y=1)]			*/
		PCMKP	*pcmkprm,				/* 計算結果出力構造体ポインタ	[-]							*/
		LONG	insel		)			/* 入力選択(0xYX)				[X:不使用, Y:us/ns選択]		*/
{
LONG	kx,sx;
PCMKP	wkprm;
LONG	kunit = ((insel & 0xF0)==0)? 1 : 1000;

/*--------------------------------------------------------------------------------------------------*/
/*		共通項演算																					*/
/*--------------------------------------------------------------------------------------------------*/
/*			   10000 * scantime * scantime * 2^pshlx												*/
/*		kx = -----------------------------------------												*/
/*					kunit * kunit * 10^6 * 10^6														*/
/*--------------------------------------------------------------------------------------------------*/
		sx = pcmkprm->pshlx; kx = MlibPcalKxmulx( kunit, kunit, 100000000, &sx );
		sx = -sx;			 kx = MlibPcalKxgain( scantime, scantime, kx, &sx, -1 );
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令加速度[xpulse/scan/scan]															*/
/*--------------------------------------------------------------------------------------------------*/
/*				 10000 * scantime * scantime * 2^pshlx												*/
/*		vpacc = --------------------------------------- * accrate									*/
/*					kunit * kunit * 10^6 * 10^6														*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpacc = MlibScalKskxkx( kx, accrate, 1, NULL, -24 );
		if( wkprm.vpacc <= 0 ){ wkprm.vpacc = 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令減速度[xpulse/scan/scan]															*/
/*--------------------------------------------------------------------------------------------------*/
/*				 10000 * scantime * scantime * 2^pshlx												*/
/*		vpdec = --------------------------------------- * decrate									*/
/*					kunit * kunit * 10^6 * 10^6														*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpdec = MlibScalKskxkx( kx, decrate, 1, NULL, -24 );
		if( wkprm.vpdec <= 0 ){ wkprm.vpdec = 1;}
/*--------------------------------------------------------------------------------------------------*/
/*		商(vpampx), 余り(vparx), 加速分減速停止パルス量(vpapx)										*/
/*--------------------------------------------------------------------------------------------------*/
/*		vpamx = vpacc / vpdec																		*/
/*		vparx = vpacc % vpdec																		*/
/*		vpapx = (vpamx + 1) * (vpacc + vparx) / 2													*/
/*--------------------------------------------------------------------------------------------------*/
		wkprm.vpamx = wkprm.vpacc / wkprm.vpdec;
		wkprm.vparx = wkprm.vpacc - (wkprm.vpamx*wkprm.vpdec);
		if( wkprm.vpamx & 0x0001 )
		{
			wkprm.vpapx = ((wkprm.vpamx+1)>>1)*(wkprm.vpacc+wkprm.vparx);
		}
		else
		{
			wkprm.vpapx = (wkprm.vpamx+1)*((wkprm.vpacc+wkprm.vparx)>>1);
		}
/*--------------------------------------------------------------------------------------------------*/
/*		パラメータ設定																				*/
/*--------------------------------------------------------------------------------------------------*/
		KPI_DI( );
		pcmkprm->vpacc = wkprm.vpacc;
		pcmkprm->vpdec = wkprm.vpdec;
		pcmkprm->vpamx = wkprm.vpamx;
		pcmkprm->vparx = wkprm.vparx;
		pcmkprm->vpapx = wkprm.vpapx;
		KPI_EI( );
/*--------------------------------------------------------------------------------------------------*/
		return( TRUE );

}



#if 0 /* 現状未使用 */
/****************************************************************************************************/
/*																									*/
/*		位置指令作成器補間演算パラメータ計算Ｂ														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibPcalbPcmdMkrIP(				/* 位置指令作成器補間演算パラメータ計算Ｂ					*/
		LONG	iptimes,				/* 補間回数						[-]							*/
		LONG	ipaccrt,				/* 最大加減速レート				[10000pulse/s/s]			*/
		LONG	ipdecrt,				/* 非常停止減速レート			[10000pulse/s/s]			*/
		LONG	scantime,				/* スキャンタイム				[us(Y=0)/ns(Y=1)]			*/
		PCMKP	*pcmkprm,				/* 計算結果出力構造体ポインタ	[--]						*/
		LONG	insel		)			/* 入力選択(0xYX)				[X:不使用, Y:us/ns選択]		*/
{
LONG	xx[2];
LONG	kx,sx,sy;
LONG	ipmaxacc;
LONG	ipstpdec;
LONG	IPcycle = scantime * iptimes;
LONG	kunit = ((insel & 0xF0)==0)? 1 : 1000;

/*--------------------------------------------------------------------------------------------------*/
/*		共通項計算 : 補間モード最大加減速度＆非常停止減速度											*/
/*--------------------------------------------------------------------------------------------------*/
/*						10000 * IPcycle * IPcycle													*/
/*		{kx,sx} = -------------------------------------												*/
/*					1000000 * 1000000 * kunit * kunit												*/
/*--------------------------------------------------------------------------------------------------*/
		sx = 0;   kx = MlibPcalKxmulx( kunit, kunit, 100000000, &sx );
		sx = -sx; kx = MlibPcalKxgain( IPcycle, IPcycle, kx, &sx, 0 );
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード最大速度 [ipulse/IPcycle]															*/
/*--------------------------------------------------------------------------------------------------*/
/*					 maxipv * iptimes																*/
/*		ipmaxspd = --------------------																*/
/*						 2^pshlx																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( pcmkprm->maxipv, iptimes, &xx[0] );
		xx[0] = ((xx[1]<<(31-pcmkprm->pshlx))<<1) + ((ULONG)xx[0]>>pcmkprm->pshlx);
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード最大加減速度 [ipulse/IPcycle^2]													*/
/*--------------------------------------------------------------------------------------------------*/
/*						 10000 * IPcycle * IPcycle													*/
/*		ipmaxacc = ------------------------------------ * ipaccrt									*/
/*					1000000 * 1000000 * kunit * kunit												*/
/*--------------------------------------------------------------------------------------------------*/
		if( ipaccrt <= 0 )
		{
			ipmaxacc = xx[0];
		}
		else
		{
			sy = sx;
			ipmaxacc = MlibPcalKxgain( kx, ipaccrt, 1, &sy, -24 );
			if( ipmaxacc <= 0 ){ ipmaxacc = 1;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		補間モード非常停止減速度 [ipulse/IPcycle^2]													*/
/*--------------------------------------------------------------------------------------------------*/
/*						 10000 * IPcycle * IPcycle													*/
/*		ipstpdec = ------------------------------------- * ipdecrt									*/
/*					 1000000 * 1000000 * kunit * kunit												*/
/*--------------------------------------------------------------------------------------------------*/
		if( ipdecrt <= 0 )
		{
			ipstpdec = xx[0];
		}
		else
		{
			sy = sx;
			ipstpdec = MlibPcalKxgain( kx, ipdecrt, 1, &sy, -24 );
			if( ipstpdec <= 0 ){ ipstpdec = 1;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		パラメータ設定																				*/
/*--------------------------------------------------------------------------------------------------*/
		KPI_DI( );
		pcmkprm->iptimes  = (USHORT)iptimes;
		pcmkprm->ipmaxspd = xx[0];
		pcmkprm->ipmaxacc = ipmaxacc;
		pcmkprm->ipstpdec = ipstpdec;
		KPI_EI( );
/*--------------------------------------------------------------------------------------------------*/
		return( TRUE );

}
#endif



/****************************************************************************************************/
/*																									*/
/*		位置指令作成器リセット処理																	*/
/*																									*/
/****************************************************************************************************/
void	MlibRstPcmdMaker(
		LONG	pcmdset0,				/* 位置指令初期値(下位32bit)		[pulse]					*/
		LONG	pcmdset1,				/* 位置指令初期値(上位32bit)		[pulse]					*/
		PCMKPV	*pcmdmkr	)			/* 位置指令作成器演算用変数(P&V)	[-]						*/
{

		KPI_DI( );
/*--------------------------------------------------------------------------------------------------*/
		pcmdmkr->V.vpx        = 0;
		pcmdmkr->V.vpxrem     = 0;
		pcmdmkr->V.ipvpi      = 0;
		pcmdmkr->V.ipvpx      = 0;
		pcmdmkr->V.ipremi     = 0;
		pcmdmkr->V.ipremx     = 0;
/*--------------------------------------------------------------------------------------------------*/
		pcmdmkr->V.calendf    = 0;
		pcmdmkr->V.cmderrf    = 0;
		pcmdmkr->V.pcmkmode   = 0;
		pcmdmkr->V.modechgf   = 0;
/*--------------------------------------------------------------------------------------------------*/
		pcmdmkr->V.pcmdout[0] = pcmdset0;
		pcmdmkr->V.pcmdout[1] = pcmdset1;
/*--------------------------------------------------------------------------------------------------*/
		KPI_EI( );
		return;

}



#if 0 /* 現状未使用 */
/****************************************************************************************************/
/*																									*/
/*		位置指令作成器：補間位置指令リミット演算													*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		64bit Compare Macro : GT(a>b),LT(a<b),GTE(a>=b),LTE(a<=b)									*/
/*--------------------------------------------------------------------------------------------------*/
#define	LPX_EQ64( a, b )	( (a[1] == b[1]) && (a[0] == b[0]) )
#define	LPX_GT64( a, b )	( (a[1] >  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] >  (ULONG)b[0])) )
#define	LPX_LT64( a, b )	( (a[1] <  b[1]) || ((a[1] == b[1])&&((ULONG)a[0] <  (ULONG)b[0])) )
/*--------------------------------------------------------------------------------------------------*/
LONG	MlibIpTposLimit(				/* 補間位置指令リミット演算									*/
		LONG	*tpos,					/* 目標位置(64bit)					[pulse]					*/
		LONG	*lmtpos,				/* リミット位置(64bit)				[pulse]					*/
		LONG	lmtdir,					/* リミット方向(正側／負側)			[-]						*/
		PCMKPV	*pcmdmkr	)			/* 位置指令作成器演算用変数(P&V)	[-]						*/
{
LONG	carry;							/* 64bit演算Carry計算用										*/
LONG	x1,x2;							/* 位置偏差演算用											*/
LONG	px64[2];						/* 位置偏差演算用											*/
PCMKP	*pcmkprm = &pcmdmkr->P;			/* 位置指令作成器パラメータ									*/
PCMKV	*pcmkvar = &pcmdmkr->V;			/* 位置指令作成器演算用変数									*/

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令作成モード変更チェック																*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmkvar->pcmkmode != PCMKMODE_IPA )
		{
			MUL3232( pcmkvar->vpx, (pcmkprm->iptimes<<1), &px64[0] );
			x1 = ((px64[1]<<(31-pcmkprm->pshlx))<<1) + ((ULONG)px64[0]>>pcmkprm->pshlx);
			pcmkvar->ipvpi = (x1 + 1) >> 1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		減速停止(ゼロ速)までの位置指令パルス量の演算												*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkvar->avp = (pcmkvar->ipvpi >= 0) ? pcmkvar->ipvpi : -pcmkvar->ipvpi;
		pcmkvar->n   = pcmkvar->avp / pcmkprm->ipstpdec;
		pcmkvar->rem = pcmkvar->avp - pcmkvar->n * pcmkprm->ipstpdec;
		if( ((pcmkvar->n+1)&0x01) == 0x00 )
		{
			MUL3232( ((pcmkvar->n + 1)>>1), (pcmkvar->avp + pcmkvar->rem), &px64[0] );
		}
		else
		{
			MUL3232( (pcmkvar->n + 1), ((pcmkvar->avp + pcmkvar->rem)>>1), &px64[0] );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		減速停止位置の演算																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmkvar->ipvpi >= 0 )
		{
			pcmkvar->ipstopx[0] = pcmkvar->pcmdout[0] + px64[0];
			carry = ((ULONG)pcmkvar->ipstopx[0] < (ULONG)px64[0]);
			pcmkvar->ipstopx[1] = pcmkvar->pcmdout[1] + px64[1] + carry;
		}
		else
		{
			pcmkvar->ipstopx[0] = pcmkvar->pcmdout[0] - px64[0];
			carry = ((ULONG)pcmkvar->pcmdout[0] < (ULONG)px64[0]);
			pcmkvar->ipstopx[1] = pcmkvar->pcmdout[1] - px64[1] - carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		減速停止時の位置偏差の演算 : lmtpos[] - ipstopx[]											*/
/*--------------------------------------------------------------------------------------------------*/
		px64[0] = lmtpos[0] - pcmkvar->ipstopx[0];
		carry = ((ULONG)lmtpos[0] < (ULONG)pcmkvar->ipstopx[0]);
		px64[1] = lmtpos[1] - pcmkvar->ipstopx[1] - carry;

/*--------------------------------------------------------------------------------------------------*/
/*		領域チェック：位置偏差,速度,etc																*/
/*--------------------------------------------------------------------------------------------------*/
		if( LPX_EQ64( tpos, pcmkvar->pcmdout ) )
		{
			return( FALSE );
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( lmtdir == IPTPOSLMT_PSIDE )
		{
			if( pcmkvar->ipvpi < 0 )
			{
				if( LPX_GT64( tpos, lmtpos ) )
				{
					tpos[0] = lmtpos[0];
					tpos[1] = lmtpos[1];
					return( TRUE );
				}
				return( FALSE );
			}
		/*------------------------------------------------------------------------------------------*/
			if( (px64[1] > 0) || ((px64[1]==0)&&(px64[0]<0)) )
			{
				return( FALSE );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			if( pcmkvar->ipvpi > 0 )
			{
				if( LPX_LT64( tpos, lmtpos ) )
				{
					tpos[0] = lmtpos[0];
					tpos[1] = lmtpos[1];
					return( TRUE );
				}
				return( FALSE );
			}
		/*------------------------------------------------------------------------------------------*/
			px64[0] = ~px64[0] + 1;
			px64[1] = ~px64[1] + (px64[0]==0);
			if( (px64[1] > 0) || ((px64[1]==0)&&(px64[0]<0)) )
			{
				return( FALSE );
			}
		}

/*--------------------------------------------------------------------------------------------------*/
/*		加速可能時																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( px64[0] > pcmkvar->n )
		{
			if( px64[0] <= (pcmkvar->avp + pcmkprm->ipstpdec) )
			{
				x1 = pcmkprm->ipstpdec - pcmkvar->rem;
				x2 = x1 * (pcmkvar->n + 1);
				if( px64[0] <= x2 )
				{
					pcmkvar->avp += (px64[0]/(pcmkvar->n + 1));
				}
				else
				{
					pcmkvar->avp += x1 + ((px64[0] - x2)/(pcmkvar->n + 2));
				}
			}
		/*------------------------------------------------------------------------------------------*/
			else
			{
				x1 = pcmkvar->avp;
			/*--------------------------------------------------------------------------------------*/
				x2 = (4*x1) + (10*pcmkprm->ipstpdec);
				if( px64[0] >= x2 )
				{
					px64[0] -= x2; x1 += 4*pcmkprm->ipstpdec;
				}
			/*--------------------------------------------------------------------------------------*/
				x2 = x1 + pcmkprm->ipstpdec;
				if( px64[0] >= x2 )
				{
					px64[0] -= x2; x1 = x2;
				}
			/*--------------------------------------------------------------------------------------*/
				x2 = x1 + pcmkprm->ipstpdec;
				if( px64[0] >= x2 )
				{
					px64[0] -= x2; x1 = x2;
				}
			/*--------------------------------------------------------------------------------------*/
				x2 = x1 + pcmkprm->ipstpdec;
				if( px64[0] >= x2 )
				{
					px64[0] -= x2; x1 = x2;
				}
			/*--------------------------------------------------------------------------------------*/
				x2 = x1 + pcmkprm->ipstpdec;
				if( px64[0] >  x2 )
				{
					pcmkvar->avp = x1;
					return( FALSE );
				}
				else
				{
					pcmkvar->avp = x1;
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		減速必要時																					*/
/*--------------------------------------------------------------------------------------------------*/
		else if( px64[0] < 0 )
		{
			if( px64[0] <= -pcmkvar->avp )
			{
				pcmkvar->avp -= pcmkprm->ipstpdec;
				if( pcmkvar->avp < 0 ){ pcmkvar->avp = 0;}
			}
			else if( px64[0] <= -((pcmkvar->n + 1)*pcmkvar->rem) )
			{
				pcmkvar->avp -= pcmkprm->ipstpdec - ((px64[0] + pcmkvar->avp)/pcmkvar->n);
			}
			else
			{
				pcmkvar->avp -= ((pcmkvar->n - px64[0])/(pcmkvar->n+1));
			}
		}

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令リミット値の演算																	*/
/*--------------------------------------------------------------------------------------------------*/
		x1 = (lmtdir == IPTPOSLMT_PSIDE)? pcmkvar->avp : -pcmkvar->avp;
		px64[0] = pcmkvar->pcmdout[0] + x1;
		carry = ((ULONG)px64[0] < (ULONG)x1);
		px64[1] = pcmkvar->pcmdout[1] + (x1>>31) + carry;

/*--------------------------------------------------------------------------------------------------*/
/*		正側リミット処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( lmtdir == IPTPOSLMT_PSIDE )
		{
			if( LPX_GT64( px64, lmtpos ) )
			{
				px64[0] = lmtpos[0];
				px64[1] = lmtpos[1];
			}
			if( LPX_GT64( tpos, px64 ) )
			{
				tpos[0] = px64[0];
				tpos[1] = px64[1];
				return( TRUE );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		負側リミット処理																			*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			if( LPX_LT64( px64, lmtpos ) )
			{
				px64[0] = lmtpos[0];
				px64[1] = lmtpos[1];
			}
			if( LPX_LT64( tpos, px64 ) )
			{
				tpos[0] = px64[0];
				tpos[1] = px64[1];
				return( TRUE );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		return( FALSE );
}
#endif



/****************************************************************************************************/
/*																									*/
/*		位置指令作成器演算実行関数																	*/
/*																									*/
/****************************************************************************************************/
/*--------------------------------------------------------------------------------------------------*/
/*		絶対値マクロ																				*/
/*--------------------------------------------------------------------------------------------------*/
#define LPX_ABS( u )	(((u)>=0) ? (u) : -(u))
/*--------------------------------------------------------------------------------------------------*/
/*		乗算(32bit*32bit,切捨て演算)(ＡＳＭ演算代替え)												*/
/*--------------------------------------------------------------------------------------------------*/
LONG	XasmMulhigh32down( LONG a, LONG b )
{
LONG	xx[2];
		MUL3232( a, b, xx );
		return( xx[1] );
}
/*--------------------------------------------------------------------------------------------------*/


LONG	MlibPcmdMaker(
		LONG	pcmdin0,				/* 位置指令入力(下位32bit)			[pulse]					*/
		LONG	pcmdin1,				/* 位置指令入力(上位32bit)			[pulse]					*/
		LONG	pcmdspd,				/* 位置指令速度(最大／送り)			[2^24/OvrSpd]			*/
		PCMKPV	*pcmdmkr,				/* 位置指令作成器演算用変数(P&V)	[-]						*/
		ULONG	pcmkmode	)			/* 位置指令作成モード				[-]						*/
{
LONG	carry;							/* 64bit演算Carry計算用										*/
LONG	px64[2];						/* 減速停止までのパルス量									*/
LONG	per64[2];						/* パルス偏差(64bit符号付)									*/
LONG	pex64[2];						/* 減速停止時パルス偏差(per64[]-px64[])						*/
LONG	pex,x1,x2;						/* 減速停止時パルス量演算用									*/
PCMKP	*pcmkprm = &pcmdmkr->P;			/* 位置指令作成器パラメータ									*/
PCMKV	*pcmkvar = &pcmdmkr->V;			/* 位置指令作成器演算用変数									*/


/*--------------------------------------------------------------------------------------------------*/
/*		位置指令作成モード変化チェック																*/
/*--------------------------------------------------------------------------------------------------*/
	pcmkvar->modechgf = ((pcmkmode & 0xFF) != pcmkvar->pcmkmode)? TRUE : FALSE;
	pcmkvar->pcmkmode = (UCHAR)pcmkmode;


	switch( pcmkmode )
	{
/****************************************************************************************************/
/*																									*/
/*		位置決めモード																				*/
/*																									*/
/****************************************************************************************************/
	case PCMKMODE_POS:
/*--------------------------------------------------------------------------------------------------*/
/*		開始処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmkvar->modechgf )
		{
			pcmkvar->vpxrem = 0;
			pcmkvar->cmderrf = FALSE;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		位置指令速度(最大)[xpulse/scan] : maxvp = osvpm * pcmdspd / 2^24							*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkvar->maxvp = XasmMulhigh32down( (pcmkprm->osvpm << 4), (LPX_ABS(pcmdspd) << 4) );

/*--------------------------------------------------------------------------------------------------*/
/*		64bit位置指令：位置指令偏差の計算															*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmkprm->pcmd64f )
		{
			per64[0] = pcmdin0 - pcmkvar->pcmdout[0];
			carry = ((ULONG)pcmdin0 < (ULONG)pcmkvar->pcmdout[0]);
			per64[1] = pcmdin1 - pcmkvar->pcmdout[1] - carry;
		/*------------------------------------------------------------------------------------------*/
			if( (per64[1]>>(30-pcmkprm->pshlx)) > 0 )
			{
				per64[1] =  0x3FFFFFFF;
			}
			else if( (per64[1]>>(30-pcmkprm->pshlx)) < -1 )
			{
				per64[1] = -0x3FFFFFFF;
			}
			else
			{
				x1       = (((ULONG)per64[0]>>(31-pcmkprm->pshlx))>>1);
				carry    = ((ULONG)(per64[0]<<pcmkprm->pshlx) < (ULONG)pcmkvar->vpxrem);
				per64[0] = (per64[0]<<pcmkprm->pshlx) - pcmkvar->vpxrem;
				per64[1] = (per64[1]<<pcmkprm->pshlx) + x1 - (pcmkvar->vpxrem>>31) - carry;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		32bit位置指令：位置指令偏差の計算															*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			x1       = pcmdin0 - pcmkvar->pcmdout[0];
			carry    = ((ULONG)(x1<<pcmkprm->pshlx) < (ULONG)pcmkvar->vpxrem);
			per64[0] = (x1<<pcmkprm->pshlx) - pcmkvar->vpxrem;
			per64[1] = ((x1>>(31-pcmkprm->pshlx))>>1) - (pcmkvar->vpxrem>>31) - carry;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		収束条件のチェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( ( per64[1] >  0 ) || 
			( per64[1] < -1 ) ||
			( (per64[1]^per64[0]) < 0 ) )
		{
			;
		}
		else if( (-pcmkprm->vpdec <= per64[0]) && (per64[0] <= pcmkprm->vpdec) )
		{
			x1 = per64[0] - pcmkvar->vpx;
			if( (x1 >= -pcmkprm->vpdec) && (x1 <= pcmkprm->vpdec) )
			{
				pcmkvar->vpx = per64[0];
				pcmkvar->calendf = (per64[0]==0)? TRUE : FALSE;
				break;
			}
		}
		
/*--------------------------------------------------------------------------------------------------*/
/*		速度チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkvar->calendf = FALSE;
		pcmkvar->avp = ( pcmkvar->vpx > 0 ) ? pcmkvar->vpx : -pcmkvar->vpx;
		if( pcmkvar->avp >= (pcmkvar->maxvp + pcmkprm->vpdec) )
		{
			if( pcmkvar->vpx > 0 )
			{
				pcmkvar->vpx = pcmkvar->vpx - pcmkprm->vpdec;
			}
			else
			{
				pcmkvar->vpx = pcmkvar->vpx + pcmkprm->vpdec;
			}
			break;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		減速停止(ゼロ速)までの位置指令パルス量の演算												*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkvar->n   = pcmkvar->avp / pcmkprm->vpdec;
		pcmkvar->rem = pcmkvar->avp - pcmkvar->n * pcmkprm->vpdec;
		if( ((pcmkvar->n+1)&0x01) == 0x00 )
		{
			MUL3232( ((pcmkvar->n + 1)>>1), (pcmkvar->avp + pcmkvar->rem), &px64[0] );
		}
		else
		{
			MUL3232( (pcmkvar->n + 1), ((pcmkvar->avp + pcmkvar->rem)>>1), &px64[0] );
		}

/*--------------------------------------------------------------------------------------------------*/
/*		領域チェック＆減速停止時の位置指令偏差の演算												*/
/*--------------------------------------------------------------------------------------------------*/
		if( (pcmkvar->vpx >= 0) && (per64[1] >= 0) && ((per64[1]|per64[0]) != 0) )
		{
			pex64[0] = per64[0] - px64[0];
			pex64[1] = per64[1] - px64[1] - ((ULONG)per64[0] < (ULONG)px64[0]);
			x1 = pex64[0]^pex64[1];
			if( ( x1 >= 0 )&&(( pex64[1]==0 )||( pex64[1]==-1 )) )
			{
				pex = pex64[0];
			}
			else if( pex64[1] >= 0 )
			{
				pcmkvar->vpx = pcmkvar->vpx + pcmkprm->vpacc;
				if( pcmkvar->vpx > pcmkvar->maxvp ){ pcmkvar->vpx = pcmkvar->maxvp;}
				break;
			}
			else
			{
				pcmkvar->vpx = pcmkvar->vpx - pcmkprm->vpdec;
				if( pcmkvar->vpx < -pcmkvar->maxvp ){ pcmkvar->vpx = -pcmkvar->maxvp;}
				break;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( (pcmkvar->vpx <= 0) && (per64[1] < 0) )
		{
			pex64[0] = per64[0] + px64[0];
			pex64[1] = per64[1] + px64[1] + ((ULONG)pex64[0] < (ULONG)per64[0]);
			x1 = pex64[0]^pex64[1];
			if( ( x1 >= 0 )&&(( pex64[1]==0 )||( pex64[1]==-1 )) )
			{
				pex = (pex64[0]==0x80000000) ? 0x7FFFFFFF : -pex64[0];
			}
			else if( pex64[1] >= 0 )
			{
				pcmkvar->vpx = pcmkvar->vpx + pcmkprm->vpdec;
				if( pcmkvar->vpx > pcmkvar->maxvp ){ pcmkvar->vpx = pcmkvar->maxvp;}
				break;
			}
			else
			{
				pcmkvar->vpx = pcmkvar->vpx - pcmkprm->vpacc;
				if( pcmkvar->vpx < -pcmkvar->maxvp ){ pcmkvar->vpx = -pcmkvar->maxvp;}
				break;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		else if( (pcmkvar->vpx < 0) && (per64[1] >= 0) )
		{
			pcmkvar->vpx = pcmkvar->vpx + pcmkprm->vpdec;
			if( pcmkvar->vpx > pcmkvar->maxvp ){ pcmkvar->vpx = pcmkvar->maxvp;}
			break;
		}
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			pcmkvar->vpx = pcmkvar->vpx - pcmkprm->vpdec;
			if( pcmkvar->vpx < -pcmkvar->maxvp ){ pcmkvar->vpx = -pcmkvar->maxvp;}
			break;
		}

/*--------------------------------------------------------------------------------------------------*/
/*		加速時の演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( pex > pcmkvar->n )
		{
			x1 = pcmkprm->vparx + pcmkvar->rem - pcmkprm->vpdec;
			x2 = pcmkprm->vpapx + pcmkprm->vpamx*pcmkvar->avp + pcmkvar->n*pcmkprm->vparx + ((x1>0)?x1:0);
		/*------------------------------------------------------------------------------------------*/
		/*	pex >= (vpapx+vpamx*avp+n*vparx+xxx)													*/
		/*------------------------------------------------------------------------------------------*/
			if( pex >= x2 )
			{
				pcmkvar->avp = pcmkvar->avp + pcmkprm->vpacc;
			}
		/*------------------------------------------------------------------------------------------*/
		/*	pex >= (avp+vpdec)																		*/
		/*------------------------------------------------------------------------------------------*/
			else if( pex >= (pcmkvar->avp + pcmkprm->vpdec) )
			{
				if( pex >= (8*pcmkvar->avp + 36*pcmkprm->vpdec) )
				{
					pex = pex - (8*pcmkvar->avp + 36*pcmkprm->vpdec);
					pcmkvar->avp = pcmkvar->avp + 8*pcmkprm->vpdec;
				}
				if( pex >= (4*pcmkvar->avp + 10*pcmkprm->vpdec) )
				{
					pex = pex - (4*pcmkvar->avp + 10*pcmkprm->vpdec);
					pcmkvar->avp = pcmkvar->avp + 4*pcmkprm->vpdec;
				}
				if( pex >= (2*pcmkvar->avp + 3*pcmkprm->vpdec) )
				{
					pex = pex - (2*pcmkvar->avp + 3*pcmkprm->vpdec);
					pcmkvar->avp = pcmkvar->avp + 2*pcmkprm->vpdec;
				}
				if( pex >= (pcmkvar->avp + pcmkprm->vpdec) )
				{
					pcmkvar->avp = pcmkvar->avp + pcmkprm->vpdec;
				}
			}
		/*------------------------------------------------------------------------------------------*/
		/*	pex > (n+1)*(vpdec-rem)																	*/
		/*------------------------------------------------------------------------------------------*/
			else if( pex > ((pcmkvar->n + 1)*(pcmkprm->vpdec - pcmkvar->rem)) )
			{
				pcmkvar->avp = pcmkvar->avp + pcmkprm->vpdec;
				pcmkvar->avp = pcmkvar->avp - (pcmkvar->avp - pex + pcmkvar->n + 1)/(pcmkvar->n + 2);
			}
		/*------------------------------------------------------------------------------------------*/
		/*	n < pex <= (n+1)*(vpdec-rem)															*/
		/*------------------------------------------------------------------------------------------*/
			else
			{
				pcmkvar->avp = pcmkvar->avp + pex/(pcmkvar->n + 1);
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		減速時の演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		else if( pex < 0 )
		{
		/*------------------------------------------------------------------------------------------*/
		/*	pex <= -avp																				*/
		/*------------------------------------------------------------------------------------------*/
			if( pex <= -pcmkvar->avp )
			{
				pcmkvar->avp = pcmkvar->avp - pcmkprm->vpdec;
			}
		/*------------------------------------------------------------------------------------------*/
		/*	-avp < pex <= -(n+1)*rem																*/
		/*------------------------------------------------------------------------------------------*/
			else if( pex <= -(pcmkvar->n + 1)*pcmkvar->rem )
			{
				pcmkvar->avp = pcmkvar->avp - pcmkprm->vpdec + (pex + pcmkvar->avp)/pcmkvar->n;
			}
		/*------------------------------------------------------------------------------------------*/
		/*	-(n+1)*rem < pex < 0																	*/
		/*------------------------------------------------------------------------------------------*/
			else
			{
				pcmkvar->avp = pcmkvar->avp - (pcmkvar->n - pex)/(pcmkvar->n + 1);
			}
		}

/*--------------------------------------------------------------------------------------------------*/
/*		リミット＆符号の演算																		*/
/*--------------------------------------------------------------------------------------------------*/
		x1 = ( pcmkvar->avp > pcmkvar->maxvp )? pcmkvar->maxvp : pcmkvar->avp;
		pcmkvar->vpx = ( per64[1] >= 0 )? x1 : -x1;

		break;

/****************************************************************************************************/
/*		減速停止モード																				*/
/****************************************************************************************************/
	default: 
/*--------------------------------------------------------------------------------------------------*/
/*		開始処理																					*/
/*--------------------------------------------------------------------------------------------------*/
		pcmkvar->cmderrf = FALSE;
/*--------------------------------------------------------------------------------------------------*/
/*		位置指令速度の演算																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( pcmkvar->vpx >= 0 )
		{
			pcmkvar->vpx = pcmkvar->vpx - pcmkprm->vpdec;
			if( pcmkvar->vpx <= 0 )
			{
				pcmkvar->vpx = 0;
				pcmkvar->calendf = TRUE;
			}
			else
			{
				pcmkvar->calendf = FALSE;
			}
		}
		else
		{
			pcmkvar->vpx = pcmkvar->vpx + pcmkprm->vpdec;
			if( pcmkvar->vpx >= 0 )
			{
				pcmkvar->vpx = 0;
				pcmkvar->calendf = TRUE;
			}
			else
			{
				pcmkvar->calendf = FALSE;
			}
		}
		break;
	}
/*--------------------------------------------------------------------------------------------------*/
/*		計算終了処理 : 位置指令出力(絶対値)の更新													*/
/*--------------------------------------------------------------------------------------------------*/
	x1 = pcmkvar->vpx + pcmkvar->vpxrem;
	x2 = (x1>=0)? (x1>>pcmkprm->pshlx) : -((-x1)>>pcmkprm->pshlx);
	pcmkvar->vpxrem = x1 - (x2<<pcmkprm->pshlx);
	pcmkvar->pcmdout[0] = pcmkvar->pcmdout[0] + x2;
	carry = ((ULONG)pcmkvar->pcmdout[0] < (ULONG)x2);
	pcmkvar->pcmdout[1] = pcmkvar->pcmdout[1] + (x2>>31) + carry;
/*--------------------------------------------------------------------------------------------------*/
	return( x2 );
}


#if 0 /* mlib.shにて定義 */

/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 基本数値演算関数 >>>>>																*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		絶対値(32bit)																				*/
/*																									*/
/****************************************************************************************************/
LONG	MlibAbs32( LONG u )
{
LONG	x;

		x = (u >= 0)? u : -u;

		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		加算(64bit+32bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibAdd6432( LONG *a, LONG b, LONG *x )
{

		ADD6432( a, b, x );

		return;

}
#endif



#if 0 /* mlib.shにて定義 */
/****************************************************************************************************/
/*																									*/
/*		加算(64bit+64bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibAdd6464( LONG *a, LONG *b, LONG *x )
{

		ADD6464( a, b, x );

		return;

}
#endif



#if 0 /* mlib.shにて定義 */
/****************************************************************************************************/
/*																									*/
/*		減算(64bit-32bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibSub6432( LONG *a, LONG b, LONG *x )
{

		SUB6432( a, b, x );

		return;

}
#endif



#if 0 /* mlib.shにて定義 */
/****************************************************************************************************/
/*																									*/
/*		減算(64bit-64bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibSub6464( LONG *a, LONG *b, LONG *x )
{

		SUB6464( a, b, x );

		return;

}
#endif


#if 0
/****************************************************************************************************/
/*																									*/
/*		偏差(64bit-64bit)																			*/
/*																									*/
/****************************************************************************************************/
LONG	MlibErr6464( LONG *a, LONG *b )
{
LONG	errchk;
LONG	err64[2];

		MlibSub6464( a, b, err64 );
		if( err64[1] >  0 ){ return(  0x3FFFFFFF );}
		if( err64[1] < -1 ){ return( -0x40000000 );}

		errchk = (err64[1]<<2) + (((ULONG)err64[0])>>30);
		if( errchk   >  0 ){ return(  0x3FFFFFFF );}
		if( errchk   < -1 ){ return( -0x40000000 );}
		return( err64[0] );

}
#endif


/****************************************************************************************************/
/*																									*/
/*		飽和加算(符号付,32bit+32bit,Limit:0x01000000,0xFF000000)									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSatAdd24( LONG a, LONG b )
{
LONG	x;

		x = a + b;

		if( (a>0)&&(b>0)&&(x<=0) ){ return( 0x01000000 );}
		if( (a<0)&&(b<0)&&(x>=0) ){ return( 0xFF000000 );}

		if( x > (LONG)0x01000000 ){ return( 0x01000000 );}
		if( x < (LONG)0xFF000000 ){ return( 0xFF000000 );}

		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		飽和加算(符号付,32bit+32bit,Limit:0x10000000,0xF0000000)									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSatAdd28( LONG a, LONG b )
{
LONG	x;

		x = a + b;

		if( (a>0)&&(b>0)&&(x<=0) ){ return( 0x10000000 );}
		if( (a<0)&&(b<0)&&(x>=0) ){ return( 0xF0000000 );}

		if( x > (LONG)0x10000000 ){ return( 0x10000000 );}
		if( x < (LONG)0xF0000000 ){ return( 0xF0000000 );}

		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		飽和加算(符号付,32bit+32bit,Limit:0x7FFFFFFF,0x80000000)									*/
/*																									*/
/****************************************************************************************************/
KSGAIN	MlibSatAdd32( KSGAIN a, KSGAIN b )		/*<S00A>*/
{
KSGAIN	x;		/*<S00A>*/

		x = a + b;

		if( (a>0)&&(b>0)&&(x<=0) ){ return( 0x7FFFFFFF );}
		if( (a<0)&&(b<0)&&(x>=0) ){ return( 0x80000000 );}

		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		飽和加算(符号無,32bit+32bit,Limit:0xFFFFFFFF)												*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibSatAddu32( ULONG a, ULONG b )
{
ULONG	x;

		x = a + b;

		if( x < a ){ return( 0xFFFFFFFF );}

		return( x );

}



#if 0 /* mlib.shにて定義 */
/****************************************************************************************************/
/*																									*/
/*		乗算(32bit*32bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibMul3232( LONG a, LONG b, LONG *x )
{

		MUL3232( a, b, x );
		return;

}
#endif



#if 0 /* mlib.shにて定義 */
/****************************************************************************************************/
/*																									*/
/*		乗算(32bit*32bit)																			*/
/*																									*/
/****************************************************************************************************/
void	MlibMulu32u32( ULONG a, ULONG b, ULONG *x )
{

		MULU32U32( a, b, x );
		return;

}



/****************************************************************************************************/
/*																									*/
/*		乗算(32bit*32bit)																			*/
/*																									*/
/****************************************************************************************************/
LONG	MlibMulhigh32( LONG a, LONG b )
{
LONG	xx[2];

		MUL3232( a, b, xx );
		xx[1] = xx[1] + ((ULONG)xx[0]>>31);

		return( xx[1] );

}



/****************************************************************************************************/
/*																									*/
/*		乗算(32bit*32bit)																			*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibMulhighu32( ULONG a, ULONG b )
{
ULONG	xx[2];

		MULU32U32( a, b, xx );
		xx[1] = xx[1] + ((ULONG)xx[0]>>31);

		return( xx[1] );

}
#endif



/****************************************************************************************************/
/*																									*/
/*		除算(32bit/16bit)			rv = u32/k16, *rem = u32%k16									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibDivhrem( LONG u, SHORT k, SHORT *rem )
{
LONG	x;

		x = u / k;

		*rem = (SHORT)(u - (x*k));

		return( x );

}



/****************************************************************************************************/
/*																									*/
/*		除算(32bit*32bit/32bit)		rv = a*b/c, Limit : 0x7FFFFFFF									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibDiv6432( LONG a, LONG b, LONG c )
{
LONG	i;
LONG	x;
LONG	xx[2];
LONG	signx;

		signx = 1;
		if( a <  0 ){ a = -a; signx = -1*signx;}
		if( b <  0 ){ b = -b; signx = -1*signx;}
		if( c <  0 ){ c = -c; signx = -1*signx;}
		if( c == 0 ){ return( 0 );}
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( (ULONG)a, (ULONG)b, (ULONG*)xx );
		if( (ULONG)xx[1] >= (ULONG)c ){ return( signx * 0x7FFFFFFF );}
		xx[1] = (xx[1]<<1) + (xx[0]<0); xx[0] = (xx[0]<<1);
		if( (ULONG)xx[1] >= (ULONG)c ){ return( signx * 0x7FFFFFFF );}
		xx[1] = (xx[1]<<1) + (xx[0]<0); xx[0] = (xx[0]<<1);
/*--------------------------------------------------------------------------------------------------*/
		for( x=0,i=0; i<31; i++ )
		{
			x = (x<<1);
			if( (ULONG)xx[1] >= (ULONG)c )
			{
				x     = x + 1;
				xx[1] = (ULONG)xx[1] - (ULONG)c;
			}
			xx[1] = (xx[1]<<1) + (xx[0]<0);
			xx[0] = (xx[0]<<1);
		}
		if( (ULONG)xx[1] >= (ULONG)c )
		{
			x = x + 1;
			if( x < 0 )
			{
				x = 0x7FFFFFFF;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
		return( signx * x );

}



/****************************************************************************************************/
/*																									*/
/*		拡張除算(32bit/32bit)		rv = ((a/b)<<sx)												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibDivx3232( LONG a, LONG b, LONG qmax, LONG sx )
{
LONG	rv;
LONG	remx;
LONG	signx;

		signx = a ^ b;
		a = ( a < 0 )? -a : a;
		b = ( b < 0 )? -b : b;
		if( b == 0 ){ return( 0 );}

		rv = a/b;
		remx = a%b;

		if( rv < qmax )
		{
			rv = (rv<<sx) | XasmDIVUA( remx, b, sx );
		}
		else
		{
			rv = (qmax<<sx);
		}

		if( signx >= 0 )
		{
			return( rv );
		}
		else
		{
			return( -rv );
		}
}



/****************************************************************************************************/
/*																									*/
/*		ルート演算(入力:32bit, 出力:16bit(Max.0x10000), 四捨五入)									*/
/*																									*/
/****************************************************************************************************/
USHORT	MlibSqrtu32( ULONG a )
{
ULONG	i;
ULONG	x,y;

/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( x=y=i=0; i<16; i++ )
		{
			x = ((x<<2)|(a>>30));
			a = (a<<2);
			y = (y<<1);
			if( x > y )
			{
				x = x - y - 1;
				y = y + 2;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		四捨五入処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( (x<<1) > y )
		{
			y = y + 2;
		}
		y = y>>1;
		y = (y > 0xFFFF)? 0xFFFF : y;

		return( (USHORT)y );

}



/****************************************************************************************************/
/*																									*/
/*		ルート演算(入力:64bit, 出力:32bit(Max.0xFFFFFFFF), 四捨五入)								*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibSqrtu64( ULONG a0, ULONG a1 )
{
ULONG	i;
ULONG	x,y,z;
ULONG	xx,yy;

/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(上位32bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( x=y=i=0; i<16; i++ )
		{
			x  = ((x<<2)|(a1>>30));
			a1 = (a1<<2);
			y  = (y<<1);
			if( x > y )
			{
				x = x - y - 1;
				y = y + 2;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(下位28bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i<14; i++ )
		{
			x  = ((x<<2)|(a0>>30));
			a0 = (a0<<2);
			y  = (y<<1);
			if( x > y )
			{
				x = x - y - 1;
				y = y + 2;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(下位4bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		xx = (x>>30);
		x  = ((x<<2)|(a0>>30));
		a0 = (a0<<2);
		yy = (y>>31);
		y  = (y<<1);
		if( xx > yy )
		{
			xx = xx - yy - (x<=y);
			x  = x - y - 1;
			y  = y + 2;
		}
		else if( (xx==yy)&&(x>y) )
		{
			x  = x - y - 1;
			y  = y + 2;
		}
/*--------------------------------------------------------------------------------------------------*/
		xx = (xx<<2)|(x>>30);
		x  = ((x<<2)|(a0>>30));
		yy = (yy<<1)|(y>>31);
		y  = (y<<1);
		if( xx > yy )
		{
			xx = xx - yy - (x<=y);
			x  = x - y - 1;
			y  = y + 2;
		}
		else if( (xx==yy)&&(x>y) )
		{
			xx = xx - yy;
			x  = x - y - 1;
			y  = y + 2;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		四捨五入処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		z  = (yy<<31)+(y>>1);
		xx = (xx<<1)|(x>>31); x = (x<<1);
		if( (z!=0xFFFFFFFF)&&((xx>yy)||((xx==yy)&&(x>y))) )
		{
			z = z + 1;
		}

		return( z );

}



/****************************************************************************************************/
/*																									*/
/*		ルート演算(入力:32bit*32bit, 出力:32bit(Max.0xFFFFFFFF), 四捨五入)							*/
/*																									*/
/****************************************************************************************************/
ULONG	MlibSqrtu32u32( ULONG a, ULONG b )
{
ULONG	i;
ULONG	ab[2];
ULONG	x,y,z;
ULONG	xx,yy;

/*--------------------------------------------------------------------------------------------------*/
/*		乗算処理(32bit*32bit)																		*/
/*--------------------------------------------------------------------------------------------------*/
		MULU32U32( a, b, &ab[0] );

/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(上位32bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( x=y=i=0; i<16; i++ )
		{
			x = ((x<<2)|(ab[1]>>30));
			ab[1] = (ab[1]<<2);
			y = (y<<1);
			if( x > y )
			{
				x = x - y - 1;
				y = y + 2;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(下位28bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i<14; i++ )
		{
			x  = ((x<<2)|(ab[0]>>30));
			ab[0] = (ab[0]<<2);
			y  = (y<<1);
			if( x > y )
			{
				x = x - y - 1;
				y = y + 2;
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		ルート演算処理(下位4bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		xx = (x>>30);
		x  = ((x<<2)|(ab[0]>>30));
		ab[0] = (ab[0]<<2);
		y  = (y<<1);
		if( xx > 0 )
		{
			xx = xx - (x<=y);
			x  = x - y - 1;
			y  = y + 2;
		}
		else if( x > y )
		{
			x  = x - y - 1;
			y  = y + 2;
		}
/*--------------------------------------------------------------------------------------------------*/
		xx = (xx<<2)|(x>>30);
		x  = ((x<<2)|(ab[0]>>30));
		yy = (y>>31);
		y  = (y<<1);
		if( xx > yy )
		{
			xx = xx - yy - (x<=y);
			x  = x - y - 1;
			y  = y + 2;
		}
		else if( (xx==yy)&&(x>y) )
		{
			xx = xx - yy;
			x  = x - y - 1;
			y  = y + 2;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		四捨五入処理																				*/
/*--------------------------------------------------------------------------------------------------*/
		z  = (yy<<31)+(y>>1);
		xx = (xx<<1)|(x>>31); x = (x<<1);
		if( (z!=0xFFFFFFFF)&&((xx>yy)||((xx==yy)&&(x>y))) )
		{
			z = z + 1;
		}

		return( z );

}



/****************************************************************************************************/
/*																									*/
/*		Ｓｉｎ演算  (入力:[0.1deg]or[360/16384deg], 出力:[1.0/10000]or[1.0/16384])					*/
/*																									*/
/****************************************************************************************************/
#if 0
SHORT	MlibSins16( LONG a, LONG unit )
{
ULONG	x,y;
ULONG	x2,xx[2];
LONG	calx;
LONG	sign = 1;
LONG	ax90,ax180,ax270,ax360,kax;

/*--------------------------------------------------------------------------------------------------*/
/*		入力単位チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (unit & 0x01) == 0 )	/* Input : 360deg/3600		*/
		{
			ax90 =  900; ax180 = 1800; ax270 =  2700; ax360 =  3600; kax = 7496132;
		}
		else						/* Input : 360deg/16384		*/
		{
			ax90 = 4096; ax180 = 8192; ax270 = 12288; ax360 = 16384; kax = 1647099;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		入力スケーリング処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( a >= ax360 ){ a -= ax360;}
		else if( a < 0 ){ a += ax360; if( a < 0 ){ a += ax360;} }
/*--------------------------------------------------------------------------------------------------*/
		if( a >= ax270      ){ a = ax360 - a; sign = -1;}
		else if( a >= ax180 ){ a = a - ax180; sign = -1;}
		else if( a >= ax90  ){ a = ax180 - a; sign =  1;}
/*--------------------------------------------------------------------------------------------------*/
		if(  (2*a) <= ax90  ){ x = (ULONG)a * kax; calx = 0;}
		else          { x = (ULONG)(ax90-a) * kax; calx = 1;}

/*--------------------------------------------------------------------------------------------------*/
/*		Ｓｉｎ演算処理 : sin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9!								*/
/*--------------------------------------------------------------------------------------------------*/
		if( calx == 0 )
		{
			y = x;
			MULU32U32(x,x, xx);	x2= xx[1];
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,715827883,xx); y -= xx[1]; /* - x^3/3!	*/
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x, 35791394,xx); y += xx[1]; /* + x^5/5!	*/
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,   852176,xx); y -= xx[1]; /* - x^7/7!	*/
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,    11836,xx); y += xx[1]; /* + x^9/9!	*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Ｓｉｎ演算処理 : sin(x) = cos(pai/2-x) = 1 - z^2/2! + z^4/4! - z^6/6! + z^8/8!				*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			MULU32U32(x,x, xx);	x = x2 = xx[1]; y = (x2>2)? (~(x2>>1)+1) : 0xFFFFFFFF;
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,178956971,xx); y += xx[1]; /* + x^4/4!	*/
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,  5965232,xx); y -= xx[1]; /* - x^6/6!	*/
			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,   106522,xx); y += xx[1]; /* + x^8/8!	*/
//			MULU32U32(x,x2,xx); x = xx[1]; MULU32U32(x,     1184,xx); y -= xx[1]; /* - x^10/10! */
		}

/*--------------------------------------------------------------------------------------------------*/
/*		出力スケーリング処理																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( (unit & 0x10) == 0 )	/* Output : 1.0000/10000	*/
		{
			MULU32U32( y, 20000, xx );
			y = ((xx[1]+1)>>1);
		}
		else						/* Output : 1.0000/16384	*/
		{
			y = (((y>>17)+1)>>1);
		}

		return( (SHORT)((LONG)y * sign) );

}
#endif
LONG	MlibSins16( LONG a, LONG unit )
{
	double	rv;
	double	rad;

	if( (unit & 0x01) == 0 )	/* Input : 360deg/3600		*/
	{
		rad = DEG2RAD * (double)a;
	}
	else						/* Input : 360deg/16384		*/
	{
		rad = FOURTEENBIT2RAD * (double)a;
	}

	rv = sin( rad );

	if( (unit & 0x10) == 0 )	/* Output : 1.0000/10000	*/
	{
		rv = rv * 10000.0;
	}
	else						/* Output : 1.0000/16384	*/
	{
		rv = rv * 16384.0;
	}
	return ( (LONG)rv );
}

#if (FLOAT_USE==TRUE)
/****************************************************************************************************/
/*																									*/
/*		指数値の計算 : 10^exp		浮動少数演算														*/
/*																									*/
/****************************************************************************************************/
void	FlibExpCal( CHAR exp, float *output )
{

	LONG	i, x;
	LONG	aexp;

	if( exp < 0 )
	{
		aexp = -exp;
	}
	else
	{
		aexp = exp;
	}
/*--------------------------------------------------------------------------------------------------*/
	for( x=1,i=0; i < aexp; i++ )						/* 10^aexp 計算								*/
	{
		x = 10 * x;										/* x = 1 * 10 * 10 * ......					*/
	}
/*--------------------------------------------------------------------------------------------------*/
	if( exp >= 0 )										/* {kx,sx}形式への変換						*/
	{
		*output = (float)x;								/* ksx = 10^aexp							*/
	}
	else
	{
		*output = 1.0F / (float)x;						/* ksx = 1 / (10^aexp)						*/
	}
/*--------------------------------------------------------------------------------------------------*/
	return;
}
#endif /* FLOAT_USE */

/****************************************************************************************************/
/*																									*/
/*		指数値の計算 : 10^exp																		*/
/*																									*/
/****************************************************************************************************/
LONG	MlibExpCal( CHAR exp )
{
LONG	i,x;
LONG	ksx;
LONG	aexp;

		aexp = ( exp >= 0 ) ? exp : -exp;					/* 符号チェック							*/
/*--------------------------------------------------------------------------------------------------*/
		for( x=1,i=0; i < aexp; i++ )						/* 10^aexp 計算							*/
		{
			x = 10 * x;										/* x = 1 * 10 * 10 * ......				*/
		}
/*--------------------------------------------------------------------------------------------------*/
		if( exp >= 0 )										/* {kx,sx}形式への変換					*/
		{
			ksx = MlibScalKxgain( x, 1, 1, NULL, -1 );		/* ksx = 10^aexp						*/
		}
		else
		{
			ksx = MlibScalKxgain( 1, 1, x, NULL, -1 );		/* ksx = 1 / (10^aexp)					*/
		}
/*--------------------------------------------------------------------------------------------------*/
		return( ksx );

}


/****************************************************************************************************/
/*																									*/
/*		絶対値偏差チェック：rv = (|a32 - b32| <= chk32)												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibAbsErrchk32( LONG a32, LONG b32, LONG chk32 )
{
LONG	err;

/*--------------------------------------------------------------------------------------------------*/
/*		偏差演算＆絶対値演算																		*/
/*--------------------------------------------------------------------------------------------------*/
		err = a32 - b32;
		if( err < 0 )
		{
			err = -err;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		絶対値偏差チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (ULONG)err <= (ULONG)chk32 )
		{
			return( TRUE );
		}
		else
		{
			return( FALSE );
		}

}



/****************************************************************************************************/
/*																									*/
/*		絶対値偏差チェック：rv = (|a64 - b64| <= chk32)												*/
/*																									*/
/****************************************************************************************************/
LONG	MlibAbsErrchk64( LONG *a64, LONG *b64, LONG chk32 )
{
LONG	err[2];

/*--------------------------------------------------------------------------------------------------*/
/*		偏差演算＆絶対値演算																		*/
/*--------------------------------------------------------------------------------------------------*/
		err[0] = a64[0] - b64[0];
		err[1] = a64[1] - b64[1] - ((ULONG)a64[0] < (ULONG)b64[0]);
		if( err[1] < 0 )
		{
			err[1] = ~err[1] + (err[0] == 0);
			err[0] = ~err[0] + 1;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		絶対値偏差チェック																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( err[1] > 0 )
		{
			return( FALSE );
		}
		else if( (ULONG)err[0] <= (ULONG)chk32 )
		{
			return( TRUE );
		}
		else
		{
			return( FALSE );
		}

}



/****************************************************************************************************/
/*																									*/
/*		ＣＲＣ１６の設定(MEMOBUS用), 戻り値:無し													*/
/*																									*/
/****************************************************************************************************/
void	MlibSetCRC16MB( UCHAR *MsgBuf, LONG MsgLen )
{
LONG	i;
ULONG	a = 0xFFFF;
ULONG	b = 0xA001;

/*--------------------------------------------------------------------------------------------------*/
/*		Calculate CRC16																				*/
/*		※LengthにSUM値を含めたメッセージ長を指定するように変更(Jupiterに合わせた)					*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i<(MsgLen-2); i++ )
		{
			a = a ^ (ULONG)MsgBuf[i];
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 1	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 2	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 3	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 4	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 5	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 6	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 7	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 8	*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Set CRC16 Data (CRC16 Cal. Data : Low/High reversed)										*/
/*--------------------------------------------------------------------------------------------------*/
		MsgBuf[MsgLen-2] = (UCHAR)(a>>0);
		MsgBuf[MsgLen-1] = (UCHAR)(a>>8);
/*--------------------------------------------------------------------------------------------------*/
		return;
}



/****************************************************************************************************/
/*																									*/
/*		ＣＲＣ１６のチェック(MEMOBUS用), 戻り値:TRUE(正常)/FALSE(異常)								*/
/*																									*/
/****************************************************************************************************/
LONG	MlibChkCRC16MB( UCHAR *MsgBuf, LONG MsgLen )
{
LONG	i;
ULONG	a = 0xFFFF;
ULONG	b = 0xA001;

/*--------------------------------------------------------------------------------------------------*/
/*		Calculate CRC16																				*/
/*		CRCを含めたメッセージ長を指定するように変更(Jupiterに合わせた)								*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i<(MsgLen-2); i++ )
		{
			a = a ^ (ULONG)MsgBuf[i];
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 1	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 2	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 3	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 4	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 5	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 6	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 7	*/
			a = (a & 0x01)? ((a>>1)^b) : (a>>1);		/* 8	*/
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check CRC16 Data (CRC16 Cal. Data : Low/High reversed)										*/
/*--------------------------------------------------------------------------------------------------*/
		if( a == (ULONG)(MsgBuf[MsgLen-2]+(MsgBuf[MsgLen-1]<<8)) ){ return(OK);}else{ return(NG);}
}


/****************************************************************************************************/
/*																									*/
/*		ＳＵＭ１６の設定(SigmaMessage用), 戻り値:無し												*/
/*																									*/
/****************************************************************************************************/
void	MlibSetSum16SM( UCHAR *MsgBuf, LONG MsgLen )
{
LONG	i;
LONG	Sum;
LONG	WdLen = (MsgLen>>1) - 1;
USHORT*	WdBuf = (USHORT*)MsgBuf;
USHORT  word;
/*--------------------------------------------------------------------------------------------------*/
/*		Calculate Sum16																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( Sum=0,i=0; i<WdLen; i++ )
		{
			word = WdBuf[i];
			MlibCnvLittle16( word, word );
			Sum = Sum + word;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Set SUM16 Data																				*/
/*--------------------------------------------------------------------------------------------------*/
		Sum = (USHORT)(-Sum);
		MlibCnvLittle16( Sum, Sum );
		WdBuf[WdLen] = Sum;
/*--------------------------------------------------------------------------------------------------*/
		return;
}



/****************************************************************************************************/
/*																									*/
/*		ＳＵＭ１６のチェック(SigmaMessage用), 戻り値:TRUE(正常)/FALSE(異常)							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibChkSum16SM( UCHAR *MsgBuf, LONG MsgLen )
{
LONG	i;
LONG	Sum;
LONG	WdLen = (MsgLen >> 1);
USHORT*	WdBuf = (USHORT*)MsgBuf;
USHORT  word;

/*--------------------------------------------------------------------------------------------------*/
/*		Calculate Sum16																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( Sum=0,i=0; i<WdLen; i++ )
		{
			word = WdBuf[i];
			MlibCnvLittle16( word, word );
			Sum = Sum + word;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check SUM16 Data																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (USHORT)Sum == 0x0000 ){ return( OK );}else{ return( NG );}
}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< メモリ操作関数 >>>>>																	*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		バイトメモリのリセット																		*/
/*																									*/
/****************************************************************************************************/
void	MlibResetByteMemory( void *mempx, LONG xbyte )
{
		LONG	i;

		for( i=0; i<xbyte; i++ )
		{
			((UCHAR *)mempx)[i] = 0;
		}
		return;

}



/****************************************************************************************************/
/*																									*/
/*		ロングメモリのリセット																		*/
/*																									*/
/****************************************************************************************************/
void	MlibResetLongMemory( void *mempx, LONG xlwd )
{
LONG	i;

		for( i=0; i<xlwd; i++ )
		{
			((LONG *)mempx)[i] = 0;
		}
		return;

}



/****************************************************************************************************/
/*																									*/
/*		KSGAIN → LONG Data 変換																	*/
/*																									*/
/****************************************************************************************************/
LONG	MlibKsgain2Long( KSGAIN Input )
{
	LONG	kx;
	LONG	sx;

	//kx = (LONG)((Input << 8) >> 8);
	//sx = (LONG)(Input >> 24);
	kx = (((LONG)Input << 8) >> 8);
	sx = ((LONG)Input >> 24);

	return	kx >> sx;
}



/****************************************************************************************************/
/*																									*/
/*																									*/
/*		<<<<< 高速版：固定小数点ゲイン(16bit.16bit) >>>>>											*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(高速版：固定小数点ゲイン)				rv = (k*u)>>16;							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibHsMulgain( LONG u, LONG kx )
{
LONG	lwk;
LONG	xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		xx = u * kx (32bit*32bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );								/* xx[] = {xh,xl} = u * kx				*/
/*--------------------------------------------------------------------------------------------------*/
/*		上下限チェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( xx[1] >= 0x0100 )								/* Check Upper Limit					*/
		{
			return(  0x01000000 );
		}
		else if( xx[1] < -0x0100 )							/* Check Lower Limit					*/
		{
			return( -0x01000000 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		演算結果編集																				*/
/*--------------------------------------------------------------------------------------------------*/
		lwk = (LONG)(xx[1]<<16) + ((((ULONG)xx[0]>>15) + 1)>>1);
		return( lwk );

}



/****************************************************************************************************/
/*																									*/
/*		ゲイン乗算(高速版：固定小数点ゲイン, Limit無し)		rv = (k*u)>>16;							*/
/*																									*/
/****************************************************************************************************/
LONG	MlibHsMulgainNolim( LONG u, LONG kx )
{
LONG	lwk;
LONG	xx[2];

/*--------------------------------------------------------------------------------------------------*/
/*		xx = u * kx (32bit*32bit)																	*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );								/* xx[] = {xh,xl} = u * kx				*/
/*--------------------------------------------------------------------------------------------------*/
/*		演算結果編集																				*/
/*--------------------------------------------------------------------------------------------------*/
		lwk = (LONG)(xx[1]<<16) + ((((ULONG)xx[0]>>15) + 1)>>1);
		return( lwk );

}



/****************************************************************************************************/
/*																									*/
/*		積分演算(高速版：固定小数点ゲイン)					iu=iu+(k*u); rv=((iu[1]+1)>>1);			*/
/*																									*/
/****************************************************************************************************/
LONG	MlibHsIntegral( LONG u, LONG kx, LONG iu[2] )
{
LONG	xx[2];
LONG	carry;

/*--------------------------------------------------------------------------------------------------*/
/*		入力演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( xx[1] > 0x0100 )
		{
			iu[1] = iu[1] + (LONG)0x02000000;
		}
		else if( xx[1] < -0x0100 )
		{
			iu[1] = iu[1] - (LONG)0x02000000;
		}
		else
		{
			carry = ( ((ULONG)(iu[0]+(xx[0]<<17))) < (ULONG)iu[0] );
			iu[0] = iu[0] + (xx[0]<<17);
			iu[1] = iu[1] + (xx[1]<<17) + ((ULONG)xx[0]>>15) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( iu[1] >= (LONG)0x02000000 )
		{
			iu[0] = 0;
			iu[1] = 0x02000000;
		}
		else if( iu[1] < (LONG)-0x02000000 )
		{
			iu[0] =  0;
			iu[1] = -0x02000000;
		}
/*--------------------------------------------------------------------------------------------------*/
		return( ((iu[1]+1)>>1) );

}

/****************************************************************************************************/
/*																									*/
/*		サーチビットＯＮ(LSB/MSBからサーチ, 戻り値:BitNo/NG(-1))									*/
/*																									*/
/****************************************************************************************************/
LONG	MlibSrhbiton( ULONG data, ULONG dir )
{
LONG	BitNo = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		None ON Bit : data == 0																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( data == 0 )
		{
			return( -1 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Search from LSB																				*/
/*--------------------------------------------------------------------------------------------------*/
		else if( dir == SRH_FROM_LSB )
		{
			if( (data & 0xFFFF) == 0 ){ BitNo += 16; data = data>>16;}
			if( (data & 0x00FF) == 0 ){ BitNo +=  8; data = data>>8 ;}
			if( (data & 0x000F) == 0 ){ BitNo +=  4; data = data>>4 ;}
			if( (data & 0x0003) == 0 ){ BitNo +=  2; data = data>>2 ;}
			if( (data & 0x0001) == 0 ){ BitNo +=  1;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Search from MSB																				*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{/*kira_間違い修正_for_DataTrace_101108*/
			if( (data & 0xFFFF0000) != 0 ){ BitNo += 16; data = data>>16;}
			if( (data & 0x0000FF00) != 0 ){ BitNo +=  8; data = data>>8 ;}
			if( (data & 0x000000F0) != 0 ){ BitNo +=  4; data = data>>4 ;}
			if( (data & 0x0000000C) != 0 ){ BitNo +=  2; data = data>>2 ;}
			if( (data & 0x00000002) != 0 ){ BitNo +=  1;}
		}
/*--------------------------------------------------------------------------------------------------*/
		return( BitNo );

}


/****************************************************************************************************/
/*																									*/
/*		２の累乗チェック (戻値 : BitNo/NG(-1))														*/
/*																									*/
/****************************************************************************************************/
LONG	MlibCheckPowerOf2( ULONG x )
{
LONG	BitNo;

		BitNo = MlibSrhbiton( x, SRH_FROM_LSB );

		if( (BitNo >= 0) && (x == (ULONG)(1<<BitNo)) )
		{
			return( BitNo );
		}
		else
		{
			return( -1 );
		}

}



/****************************************************************************************************/
/*																									*/
/*		バイトメモリコピー			//kira_for_MEMOBUS_Message										*/
/*																									*/
/****************************************************************************************************/
void	MlibCopyByteMemory( void *dstMem, const void *srcMem, INT nbyte )
{
	CHAR *dst, *src;

	dst = (CHAR*)dstMem;
	src = (CHAR*)srcMem;
	while( nbyte > 0 )
	{
		*dst = *src;
		dst++;
		src++;
		nbyte--;
	}
}



/****************************************************************************************************/
/*																									*/
/*		ロングメモリコピー																			*/
/*																									*/
/****************************************************************************************************/
void	MlibCopyLongMemory( void *dstMem, void *srcMem, INT nbyte )
{
	ULONG *dst, *src;

	dst = (ULONG*)dstMem;
	src = (ULONG*)srcMem;
	while( nbyte > 0 )
	{
		*dst = *src;
		dst++;
		src++;
		nbyte--;
	}
}



/****************************************************************************************************/
/*																									*/
/*		高速Ｓｉｎ演算テーブル：入力:[360deg/1024], 出力:[1.0/16384]								*/
/*																									*/
/****************************************************************************************************/
const	SHORT	MlibFastSinTbl[1024] = {
	     0,   101,   201,   302,   402,   503,   603,   704,
	   804,   904,  1005,  1105,  1205,  1306,  1406,  1506,
	  1606,  1706,  1806,  1906,  2006,  2105,  2205,  2305,
	  2404,  2503,  2603,  2702,  2801,  2900,  2999,  3098,
	  3196,  3295,  3393,  3492,  3590,  3688,  3786,  3883,
	  3981,  4078,  4176,  4273,  4370,  4467,  4563,  4660,
	  4756,  4852,  4948,  5044,  5139,  5235,  5330,  5425,
	  5520,  5614,  5708,  5803,  5897,  5990,  6084,  6177,
	  6270,  6363,  6455,  6547,  6639,  6731,  6823,  6914,
	  7005,  7096,  7186,  7276,  7366,  7456,  7545,  7635,
	  7723,  7812,  7900,  7988,  8076,  8163,  8250,  8337,
	  8423,  8509,  8595,  8680,  8765,  8850,  8935,  9019,
	  9102,  9186,  9269,  9352,  9434,  9516,  9598,  9679,
	  9760,  9841,  9921, 10001, 10080, 10159, 10238, 10316,
	 10394, 10471, 10549, 10625, 10702, 10778, 10853, 10928,
	 11003, 11077, 11151, 11224, 11297, 11370, 11442, 11514,
	 11585, 11656, 11727, 11797, 11866, 11935, 12004, 12072,
	 12140, 12207, 12274, 12340, 12406, 12472, 12537, 12601,
	 12665, 12729, 12792, 12854, 12916, 12978, 13039, 13100,
	 13160, 13219, 13279, 13337, 13395, 13453, 13510, 13567,
	 13623, 13678, 13733, 13788, 13842, 13896, 13949, 14001,
	 14053, 14104, 14155, 14206, 14256, 14305, 14354, 14402,
	 14449, 14497, 14543, 14589, 14635, 14680, 14724, 14768,
	 14811, 14854, 14896, 14937, 14978, 15019, 15059, 15098,
	 15137, 15175, 15213, 15250, 15286, 15322, 15357, 15392,
	 15426, 15460, 15493, 15525, 15557, 15588, 15619, 15649,
	 15679, 15707, 15736, 15763, 15791, 15817, 15843, 15868,
	 15893, 15917, 15941, 15964, 15986, 16008, 16029, 16049,
	 16069, 16088, 16107, 16125, 16143, 16160, 16176, 16192,
	 16207, 16221, 16235, 16248, 16261, 16273, 16284, 16295,
	 16305, 16315, 16324, 16332, 16340, 16347, 16353, 16359,
	 16364, 16369, 16373, 16376, 16379, 16381, 16383, 16384,
/*--------------------------------------------------------------------------------------------------*/
	 16384, 16384, 16383, 16381, 16379, 16376, 16373, 16369,
	 16364, 16359, 16353, 16347, 16340, 16332, 16324, 16315,
	 16305, 16295, 16284, 16273, 16261, 16248, 16235, 16221,
	 16207, 16192, 16176, 16160, 16143, 16125, 16107, 16088,
	 16069, 16049, 16029, 16008, 15986, 15964, 15941, 15917,
	 15893, 15868, 15843, 15817, 15791, 15763, 15736, 15707,
	 15679, 15649, 15619, 15588, 15557, 15525, 15493, 15460,
	 15426, 15392, 15357, 15322, 15286, 15250, 15213, 15175,
	 15137, 15098, 15059, 15019, 14978, 14937, 14896, 14854,
	 14811, 14768, 14724, 14680, 14635, 14589, 14543, 14497,
	 14449, 14402, 14354, 14305, 14256, 14206, 14155, 14104,
	 14053, 14001, 13949, 13896, 13842, 13788, 13733, 13678,
	 13623, 13567, 13510, 13453, 13395, 13337, 13279, 13219,
	 13160, 13100, 13039, 12978, 12916, 12854, 12792, 12729,
	 12665, 12601, 12537, 12472, 12406, 12340, 12274, 12207,
	 12140, 12072, 12004, 11935, 11866, 11797, 11727, 11656,
	 11585, 11514, 11442, 11370, 11297, 11224, 11151, 11077,
	 11003, 10928, 10853, 10778, 10702, 10625, 10549, 10471,
	 10394, 10316, 10238, 10159, 10080, 10001,  9921,  9841,
	  9760,  9679,  9598,  9516,  9434,  9352,  9269,  9186,
	  9102,  9019,  8935,  8850,  8765,  8680,  8595,  8509,
	  8423,  8337,  8250,  8163,  8076,  7988,  7900,  7812,
	  7723,  7635,  7545,  7456,  7366,  7276,  7186,  7096,
	  7005,  6914,  6823,  6731,  6639,  6547,  6455,  6363,
	  6270,  6177,  6084,  5990,  5897,  5803,  5708,  5614,
	  5520,  5425,  5330,  5235,  5139,  5044,  4948,  4852,
	  4756,  4660,  4563,  4467,  4370,  4273,  4176,  4078,
	  3981,  3883,  3786,  3688,  3590,  3492,  3393,  3295,
	  3196,  3098,  2999,  2900,  2801,  2702,  2603,  2503,
	  2404,  2305,  2205,  2105,  2006,  1906,  1806,  1706,
	  1606,  1506,  1406,  1306,  1205,  1105,  1005,   904,
	   804,   704,   603,   503,   402,   302,   201,   101,
/*--------------------------------------------------------------------------------------------------*/
	     0,  -101,  -201,  -302,  -402,  -503,  -603,  -704,
	  -804,  -904, -1005, -1105, -1205, -1306, -1406, -1506,
	 -1606, -1706, -1806, -1906, -2006, -2105, -2205, -2305,
	 -2404, -2503, -2603, -2702, -2801, -2900, -2999, -3098,
	 -3196, -3295, -3393, -3492, -3590, -3688, -3786, -3883,
	 -3981, -4078, -4176, -4273, -4370, -4467, -4563, -4660,
	 -4756, -4852, -4948, -5044, -5139, -5235, -5330, -5425,
	 -5520, -5614, -5708, -5803, -5897, -5990, -6084, -6177,
	 -6270, -6363, -6455, -6547, -6639, -6731, -6823, -6914,
	 -7005, -7096, -7186, -7276, -7366, -7456, -7545, -7635,
	 -7723, -7812, -7900, -7988, -8076, -8163, -8250, -8337,
	 -8423, -8509, -8595, -8680, -8765, -8850, -8935, -9019,
	 -9102, -9186, -9269, -9352, -9434, -9516, -9598, -9679,
	 -9760, -9841, -9921,-10001,-10080,-10159,-10238,-10316,
	-10394,-10471,-10549,-10625,-10702,-10778,-10853,-10928,
	-11003,-11077,-11151,-11224,-11297,-11370,-11442,-11514,
	-11585,-11656,-11727,-11797,-11866,-11935,-12004,-12072,
	-12140,-12207,-12274,-12340,-12406,-12472,-12537,-12601,
	-12665,-12729,-12792,-12854,-12916,-12978,-13039,-13100,
	-13160,-13219,-13279,-13337,-13395,-13453,-13510,-13567,
	-13623,-13678,-13733,-13788,-13842,-13896,-13949,-14001,
	-14053,-14104,-14155,-14206,-14256,-14305,-14354,-14402,
	-14449,-14497,-14543,-14589,-14635,-14680,-14724,-14768,
	-14811,-14854,-14896,-14937,-14978,-15019,-15059,-15098,
	-15137,-15175,-15213,-15250,-15286,-15322,-15357,-15392,
	-15426,-15460,-15493,-15525,-15557,-15588,-15619,-15649,
	-15679,-15707,-15736,-15763,-15791,-15817,-15843,-15868,
	-15893,-15917,-15941,-15964,-15986,-16008,-16029,-16049,
	-16069,-16088,-16107,-16125,-16143,-16160,-16176,-16192,
	-16207,-16221,-16235,-16248,-16261,-16273,-16284,-16295,
	-16305,-16315,-16324,-16332,-16340,-16347,-16353,-16359,
	-16364,-16369,-16373,-16376,-16379,-16381,-16383,-16384,
/*--------------------------------------------------------------------------------------------------*/
	-16384,-16384,-16383,-16381,-16379,-16376,-16373,-16369,
	-16364,-16359,-16353,-16347,-16340,-16332,-16324,-16315,
	-16305,-16295,-16284,-16273,-16261,-16248,-16235,-16221,
	-16207,-16192,-16176,-16160,-16143,-16125,-16107,-16088,
	-16069,-16049,-16029,-16008,-15986,-15964,-15941,-15917,
	-15893,-15868,-15843,-15817,-15791,-15763,-15736,-15707,
	-15679,-15649,-15619,-15588,-15557,-15525,-15493,-15460,
	-15426,-15392,-15357,-15322,-15286,-15250,-15213,-15175,
	-15137,-15098,-15059,-15019,-14978,-14937,-14896,-14854,
	-14811,-14768,-14724,-14680,-14635,-14589,-14543,-14497,
	-14449,-14402,-14354,-14305,-14256,-14206,-14155,-14104,
	-14053,-14001,-13949,-13896,-13842,-13788,-13733,-13678,
	-13623,-13567,-13510,-13453,-13395,-13337,-13279,-13219,
	-13160,-13100,-13039,-12978,-12916,-12854,-12792,-12729,
	-12665,-12601,-12537,-12472,-12406,-12340,-12274,-12207,
	-12140,-12072,-12004,-11935,-11866,-11797,-11727,-11656,
	-11585,-11514,-11442,-11370,-11297,-11224,-11151,-11077,
	-11003,-10928,-10853,-10778,-10702,-10625,-10549,-10471,
	-10394,-10316,-10238,-10159,-10080,-10001, -9921, -9841,
	 -9760, -9679, -9598, -9516, -9434, -9352, -9269, -9186,
	 -9102, -9019, -8935, -8850, -8765, -8680, -8595, -8509,
	 -8423, -8337, -8250, -8163, -8076, -7988, -7900, -7812,
	 -7723, -7635, -7545, -7456, -7366, -7276, -7186, -7096,
	 -7005, -6914, -6823, -6731, -6639, -6547, -6455, -6363,
	 -6270, -6177, -6084, -5990, -5897, -5803, -5708, -5614,
	 -5520, -5425, -5330, -5235, -5139, -5044, -4948, -4852,
	 -4756, -4660, -4563, -4467, -4370, -4273, -4176, -4078,
	 -3981, -3883, -3786, -3688, -3590, -3492, -3393, -3295,
	 -3196, -3098, -2999, -2900, -2801, -2702, -2603, -2503,
	 -2404, -2305, -2205, -2105, -2006, -1906, -1806, -1706,
	 -1606, -1506, -1406, -1306, -1205, -1105, -1005,  -904,
	  -804,  -704,  -603,  -503,  -402,  -302,  -201,  -101,
};



/************************************* end of file **************************************************/
